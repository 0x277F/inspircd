<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>InspIRCd: Server Class Reference</title>
<link href="inspircd.doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4-20050815 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>Server Class Reference</h1><!-- doxytag: class="Server" --><!-- doxytag: inherits="classbase" -->Allows server output and query functions This class contains methods which allow a module to query the state of the irc server, and produce output to users and other servers.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="modules_8h-source.html">modules.h</a>&gt;</code>
<p>
Inheritance diagram for Server:<p><center><img src="classServer__inherit__graph.gif" border="0" usemap="#Server__inherit__map" alt="Inheritance graph"></center>
<map name="Server__inherit__map">
<area href="classclassbase.html" shape="rect" coords="7,7,87,34" alt="">
</map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center>Collaboration diagram for Server:<p><center><img src="classServer__coll__graph.gif" border="0" usemap="#Server__coll__map" alt="Collaboration graph"></center>
<map name="Server__coll__map">
<area href="classclassbase.html" shape="rect" coords="7,97,87,124" alt="">
</map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center><a href="classServer-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#Server_28_29">Server</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor.  <a href="#Server_28_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#_7EServer_28_29">~Server</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default destructor.  <a href="#_7EServer_28_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#SendOpers_28std_3A_3Astring_20s_29">SendOpers</a> (<a class="el" href="namespaceirc.html#string">std::string</a> s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends text to all opers.  <a href="#SendOpers_28std_3A_3Astring_20s_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#Log_28int_20level_2C_20std_3A_3Astring_20s_29">Log</a> (int level, <a class="el" href="namespaceirc.html#string">std::string</a> s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a log string.  <a href="#Log_28int_20level_2C_20std_3A_3Astring_20s_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#Send_28int_20Socket_2C_20std_3A_3Astring_20s_29">Send</a> (int Socket, <a class="el" href="namespaceirc.html#string">std::string</a> s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends a line of text down a TCP/IP socket.  <a href="#Send_28int_20Socket_2C_20std_3A_3Astring_20s_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#SendServ_28int_20Socket_2C_20std_3A_3Astring_20s_29">SendServ</a> (int Socket, <a class="el" href="namespaceirc.html#string">std::string</a> s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends text from the server to a socket.  <a href="#SendServ_28int_20Socket_2C_20std_3A_3Astring_20s_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#SendChannelServerNotice_28std_3A_3Astring_20ServName_2C_20chanrec_20_2AChannel_2C_20std_3A_3Astring_20text_29">SendChannelServerNotice</a> (<a class="el" href="namespaceirc.html#string">std::string</a> ServName, <a class="el" href="classchanrec.html">chanrec</a> *Channel, <a class="el" href="namespaceirc.html#string">std::string</a> text)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes text to a channel, but from a server, including all.  <a href="#SendChannelServerNotice_28std_3A_3Astring_20ServName_2C_20chanrec_20_2AChannel_2C_20std_3A_3Astring_20text_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#SendFrom_28int_20Socket_2C_20userrec_20_2AUser_2C_20std_3A_3Astring_20s_29">SendFrom</a> (int Socket, <a class="el" href="classuserrec.html">userrec</a> *User, <a class="el" href="namespaceirc.html#string">std::string</a> s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends text from a user to a socket.  <a href="#SendFrom_28int_20Socket_2C_20userrec_20_2AUser_2C_20std_3A_3Astring_20s_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#SendTo_28userrec_20_2ASource_2C_20userrec_20_2ADest_2C_20std_3A_3Astring_20s_29">SendTo</a> (<a class="el" href="classuserrec.html">userrec</a> *Source, <a class="el" href="classuserrec.html">userrec</a> *Dest, <a class="el" href="namespaceirc.html#string">std::string</a> s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends text from a user to another user.  <a href="#SendTo_28userrec_20_2ASource_2C_20userrec_20_2ADest_2C_20std_3A_3Astring_20s_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#SendChannel_28userrec_20_2AUser_2C_20chanrec_20_2AChannel_2C_20std_3A_3Astring_20s_2C_20bool_20IncludeSender_29">SendChannel</a> (<a class="el" href="classuserrec.html">userrec</a> *User, <a class="el" href="classchanrec.html">chanrec</a> *Channel, <a class="el" href="namespaceirc.html#string">std::string</a> s, bool IncludeSender)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends text from a user to a channel (mulicast).  <a href="#SendChannel_28userrec_20_2AUser_2C_20chanrec_20_2AChannel_2C_20std_3A_3Astring_20s_2C_20bool_20IncludeSender_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#CommonChannels_28userrec_20_2Au_31_2C_20userrec_20_2Au_32_29">CommonChannels</a> (<a class="el" href="classuserrec.html">userrec</a> *u1, <a class="el" href="classuserrec.html">userrec</a> *u2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if two users share a common channel.  <a href="#CommonChannels_28userrec_20_2Au_31_2C_20userrec_20_2Au_32_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#SendCommon_28userrec_20_2AUser_2C_20std_3A_3Astring_20text_2C_20bool_20IncludeSender_29">SendCommon</a> (<a class="el" href="classuserrec.html">userrec</a> *User, <a class="el" href="namespaceirc.html#string">std::string</a> text, bool IncludeSender)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends text from a user to one or more channels (mulicast).  <a href="#SendCommon_28userrec_20_2AUser_2C_20std_3A_3Astring_20text_2C_20bool_20IncludeSender_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#SendWallops_28userrec_20_2AUser_2C_20std_3A_3Astring_20text_29">SendWallops</a> (<a class="el" href="classuserrec.html">userrec</a> *User, <a class="el" href="namespaceirc.html#string">std::string</a> text)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends a WALLOPS message.  <a href="#SendWallops_28userrec_20_2AUser_2C_20std_3A_3Astring_20text_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#IsNick_28std_3A_3Astring_20nick_29">IsNick</a> (<a class="el" href="namespaceirc.html#string">std::string</a> nick)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if a nick is valid.  <a href="#IsNick_28std_3A_3Astring_20nick_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#CountUsers_28chanrec_20_2Ac_29">CountUsers</a> (<a class="el" href="classchanrec.html">chanrec</a> *c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a count of the number of users on a channel.  <a href="#CountUsers_28chanrec_20_2Ac_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classuserrec.html">userrec</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#FindNick_28std_3A_3Astring_20nick_29">FindNick</a> (<a class="el" href="namespaceirc.html#string">std::string</a> nick)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempts to look up a nick and return a pointer to it.  <a href="#FindNick_28std_3A_3Astring_20nick_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classuserrec.html">userrec</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#FindDescriptor_28int_20socket_29">FindDescriptor</a> (int socket)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempts to look up a nick using the file descriptor associated with that nick.  <a href="#FindDescriptor_28int_20socket_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classchanrec.html">chanrec</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#FindChannel_28std_3A_3Astring_20channel_29">FindChannel</a> (<a class="el" href="namespaceirc.html#string">std::string</a> channel)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempts to look up a channel and return a pointer to it.  <a href="#FindChannel_28std_3A_3Astring_20channel_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#ChanMode_28userrec_20_2AUser_2C_20chanrec_20_2AChan_29">ChanMode</a> (<a class="el" href="classuserrec.html">userrec</a> *User, <a class="el" href="classchanrec.html">chanrec</a> *Chan)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempts to look up a user's privilages on a channel.  <a href="#ChanMode_28userrec_20_2AUser_2C_20chanrec_20_2AChan_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#IsOnChannel_28userrec_20_2AUser_2C_20chanrec_20_2AChan_29">IsOnChannel</a> (<a class="el" href="classuserrec.html">userrec</a> *User, <a class="el" href="classchanrec.html">chanrec</a> *Chan)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if a user is on a channel.  <a href="#IsOnChannel_28userrec_20_2AUser_2C_20chanrec_20_2AChan_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#GetServerName_28_29">GetServerName</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the server name of the server where the module is loaded.  <a href="#GetServerName_28_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#GetNetworkName_28_29">GetNetworkName</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the network name, global to all linked servers.  <a href="#GetNetworkName_28_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#GetServerDescription_28_29">GetServerDescription</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the server description string of the local server.  <a href="#GetServerDescription_28_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classAdmin.html">Admin</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#GetAdmin_28_29">GetAdmin</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the information of the server as returned by the /ADMIN command.  <a href="#GetAdmin_28_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#AddExtendedMode_28char_20modechar_2C_20int_20type_2C_20bool_20requires_5Foper_2C_20int_20params_5Fwhen_5Fon_2C_20int_20params_5Fwhen_5Foff_29">AddExtendedMode</a> (char modechar, int type, bool requires_oper, int params_when_on, int params_when_off)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds an extended mode letter which is parsed by a module.  <a href="#AddExtendedMode_28char_20modechar_2C_20int_20type_2C_20bool_20requires_5Foper_2C_20int_20params_5Fwhen_5Fon_2C_20int_20params_5Fwhen_5Foff_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#AddExtendedListMode_28char_20modechar_29">AddExtendedListMode</a> (char modechar)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds an extended mode letter which is parsed by a module and handled in a list fashion.  <a href="#AddExtendedListMode_28char_20modechar_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#AddCommand_28char_20_2Acmd_2C_20handlerfunc_20f_2C_20char_20flags_2C_20int_20minparams_2C_20char_20_2Asource_29">AddCommand</a> (char *cmd, handlerfunc f, char flags, int minparams, char *source)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a command to the command table.  <a href="#AddCommand_28char_20_2Acmd_2C_20handlerfunc_20f_2C_20char_20flags_2C_20int_20minparams_2C_20char_20_2Asource_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#SendMode_28char_20_2A_2Aparameters_2C_20int_20pcnt_2C_20userrec_20_2Auser_29">SendMode</a> (char **parameters, int pcnt, <a class="el" href="classuserrec.html">userrec</a> *user)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends a servermode.  <a href="#SendMode_28char_20_2A_2Aparameters_2C_20int_20pcnt_2C_20userrec_20_2Auser_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#SendToModeMask_28std_3A_3Astring_20modes_2C_20int_20flags_2C_20std_3A_3Astring_20text_29">SendToModeMask</a> (<a class="el" href="namespaceirc.html#string">std::string</a> modes, int flags, <a class="el" href="namespaceirc.html#string">std::string</a> text)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends to all users matching a mode mask You must specify one or more usermodes as the first parameter.  <a href="#SendToModeMask_28std_3A_3Astring_20modes_2C_20int_20flags_2C_20std_3A_3Astring_20text_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classchanrec.html">chanrec</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#JoinUserToChannel_28userrec_20_2Auser_2C_20std_3A_3Astring_20cname_2C_20std_3A_3Astring_20key_29">JoinUserToChannel</a> (<a class="el" href="classuserrec.html">userrec</a> *user, <a class="el" href="namespaceirc.html#string">std::string</a> cname, <a class="el" href="namespaceirc.html#string">std::string</a> key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Forces a user to join a channel.  <a href="#JoinUserToChannel_28userrec_20_2Auser_2C_20std_3A_3Astring_20cname_2C_20std_3A_3Astring_20key_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classchanrec.html">chanrec</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#PartUserFromChannel_28userrec_20_2Auser_2C_20std_3A_3Astring_20cname_2C_20std_3A_3Astring_20reason_29">PartUserFromChannel</a> (<a class="el" href="classuserrec.html">userrec</a> *user, <a class="el" href="namespaceirc.html#string">std::string</a> cname, <a class="el" href="namespaceirc.html#string">std::string</a> reason)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Forces a user to part a channel.  <a href="#PartUserFromChannel_28userrec_20_2Auser_2C_20std_3A_3Astring_20cname_2C_20std_3A_3Astring_20reason_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#ChangeUserNick_28userrec_20_2Auser_2C_20std_3A_3Astring_20nickname_29">ChangeUserNick</a> (<a class="el" href="classuserrec.html">userrec</a> *user, <a class="el" href="namespaceirc.html#string">std::string</a> nickname)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Forces a user nickchange.  <a href="#ChangeUserNick_28userrec_20_2Auser_2C_20std_3A_3Astring_20nickname_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#QuitUser_28userrec_20_2Auser_2C_20std_3A_3Astring_20reason_29">QuitUser</a> (<a class="el" href="classuserrec.html">userrec</a> *user, <a class="el" href="namespaceirc.html#string">std::string</a> reason)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Forces a user to quit with the specified reason.  <a href="#QuitUser_28userrec_20_2Auser_2C_20std_3A_3Astring_20reason_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#MatchText_28std_3A_3Astring_20sliteral_2C_20std_3A_3Astring_20spattern_29">MatchText</a> (<a class="el" href="namespaceirc.html#string">std::string</a> sliteral, <a class="el" href="namespaceirc.html#string">std::string</a> spattern)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Matches text against a glob pattern.  <a href="#MatchText_28std_3A_3Astring_20sliteral_2C_20std_3A_3Astring_20spattern_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#CallCommandHandler_28std_3A_3Astring_20commandname_2C_20char_20_2A_2Aparameters_2C_20int_20pcnt_2C_20userrec_20_2Auser_29">CallCommandHandler</a> (<a class="el" href="namespaceirc.html#string">std::string</a> commandname, char **parameters, int pcnt, <a class="el" href="classuserrec.html">userrec</a> *user)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calls the handler for a command, either implemented by the core or by another module.  <a href="#CallCommandHandler_28std_3A_3Astring_20commandname_2C_20char_20_2A_2Aparameters_2C_20int_20pcnt_2C_20userrec_20_2Auser_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#IsValidModuleCommand_28std_3A_3Astring_20commandname_2C_20int_20pcnt_2C_20userrec_20_2Auser_29">IsValidModuleCommand</a> (<a class="el" href="namespaceirc.html#string">std::string</a> commandname, int pcnt, <a class="el" href="classuserrec.html">userrec</a> *user)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#ChangeHost_28userrec_20_2Auser_2C_20std_3A_3Astring_20host_29">ChangeHost</a> (<a class="el" href="classuserrec.html">userrec</a> *user, <a class="el" href="namespaceirc.html#string">std::string</a> host)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change displayed hostname of a user.  <a href="#ChangeHost_28userrec_20_2Auser_2C_20std_3A_3Astring_20host_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#ChangeGECOS_28userrec_20_2Auser_2C_20std_3A_3Astring_20gecos_29">ChangeGECOS</a> (<a class="el" href="classuserrec.html">userrec</a> *user, <a class="el" href="namespaceirc.html#string">std::string</a> gecos)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change GECOS (fullname) of a user.  <a href="#ChangeGECOS_28userrec_20_2Auser_2C_20std_3A_3Astring_20gecos_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#IsUlined_28std_3A_3Astring_20server_29">IsUlined</a> (<a class="el" href="namespaceirc.html#string">std::string</a> server)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the servername you give is ulined.  <a href="#IsUlined_28std_3A_3Astring_20server_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="modules_8h.html#chanuserlist">chanuserlist</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#GetUsers_28chanrec_20_2Achan_29">GetUsers</a> (<a class="el" href="classchanrec.html">chanrec</a> *chan)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetches the userlist of a channel.  <a href="#GetUsers_28chanrec_20_2Achan_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#UserToPseudo_28userrec_20_2Auser_2C_20std_3A_3Astring_20message_29">UserToPseudo</a> (<a class="el" href="classuserrec.html">userrec</a> *user, <a class="el" href="namespaceirc.html#string">std::string</a> message)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a user's connection to the irc server, but leave their client in existence in the user hash.  <a href="#UserToPseudo_28userrec_20_2Auser_2C_20std_3A_3Astring_20message_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#PseudoToUser_28userrec_20_2Aalive_2C_20userrec_20_2Azombie_2C_20std_3A_3Astring_20message_29">PseudoToUser</a> (<a class="el" href="classuserrec.html">userrec</a> *alive, <a class="el" href="classuserrec.html">userrec</a> *zombie, <a class="el" href="namespaceirc.html#string">std::string</a> message)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This user takes one user, and switches their file descriptor with another user, so that one user "becomes" the other.  <a href="#PseudoToUser_28userrec_20_2Aalive_2C_20userrec_20_2Azombie_2C_20std_3A_3Astring_20message_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#AddGLine_28long_20duration_2C_20std_3A_3Astring_20source_2C_20std_3A_3Astring_20reason_2C_20std_3A_3Astring_20hostmask_29">AddGLine</a> (long duration, <a class="el" href="namespaceirc.html#string">std::string</a> source, <a class="el" href="namespaceirc.html#string">std::string</a> reason, <a class="el" href="namespaceirc.html#string">std::string</a> hostmask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a G-line The G-line is propogated to all of the servers in the mesh and enforced as soon as it is added.  <a href="#AddGLine_28long_20duration_2C_20std_3A_3Astring_20source_2C_20std_3A_3Astring_20reason_2C_20std_3A_3Astring_20hostmask_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#AddQLine_28long_20duration_2C_20std_3A_3Astring_20source_2C_20std_3A_3Astring_20reason_2C_20std_3A_3Astring_20nickname_29">AddQLine</a> (long duration, <a class="el" href="namespaceirc.html#string">std::string</a> source, <a class="el" href="namespaceirc.html#string">std::string</a> reason, <a class="el" href="namespaceirc.html#string">std::string</a> nickname)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a Q-line The Q-line is propogated to all of the servers in the mesh and enforced as soon as it is added.  <a href="#AddQLine_28long_20duration_2C_20std_3A_3Astring_20source_2C_20std_3A_3Astring_20reason_2C_20std_3A_3Astring_20nickname_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#AddZLine_28long_20duration_2C_20std_3A_3Astring_20source_2C_20std_3A_3Astring_20reason_2C_20std_3A_3Astring_20ipaddr_29">AddZLine</a> (long duration, <a class="el" href="namespaceirc.html#string">std::string</a> source, <a class="el" href="namespaceirc.html#string">std::string</a> reason, <a class="el" href="namespaceirc.html#string">std::string</a> ipaddr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a Z-line The Z-line is propogated to all of the servers in the mesh and enforced as soon as it is added.  <a href="#AddZLine_28long_20duration_2C_20std_3A_3Astring_20source_2C_20std_3A_3Astring_20reason_2C_20std_3A_3Astring_20ipaddr_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#AddKLine_28long_20duration_2C_20std_3A_3Astring_20source_2C_20std_3A_3Astring_20reason_2C_20std_3A_3Astring_20hostmask_29">AddKLine</a> (long duration, <a class="el" href="namespaceirc.html#string">std::string</a> source, <a class="el" href="namespaceirc.html#string">std::string</a> reason, <a class="el" href="namespaceirc.html#string">std::string</a> hostmask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a K-line The K-line is enforced as soon as it is added.  <a href="#AddKLine_28long_20duration_2C_20std_3A_3Astring_20source_2C_20std_3A_3Astring_20reason_2C_20std_3A_3Astring_20hostmask_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#AddELine_28long_20duration_2C_20std_3A_3Astring_20source_2C_20std_3A_3Astring_20reason_2C_20std_3A_3Astring_20hostmask_29">AddELine</a> (long duration, <a class="el" href="namespaceirc.html#string">std::string</a> source, <a class="el" href="namespaceirc.html#string">std::string</a> reason, <a class="el" href="namespaceirc.html#string">std::string</a> hostmask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a E-line The E-line is enforced as soon as it is added.  <a href="#AddELine_28long_20duration_2C_20std_3A_3Astring_20source_2C_20std_3A_3Astring_20reason_2C_20std_3A_3Astring_20hostmask_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#DelGLine_28std_3A_3Astring_20hostmask_29">DelGLine</a> (<a class="el" href="namespaceirc.html#string">std::string</a> hostmask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes a G-Line from all servers on the mesh.  <a href="#DelGLine_28std_3A_3Astring_20hostmask_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#DelQLine_28std_3A_3Astring_20nickname_29">DelQLine</a> (<a class="el" href="namespaceirc.html#string">std::string</a> nickname)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes a Q-Line from all servers on the mesh.  <a href="#DelQLine_28std_3A_3Astring_20nickname_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#DelZLine_28std_3A_3Astring_20ipaddr_29">DelZLine</a> (<a class="el" href="namespaceirc.html#string">std::string</a> ipaddr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes a Z-Line from all servers on the mesh.  <a href="#DelZLine_28std_3A_3Astring_20ipaddr_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#DelKLine_28std_3A_3Astring_20hostmask_29">DelKLine</a> (<a class="el" href="namespaceirc.html#string">std::string</a> hostmask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes a local K-Line.  <a href="#DelKLine_28std_3A_3Astring_20hostmask_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#DelELine_28std_3A_3Astring_20hostmask_29">DelELine</a> (<a class="el" href="namespaceirc.html#string">std::string</a> hostmask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes a local E-Line.  <a href="#DelELine_28std_3A_3Astring_20hostmask_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#CalcDuration_28std_3A_3Astring_20duration_29">CalcDuration</a> (<a class="el" href="namespaceirc.html#string">std::string</a> duration)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates a duration This method will take a string containing a formatted duration (e.g.  <a href="#CalcDuration_28std_3A_3Astring_20duration_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#IsValidMask_28std_3A_3Astring_20mask_29">IsValidMask</a> (<a class="el" href="namespaceirc.html#string">std::string</a> mask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if a nick!ident string is correctly formatted, false if otherwise.  <a href="#IsValidMask_28std_3A_3Astring_20mask_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classModule.html">Module</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#FindModule_28std_3A_3Astring_20name_29">FindModule</a> (<a class="el" href="namespaceirc.html#string">std::string</a> name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function finds a module by name.  <a href="#FindModule_28std_3A_3Astring_20name_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#AddSocket_28InspSocket_20_2Asock_29">AddSocket</a> (<a class="el" href="classInspSocket.html">InspSocket</a> *sock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a class derived from <a class="el" href="classInspSocket.html">InspSocket</a> to the server's socket engine.  <a href="#AddSocket_28InspSocket_20_2Asock_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#DelSocket_28InspSocket_20_2Asock_29">DelSocket</a> (<a class="el" href="classInspSocket.html">InspSocket</a> *sock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes a class derived from <a class="el" href="classInspSocket.html">InspSocket</a> from the server's socket engine.  <a href="#DelSocket_28InspSocket_20_2Asock_29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer.html#RehashServer_28_29">RehashServer</a> ()</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Allows server output and query functions This class contains methods which allow a module to query the state of the irc server, and produce output to users and other servers. 
<p>
All modules should instantiate at least one copy of this class, and use its member functions to perform their tasks.
<p>

<p>
Definition at line <a class="el" href="modules_8h-source.html#l01081">1081</a> of file <a class="el" href="modules_8h-source.html">modules.h</a>.<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="Server_28_29"></a><!-- doxytag: member="Server::Server" ref="Server_28_29" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">Server::Server           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Default constructor. 
<p>
Creates a Server object.
<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00394">394</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.<div class="fragment"><pre class="fragment"><a name="l00395"></a>00395 {
<a name="l00396"></a>00396 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="_7EServer_28_29"></a><!-- doxytag: member="Server::~Server" ref="_7EServer_28_29" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">Server::~Server           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Default destructor. 
<p>
Destroys a Server object.
<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00398">398</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.<div class="fragment"><pre class="fragment"><a name="l00399"></a>00399 {
<a name="l00400"></a>00400 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="AddCommand_28char_20_2Acmd_2C_20handlerfunc_20f_2C_20char_20flags_2C_20int_20minparams_2C_20char_20_2Asource_29"></a><!-- doxytag: member="Server::AddCommand" ref="AddCommand_28char_20_2Acmd_2C_20handlerfunc_20f_2C_20char_20flags_2C_20int_20minparams_2C_20char_20_2Asource_29" args="(char *cmd, handlerfunc f, char flags, int minparams, char *source)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Server::AddCommand           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname" nowrap> <em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>handlerfunc&nbsp;</td>
          <td class="mdname" nowrap> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>char&nbsp;</td>
          <td class="mdname" nowrap> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>minparams</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>source</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Adds a command to the command table. 
<p>
This allows modules to add extra commands into the command table. You must place a function within your module which is is of type handlerfunc:<p>
typedef void (handlerfunc) (char**, int, userrec*); ... void <a class="el" href="commands_8h.html#handle_5Fkill_28char_20_2A_2Aparameters_2C_20int_20pcnt_2C_20userrec_20_2Auser_29">handle_kill(char **parameters, int pcnt, userrec *user)</a><p>
When the command is typed, the parameters will be placed into the parameters array (similar to argv) and the parameter count will be placed into pcnt (similar to argv). There will never be any less parameters than the 'minparams' value you specified when creating the command. The *user parameter is the class of the user which caused the command to trigger, who will always have the flag you specified in 'flags' when creating the initial command. For example to create an oper only command create the commands with flags='o'. The source parameter is used for resource tracking, and should contain the name of your module (with file extension) e.g. "m_blarp.so". If you place the wrong identifier here, you can cause crashes if your module is unloaded.
<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00495">495</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.
<p>
References <a class="el" href="modules_8h.html#createcommand_28char_20_2Acmd_2C_20handlerfunc_20f_2C_20char_20flags_2C_20int_20minparams_2C_20char_20_2Asource_29">createcommand()</a>.<div class="fragment"><pre class="fragment"><a name="l00496"></a>00496 {
<a name="l00497"></a>00497         <a class="code" href="modules_8h.html#createcommand_28char_20_2Acmd_2C_20handlerfunc_20f_2C_20char_20flags_2C_20int_20minparams_2C_20char_20_2Asource_29">createcommand</a>(cmd,f,flags,minparams,source);
<a name="l00498"></a>00498 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="AddELine_28long_20duration_2C_20std_3A_3Astring_20source_2C_20std_3A_3Astring_20reason_2C_20std_3A_3Astring_20hostmask_29"></a><!-- doxytag: member="Server::AddELine" ref="AddELine_28long_20duration_2C_20std_3A_3Astring_20source_2C_20std_3A_3Astring_20reason_2C_20std_3A_3Astring_20hostmask_29" args="(long duration, std::string source, std::string reason, std::string hostmask)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Server::AddELine           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">long&nbsp;</td>
          <td class="mdname" nowrap> <em>duration</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>reason</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>hostmask</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Adds a E-line The E-line is enforced as soon as it is added. 
<p>
The duration must be in seconds, however you can use the <a class="el" href="classServer.html#CalcDuration_28std_3A_3Astring_20duration_29">Server::CalcDuration</a> method to convert durations into the 1w2d3h3m6s format used by /GLINE etc. The source is an arbitary string used to indicate who or what sent the data, usually this is the nickname of a person, or a server name.
<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00758">758</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.
<p>
References <a class="el" href="xline_8h.html#add_5Feline_28long_20duration_2C_20const_20char_20_2Asource_2C_20const_20char_20_2Areason_2C_20const_20char_20_2Ahostmask_29">add_eline()</a>.<div class="fragment"><pre class="fragment"><a name="l00759"></a>00759 {
<a name="l00760"></a>00760         <a class="code" href="xline_8h.html#add_5Feline_28long_20duration_2C_20const_20char_20_2Asource_2C_20const_20char_20_2Areason_2C_20const_20char_20_2Ahostmask_29">add_eline</a>(<a class="code" href="commands_8h.html#duration_28const_20char_20_2Astr_29">duration</a>, source.c_str(), reason.c_str(), hostmask.c_str());
<a name="l00761"></a>00761 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="AddExtendedListMode_28char_20modechar_29"></a><!-- doxytag: member="Server::AddExtendedListMode" ref="AddExtendedListMode_28char_20modechar_29" args="(char modechar)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool Server::AddExtendedListMode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>modechar</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Adds an extended mode letter which is parsed by a module and handled in a list fashion. 
<p>
This call is used to implement modes like +q and +a. The characteristics of these modes are as follows:<p>
(1) They are ALWAYS on channels, not on users, therefore their type is MT_CHANNEL<p>
(2) They always take exactly one parameter when being added or removed<p>
(3) They can be set multiple times, usually on users in channels<p>
(4) The mode and its parameter are NOT stored in the channels modes structure<p>
It is down to the module handling the mode to maintain state and determine what 'items' (e.g. users, or a banlist) have the mode set on them, and process the modes at the correct times, e.g. during access checks on channels, etc. When the extended mode is triggered the OnExtendedMode method will be triggered as above. Note that the target you are given will be a channel, if for example your mode is set 'on a user' (in for example +a) you must use Server::Find to locate the user the mode is operating on. Your mode handler may return 1 to handle the mode AND tell the core to display the mode change, e.g. '+aaa one two three' in the case of the mode for 'two', or it may return -1 to 'eat' the mode change, so the above example would become '+aa one three' after processing.
<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00663">663</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.
<p>
References <a class="el" href="modules_8cpp-source.html#l00221">DoAddExtendedMode()</a>, <a class="el" href="modules_8cpp-source.html#l00231">ModeMakeList()</a>, and <a class="el" href="modules_8h-source.html#l00031">MT_CHANNEL</a>.<div class="fragment"><pre class="fragment"><a name="l00664"></a>00664 {
<a name="l00665"></a>00665         <span class="keywordtype">bool</span> res = <a class="code" href="modules_8cpp.html#DoAddExtendedMode_28char_20modechar_2C_20int_20type_2C_20bool_20requires_5Foper_2C_20int_20params_5Fon_2C_20int_20params_5Foff_29">DoAddExtendedMode</a>(modechar,<a class="code" href="modules_8h.html#MT_5FCHANNEL">MT_CHANNEL</a>,<span class="keyword">false</span>,1,1);
<a name="l00666"></a>00666         <span class="keywordflow">if</span> (res)
<a name="l00667"></a>00667                 <a class="code" href="modules_8cpp.html#ModeMakeList_28char_20modechar_29">ModeMakeList</a>(modechar);
<a name="l00668"></a>00668         <span class="keywordflow">return</span> res;
<a name="l00669"></a>00669 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="AddExtendedMode_28char_20modechar_2C_20int_20type_2C_20bool_20requires_5Foper_2C_20int_20params_5Fwhen_5Fon_2C_20int_20params_5Fwhen_5Foff_29"></a><!-- doxytag: member="Server::AddExtendedMode" ref="AddExtendedMode_28char_20modechar_2C_20int_20type_2C_20bool_20requires_5Foper_2C_20int_20params_5Fwhen_5Fon_2C_20int_20params_5Fwhen_5Foff_29" args="(char modechar, int type, bool requires_oper, int params_when_on, int params_when_off)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool Server::AddExtendedMode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char&nbsp;</td>
          <td class="mdname" nowrap> <em>modechar</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>requires_oper</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>params_when_on</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>params_when_off</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Adds an extended mode letter which is parsed by a module. 
<p>
This allows modules to add extra mode letters, e.g. +x for hostcloak. the "type" parameter is either MT_CHANNEL, MT_CLIENT, or MT_SERVER, to indicate wether the mode is a channel mode, a client mode, or a server mode. requires_oper is used with MT_CLIENT type modes only to indicate the mode can only be set or unset by an oper. If this is used for MT_CHANNEL type modes it is ignored. params_when_on is the number of modes to expect when the mode is turned on (for type MT_CHANNEL only), e.g. with mode +k, this would have a value of 1. the params_when_off value has a similar value to params_when_on, except it indicates the number of parameters to expect when the mode is disabled. Modes which act in a similar way to channel mode +l (e.g. require a parameter to enable, but not to disable) should use this parameter. The function returns false if the mode is unavailable, and will not attempt to allocate another character, as this will confuse users. This also means that as only one module can claim a specific mode character, the core does not need to keep track of which modules own which modes, which speeds up operation of the server. In this version, a mode can have at most one parameter, attempting to use more parameters will have undefined effects.
<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00635">635</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.
<p>
References <a class="el" href="modules_8h-source.html#l00023">DEBUG</a>, <a class="el" href="modules_8cpp-source.html#l00221">DoAddExtendedMode()</a>, <a class="el" href="modules_8h-source.html#l00032">MT_CLIENT</a>, and <a class="el" href="modules_8h-source.html#l00033">MT_SERVER</a>.<div class="fragment"><pre class="fragment"><a name="l00636"></a>00636 {
<a name="l00637"></a>00637         <span class="keywordflow">if</span> (((modechar &gt;= <span class="charliteral">'A'</span>) &amp;&amp; (modechar &lt;= <span class="charliteral">'Z'</span>)) || ((modechar &gt;= <span class="charliteral">'a'</span>) &amp;&amp; (modechar &lt;= <span class="charliteral">'z'</span>)))
<a name="l00638"></a>00638         {
<a name="l00639"></a>00639                 <span class="keywordflow">if</span> (type == <a class="code" href="modules_8h.html#MT_5FSERVER">MT_SERVER</a>)
<a name="l00640"></a>00640                 {
<a name="l00641"></a>00641                         log(<a class="code" href="modules_8h.html#DEBUG">DEBUG</a>,<span class="stringliteral">"*** API ERROR *** Modes of type MT_SERVER are reserved for future expansion"</span>);
<a name="l00642"></a>00642                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00643"></a>00643                 }
<a name="l00644"></a>00644                 <span class="keywordflow">if</span> (((params_when_on&gt;0) || (params_when_off&gt;0)) &amp;&amp; (type == <a class="code" href="modules_8h.html#MT_5FCLIENT">MT_CLIENT</a>))
<a name="l00645"></a>00645                 {
<a name="l00646"></a>00646                         log(<a class="code" href="modules_8h.html#DEBUG">DEBUG</a>,<span class="stringliteral">"*** API ERROR *** Parameters on MT_CLIENT modes are not supported"</span>);
<a name="l00647"></a>00647                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00648"></a>00648                 }
<a name="l00649"></a>00649                 <span class="keywordflow">if</span> ((params_when_on&gt;1) || (params_when_off&gt;1))
<a name="l00650"></a>00650                 {
<a name="l00651"></a>00651                         log(<a class="code" href="modules_8h.html#DEBUG">DEBUG</a>,<span class="stringliteral">"*** API ERROR *** More than one parameter for an MT_CHANNEL mode is not yet supported"</span>);
<a name="l00652"></a>00652                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00653"></a>00653                 }
<a name="l00654"></a>00654                 <span class="keywordflow">return</span> <a class="code" href="modules_8cpp.html#DoAddExtendedMode_28char_20modechar_2C_20int_20type_2C_20bool_20requires_5Foper_2C_20int_20params_5Fon_2C_20int_20params_5Foff_29">DoAddExtendedMode</a>(modechar,type,requires_oper,params_when_on,params_when_off);
<a name="l00655"></a>00655         }
<a name="l00656"></a>00656         <span class="keywordflow">else</span>
<a name="l00657"></a>00657         {
<a name="l00658"></a>00658                 log(<a class="code" href="modules_8h.html#DEBUG">DEBUG</a>,<span class="stringliteral">"*** API ERROR *** Muppet modechar detected."</span>);
<a name="l00659"></a>00659         }
<a name="l00660"></a>00660         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00661"></a>00661 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="AddGLine_28long_20duration_2C_20std_3A_3Astring_20source_2C_20std_3A_3Astring_20reason_2C_20std_3A_3Astring_20hostmask_29"></a><!-- doxytag: member="Server::AddGLine" ref="AddGLine_28long_20duration_2C_20std_3A_3Astring_20source_2C_20std_3A_3Astring_20reason_2C_20std_3A_3Astring_20hostmask_29" args="(long duration, std::string source, std::string reason, std::string hostmask)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Server::AddGLine           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">long&nbsp;</td>
          <td class="mdname" nowrap> <em>duration</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>reason</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>hostmask</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Adds a G-line The G-line is propogated to all of the servers in the mesh and enforced as soon as it is added. 
<p>
The duration must be in seconds, however you can use the <a class="el" href="classServer.html#CalcDuration_28std_3A_3Astring_20duration_29">Server::CalcDuration</a> method to convert durations into the 1w2d3h3m6s format used by /GLINE etc. The source is an arbitary string used to indicate who or what sent the data, usually this is the nickname of a person, or a server name.
<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00738">738</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.
<p>
References <a class="el" href="xline_8h.html#add_5Fgline_28long_20duration_2C_20const_20char_20_2Asource_2C_20const_20char_20_2Areason_2C_20const_20char_20_2Ahostmask_29">add_gline()</a>.<div class="fragment"><pre class="fragment"><a name="l00739"></a>00739 {
<a name="l00740"></a>00740         <a class="code" href="xline_8h.html#add_5Fgline_28long_20duration_2C_20const_20char_20_2Asource_2C_20const_20char_20_2Areason_2C_20const_20char_20_2Ahostmask_29">add_gline</a>(<a class="code" href="commands_8h.html#duration_28const_20char_20_2Astr_29">duration</a>, source.c_str(), reason.c_str(), hostmask.c_str());
<a name="l00741"></a>00741 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="AddKLine_28long_20duration_2C_20std_3A_3Astring_20source_2C_20std_3A_3Astring_20reason_2C_20std_3A_3Astring_20hostmask_29"></a><!-- doxytag: member="Server::AddKLine" ref="AddKLine_28long_20duration_2C_20std_3A_3Astring_20source_2C_20std_3A_3Astring_20reason_2C_20std_3A_3Astring_20hostmask_29" args="(long duration, std::string source, std::string reason, std::string hostmask)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Server::AddKLine           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">long&nbsp;</td>
          <td class="mdname" nowrap> <em>duration</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>reason</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>hostmask</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Adds a K-line The K-line is enforced as soon as it is added. 
<p>
The duration must be in seconds, however you can use the <a class="el" href="classServer.html#CalcDuration_28std_3A_3Astring_20duration_29">Server::CalcDuration</a> method to convert durations into the 1w2d3h3m6s format used by /GLINE etc. The source is an arbitary string used to indicate who or what sent the data, usually this is the nickname of a person, or a server name.
<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00753">753</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.
<p>
References <a class="el" href="xline_8h.html#add_5Fkline_28long_20duration_2C_20const_20char_20_2Asource_2C_20const_20char_20_2Areason_2C_20const_20char_20_2Ahostmask_29">add_kline()</a>.<div class="fragment"><pre class="fragment"><a name="l00754"></a>00754 {
<a name="l00755"></a>00755         <a class="code" href="xline_8h.html#add_5Fkline_28long_20duration_2C_20const_20char_20_2Asource_2C_20const_20char_20_2Areason_2C_20const_20char_20_2Ahostmask_29">add_kline</a>(<a class="code" href="commands_8h.html#duration_28const_20char_20_2Astr_29">duration</a>, source.c_str(), reason.c_str(), hostmask.c_str());
<a name="l00756"></a>00756 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="AddQLine_28long_20duration_2C_20std_3A_3Astring_20source_2C_20std_3A_3Astring_20reason_2C_20std_3A_3Astring_20nickname_29"></a><!-- doxytag: member="Server::AddQLine" ref="AddQLine_28long_20duration_2C_20std_3A_3Astring_20source_2C_20std_3A_3Astring_20reason_2C_20std_3A_3Astring_20nickname_29" args="(long duration, std::string source, std::string reason, std::string nickname)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Server::AddQLine           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">long&nbsp;</td>
          <td class="mdname" nowrap> <em>duration</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>reason</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>nickname</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Adds a Q-line The Q-line is propogated to all of the servers in the mesh and enforced as soon as it is added. 
<p>
The duration must be in seconds, however you can use the <a class="el" href="classServer.html#CalcDuration_28std_3A_3Astring_20duration_29">Server::CalcDuration</a> method to convert durations into the 1w2d3h3m6s format used by /GLINE etc. The source is an arbitary string used to indicate who or what sent the data, usually this is the nickname of a person, or a server name.
<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00743">743</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.
<p>
References <a class="el" href="xline_8h.html#add_5Fqline_28long_20duration_2C_20const_20char_20_2Asource_2C_20const_20char_20_2Areason_2C_20const_20char_20_2Anickname_29">add_qline()</a>.<div class="fragment"><pre class="fragment"><a name="l00744"></a>00744 {
<a name="l00745"></a>00745         <a class="code" href="xline_8h.html#add_5Fqline_28long_20duration_2C_20const_20char_20_2Asource_2C_20const_20char_20_2Areason_2C_20const_20char_20_2Anickname_29">add_qline</a>(<a class="code" href="commands_8h.html#duration_28const_20char_20_2Astr_29">duration</a>, source.c_str(), reason.c_str(), nickname.c_str());
<a name="l00746"></a>00746 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="AddSocket_28InspSocket_20_2Asock_29"></a><!-- doxytag: member="Server::AddSocket" ref="AddSocket_28InspSocket_20_2Asock_29" args="(InspSocket *sock)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Server::AddSocket           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classInspSocket.html">InspSocket</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>sock</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Adds a class derived from <a class="el" href="classInspSocket.html">InspSocket</a> to the server's socket engine. 
<p>

<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00402">402</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.
<p>
References <a class="el" href="modules_8cpp.html#module_5Fsockets">module_sockets</a>.<div class="fragment"><pre class="fragment"><a name="l00403"></a>00403 {
<a name="l00404"></a>00404         <a class="code" href="modules_8cpp.html#module_5Fsockets">module_sockets</a>.push_back(sock);
<a name="l00405"></a>00405 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="AddZLine_28long_20duration_2C_20std_3A_3Astring_20source_2C_20std_3A_3Astring_20reason_2C_20std_3A_3Astring_20ipaddr_29"></a><!-- doxytag: member="Server::AddZLine" ref="AddZLine_28long_20duration_2C_20std_3A_3Astring_20source_2C_20std_3A_3Astring_20reason_2C_20std_3A_3Astring_20ipaddr_29" args="(long duration, std::string source, std::string reason, std::string ipaddr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Server::AddZLine           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">long&nbsp;</td>
          <td class="mdname" nowrap> <em>duration</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>reason</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>ipaddr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Adds a Z-line The Z-line is propogated to all of the servers in the mesh and enforced as soon as it is added. 
<p>
The duration must be in seconds, however you can use the <a class="el" href="classServer.html#CalcDuration_28std_3A_3Astring_20duration_29">Server::CalcDuration</a> method to convert durations into the 1w2d3h3m6s format used by /GLINE etc. The source is an arbitary string used to indicate who or what sent the data, usually this is the nickname of a person, or a server name.
<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00748">748</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.
<p>
References <a class="el" href="xline_8h.html#add_5Fzline_28long_20duration_2C_20const_20char_20_2Asource_2C_20const_20char_20_2Areason_2C_20const_20char_20_2Aipaddr_29">add_zline()</a>.<div class="fragment"><pre class="fragment"><a name="l00749"></a>00749 {
<a name="l00750"></a>00750         <a class="code" href="xline_8h.html#add_5Fzline_28long_20duration_2C_20const_20char_20_2Asource_2C_20const_20char_20_2Areason_2C_20const_20char_20_2Aipaddr_29">add_zline</a>(<a class="code" href="commands_8h.html#duration_28const_20char_20_2Astr_29">duration</a>, source.c_str(), reason.c_str(), ipaddr.c_str());
<a name="l00751"></a>00751 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="CalcDuration_28std_3A_3Astring_20duration_29"></a><!-- doxytag: member="Server::CalcDuration" ref="CalcDuration_28std_3A_3Astring_20duration_29" args="(std::string duration)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">long Server::CalcDuration           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>duration</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculates a duration This method will take a string containing a formatted duration (e.g. 
<p>
"1w2d") and return its value as a total number of seconds. This is the same function used internally by /GLINE etc to set the ban times.
<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00788">788</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.
<p>
References <a class="el" href="commands_8h.html#duration_28const_20char_20_2Astr_29">duration()</a>.<div class="fragment"><pre class="fragment"><a name="l00789"></a>00789 {
<a name="l00790"></a>00790         <span class="keywordflow">return</span> <a class="code" href="commands_8h.html#duration_28const_20char_20_2Astr_29">duration</a>(delta.c_str());
<a name="l00791"></a>00791 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="CallCommandHandler_28std_3A_3Astring_20commandname_2C_20char_20_2A_2Aparameters_2C_20int_20pcnt_2C_20userrec_20_2Auser_29"></a><!-- doxytag: member="Server::CallCommandHandler" ref="CallCommandHandler_28std_3A_3Astring_20commandname_2C_20char_20_2A_2Aparameters_2C_20int_20pcnt_2C_20userrec_20_2Auser_29" args="(std::string commandname, char **parameters, int pcnt, userrec *user)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Server::CallCommandHandler           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>commandname</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>char **&nbsp;</td>
          <td class="mdname" nowrap> <em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>pcnt</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classuserrec.html">userrec</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>user</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calls the handler for a command, either implemented by the core or by another module. 
<p>
You can use this function to trigger other commands in the ircd, such as PRIVMSG, JOIN, KICK etc, or even as a method of callback. By defining command names that are untypeable for users on irc (e.g. those which contain a  or <br>
) you may use them as callback identifiers. The first parameter to this method is the name of the command handler you wish to call, e.g. PRIVMSG. This will be a command handler previously registered by the core or wih <a class="el" href="classServer.html#AddCommand_28char_20_2Acmd_2C_20handlerfunc_20f_2C_20char_20flags_2C_20int_20minparams_2C_20char_20_2Asource_29">AddCommand()</a>. The second parameter is an array of parameters, and the third parameter is a count of parameters in the array. If you do not pass enough parameters to meet the minimum needed by the handler, the functiom will silently ignore it. The final parameter is the user executing the command handler, used for privilage checks, etc.
<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00480">480</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.<div class="fragment"><pre class="fragment"><a name="l00481"></a>00481 {
<a name="l00482"></a>00482         call_handler(commandname.c_str(),parameters,pcnt,user);
<a name="l00483"></a>00483 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="ChangeGECOS_28userrec_20_2Auser_2C_20std_3A_3Astring_20gecos_29"></a><!-- doxytag: member="Server::ChangeGECOS" ref="ChangeGECOS_28userrec_20_2Auser_2C_20std_3A_3Astring_20gecos_29" args="(userrec *user, std::string gecos)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Server::ChangeGECOS           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classuserrec.html">userrec</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>user</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>gecos</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Change GECOS (fullname) of a user. 
<p>
You should always call this method to change a user's GECOS rather than writing directly to the fullname member of userrec, as any change applied via this method will be propogated to any linked servers.
<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00578">578</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.
<p>
References <a class="el" href="message_8h.html#ChangeName_28userrec_20_2Auser_2C_20const_20char_20_2Agecos_29">ChangeName()</a>.<div class="fragment"><pre class="fragment"><a name="l00579"></a>00579 {
<a name="l00580"></a>00580         <a class="code" href="message_8h.html#ChangeName_28userrec_20_2Auser_2C_20const_20char_20_2Agecos_29">ChangeName</a>(user,gecos.c_str());
<a name="l00581"></a>00581 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="ChangeHost_28userrec_20_2Auser_2C_20std_3A_3Astring_20host_29"></a><!-- doxytag: member="Server::ChangeHost" ref="ChangeHost_28userrec_20_2Auser_2C_20std_3A_3Astring_20host_29" args="(userrec *user, std::string host)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Server::ChangeHost           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classuserrec.html">userrec</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>user</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>host</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Change displayed hostname of a user. 
<p>
You should always call this method to change a user's host rather than writing directly to the dhost member of userrec, as any change applied via this method will be propogated to any linked servers.
<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00573">573</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.
<p>
References <a class="el" href="message_8h.html#ChangeDisplayedHost_28userrec_20_2Auser_2C_20const_20char_20_2Ahost_29">ChangeDisplayedHost()</a>.<div class="fragment"><pre class="fragment"><a name="l00574"></a>00574 {
<a name="l00575"></a>00575         <a class="code" href="message_8h.html#ChangeDisplayedHost_28userrec_20_2Auser_2C_20const_20char_20_2Ahost_29">ChangeDisplayedHost</a>(user,host.c_str());
<a name="l00576"></a>00576 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="ChangeUserNick_28userrec_20_2Auser_2C_20std_3A_3Astring_20nickname_29"></a><!-- doxytag: member="Server::ChangeUserNick" ref="ChangeUserNick_28userrec_20_2Auser_2C_20std_3A_3Astring_20nickname_29" args="(userrec *user, std::string nickname)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Server::ChangeUserNick           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classuserrec.html">userrec</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>user</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>nickname</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Forces a user nickchange. 
<p>
This command works similarly to SVSNICK, and can be used to implement Q-lines etc. If you specify an invalid nickname, the nick change will be dropped and the target user will receive the error numeric for it.
<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00465">465</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.<div class="fragment"><pre class="fragment"><a name="l00466"></a>00466 {
<a name="l00467"></a>00467         force_nickchange(user,nickname.c_str());
<a name="l00468"></a>00468 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="ChanMode_28userrec_20_2AUser_2C_20chanrec_20_2AChan_29"></a><!-- doxytag: member="Server::ChanMode" ref="ChanMode_28userrec_20_2AUser_2C_20chanrec_20_2AChan_29" args="(userrec *User, chanrec *Chan)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="namespaceirc.html#string">std::string</a> Server::ChanMode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classuserrec.html">userrec</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>User</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classchanrec.html">chanrec</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>Chan</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Attempts to look up a user's privilages on a channel. 
<p>
This function will return a string containing either @, %, +, or an empty string, representing the user's privilages upon the channel you specify.
<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00603">603</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.
<p>
References <a class="el" href="message_8h.html#cmode_28userrec_20_2Auser_2C_20chanrec_20_2Achan_29">cmode()</a>.<div class="fragment"><pre class="fragment"><a name="l00604"></a>00604 {
<a name="l00605"></a>00605         <span class="keywordflow">return</span> <a class="code" href="message_8h.html#cmode_28userrec_20_2Auser_2C_20chanrec_20_2Achan_29">cmode</a>(User,Chan);
<a name="l00606"></a>00606 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="CommonChannels_28userrec_20_2Au_31_2C_20userrec_20_2Au_32_29"></a><!-- doxytag: member="Server::CommonChannels" ref="CommonChannels_28userrec_20_2Au_31_2C_20userrec_20_2Au_32_29" args="(userrec *u1, userrec *u2)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool Server::CommonChannels           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classuserrec.html">userrec</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>u1</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classuserrec.html">userrec</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>u2</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns true if two users share a common channel. 
<p>
This method is used internally by the NICK and QUIT commands, and the <a class="el" href="classServer.html#SendCommon_28userrec_20_2AUser_2C_20std_3A_3Astring_20text_2C_20bool_20IncludeSender_29">Server::SendCommon</a> method.
<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00551">551</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.
<p>
References <a class="el" href="message_8h.html#common_5Fchannels_28userrec_20_2Au_2C_20userrec_20_2Au_32_29">common_channels()</a>.<div class="fragment"><pre class="fragment"><a name="l00552"></a>00552 {
<a name="l00553"></a>00553         <span class="keywordflow">return</span> (<a class="code" href="message_8h.html#common_5Fchannels_28userrec_20_2Au_2C_20userrec_20_2Au_32_29">common_channels</a>(u1,u2) != 0);
<a name="l00554"></a>00554 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="CountUsers_28chanrec_20_2Ac_29"></a><!-- doxytag: member="Server::CountUsers" ref="CountUsers_28chanrec_20_2Ac_29" args="(chanrec *c)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int Server::CountUsers           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classchanrec.html">chanrec</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>c</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns a count of the number of users on a channel. 
<p>
This will NEVER be 0, as if the chanrec exists, it will have at least one user in the channel.
<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00671">671</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.<div class="fragment"><pre class="fragment"><a name="l00672"></a>00672 {
<a name="l00673"></a>00673         <span class="keywordflow">return</span> usercount(c);
<a name="l00674"></a>00674 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="DelELine_28std_3A_3Astring_20hostmask_29"></a><!-- doxytag: member="Server::DelELine" ref="DelELine_28std_3A_3Astring_20hostmask_29" args="(std::string hostmask)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool Server::DelELine           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>hostmask</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Deletes a local E-Line. 
<p>

<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00783">783</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.
<p>
References <a class="el" href="xline_8h.html#del_5Feline_28const_20char_20_2Ahostmask_29">del_eline()</a>.<div class="fragment"><pre class="fragment"><a name="l00784"></a>00784 {
<a name="l00785"></a>00785         <span class="keywordflow">return</span> <a class="code" href="xline_8h.html#del_5Feline_28const_20char_20_2Ahostmask_29">del_eline</a>(hostmask.c_str());
<a name="l00786"></a>00786 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="DelGLine_28std_3A_3Astring_20hostmask_29"></a><!-- doxytag: member="Server::DelGLine" ref="DelGLine_28std_3A_3Astring_20hostmask_29" args="(std::string hostmask)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool Server::DelGLine           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>hostmask</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Deletes a G-Line from all servers on the mesh. 
<p>

<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00763">763</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.
<p>
References <a class="el" href="xline_8h.html#del_5Fgline_28const_20char_20_2Ahostmask_29">del_gline()</a>.<div class="fragment"><pre class="fragment"><a name="l00764"></a>00764 {
<a name="l00765"></a>00765         <span class="keywordflow">return</span> <a class="code" href="xline_8h.html#del_5Fgline_28const_20char_20_2Ahostmask_29">del_gline</a>(hostmask.c_str());
<a name="l00766"></a>00766 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="DelKLine_28std_3A_3Astring_20hostmask_29"></a><!-- doxytag: member="Server::DelKLine" ref="DelKLine_28std_3A_3Astring_20hostmask_29" args="(std::string hostmask)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool Server::DelKLine           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>hostmask</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Deletes a local K-Line. 
<p>

<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00778">778</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.
<p>
References <a class="el" href="xline_8h.html#del_5Fkline_28const_20char_20_2Ahostmask_29">del_kline()</a>.<div class="fragment"><pre class="fragment"><a name="l00779"></a>00779 {
<a name="l00780"></a>00780         <span class="keywordflow">return</span> <a class="code" href="xline_8h.html#del_5Fkline_28const_20char_20_2Ahostmask_29">del_kline</a>(hostmask.c_str());
<a name="l00781"></a>00781 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="DelQLine_28std_3A_3Astring_20nickname_29"></a><!-- doxytag: member="Server::DelQLine" ref="DelQLine_28std_3A_3Astring_20nickname_29" args="(std::string nickname)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool Server::DelQLine           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>nickname</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Deletes a Q-Line from all servers on the mesh. 
<p>

<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00768">768</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.
<p>
References <a class="el" href="xline_8h.html#del_5Fqline_28const_20char_20_2Anickname_29">del_qline()</a>.<div class="fragment"><pre class="fragment"><a name="l00769"></a>00769 {
<a name="l00770"></a>00770         <span class="keywordflow">return</span> <a class="code" href="xline_8h.html#del_5Fqline_28const_20char_20_2Anickname_29">del_qline</a>(nickname.c_str());
<a name="l00771"></a>00771 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="DelSocket_28InspSocket_20_2Asock_29"></a><!-- doxytag: member="Server::DelSocket" ref="DelSocket_28InspSocket_20_2Asock_29" args="(InspSocket *sock)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Server::DelSocket           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classInspSocket.html">InspSocket</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>sock</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Deletes a class derived from <a class="el" href="classInspSocket.html">InspSocket</a> from the server's socket engine. 
<p>

<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00413">413</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.
<p>
References <a class="el" href="modules_8cpp.html#module_5Fsockets">module_sockets</a>.<div class="fragment"><pre class="fragment"><a name="l00414"></a>00414 {
<a name="l00415"></a>00415         <span class="keywordflow">for</span> (std::vector&lt;InspSocket*&gt;::iterator a = <a class="code" href="modules_8cpp.html#module_5Fsockets">module_sockets</a>.begin(); a &lt; <a class="code" href="modules_8cpp.html#module_5Fsockets">module_sockets</a>.end(); a++)
<a name="l00416"></a>00416         {
<a name="l00417"></a>00417                 <span class="keywordflow">if</span> (*a == sock)
<a name="l00418"></a>00418                 {
<a name="l00419"></a>00419                         <a class="code" href="modules_8cpp.html#module_5Fsockets">module_sockets</a>.erase(a);
<a name="l00420"></a>00420                         <span class="keywordflow">return</span>;
<a name="l00421"></a>00421                 }
<a name="l00422"></a>00422         }
<a name="l00423"></a>00423 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="DelZLine_28std_3A_3Astring_20ipaddr_29"></a><!-- doxytag: member="Server::DelZLine" ref="DelZLine_28std_3A_3Astring_20ipaddr_29" args="(std::string ipaddr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool Server::DelZLine           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>ipaddr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Deletes a Z-Line from all servers on the mesh. 
<p>

<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00773">773</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.
<p>
References <a class="el" href="xline_8h.html#del_5Fzline_28const_20char_20_2Aipaddr_29">del_zline()</a>.<div class="fragment"><pre class="fragment"><a name="l00774"></a>00774 {
<a name="l00775"></a>00775         <span class="keywordflow">return</span> <a class="code" href="xline_8h.html#del_5Fzline_28const_20char_20_2Aipaddr_29">del_zline</a>(ipaddr.c_str());
<a name="l00776"></a>00776 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="FindChannel_28std_3A_3Astring_20channel_29"></a><!-- doxytag: member="Server::FindChannel" ref="FindChannel_28std_3A_3Astring_20channel_29" args="(std::string channel)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classchanrec.html">chanrec</a> * Server::FindChannel           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>channel</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Attempts to look up a channel and return a pointer to it. 
<p>
This function will return NULL if the channel does not exist.
<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00598">598</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.<div class="fragment"><pre class="fragment"><a name="l00599"></a>00599 {
<a name="l00600"></a>00600         <span class="keywordflow">return</span> FindChan(channel.c_str());
<a name="l00601"></a>00601 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="FindDescriptor_28int_20socket_29"></a><!-- doxytag: member="Server::FindDescriptor" ref="FindDescriptor_28int_20socket_29" args="(int socket)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classuserrec.html">userrec</a> * Server::FindDescriptor           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>socket</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Attempts to look up a nick using the file descriptor associated with that nick. 
<p>
This function will return NULL if the file descriptor is not associated with a valid user.
<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00593">593</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.<div class="fragment"><pre class="fragment"><a name="l00594"></a>00594 {
<a name="l00595"></a>00595         <span class="keywordflow">return</span> (socket &lt; 65536 ? fd_ref_table[socket] : NULL);
<a name="l00596"></a>00596 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="FindModule_28std_3A_3Astring_20name_29"></a><!-- doxytag: member="Server::FindModule" ref="FindModule_28std_3A_3Astring_20name_29" args="(std::string name)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classModule.html">Module</a> * Server::FindModule           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>name</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function finds a module by name. 
<p>
You must provide the filename of the module. If the module cannot be found (is not loaded) the function will return NULL.
<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00822">822</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.
<p>
References <a class="el" href="modules_8cpp-source.html#l01032">MODCOUNT</a>, <a class="el" href="channels_8cpp.html#module_5Fnames">module_names</a>, and <a class="el" href="channels_8cpp.html#modules">modules</a>.<div class="fragment"><pre class="fragment"><a name="l00823"></a>00823 {
<a name="l00824"></a>00824         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt;= <a class="code" href="channels_8cpp.html#MODCOUNT">MODCOUNT</a>; i++)
<a name="l00825"></a>00825         {
<a name="l00826"></a>00826                 <span class="keywordflow">if</span> (module_names[i] == name)
<a name="l00827"></a>00827                 {
<a name="l00828"></a>00828                         <span class="keywordflow">return</span> <a class="code" href="channels_8cpp.html#modules">modules</a>[i];
<a name="l00829"></a>00829                 }
<a name="l00830"></a>00830         }
<a name="l00831"></a>00831         <span class="keywordflow">return</span> NULL;
<a name="l00832"></a>00832 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="FindNick_28std_3A_3Astring_20nick_29"></a><!-- doxytag: member="Server::FindNick" ref="FindNick_28std_3A_3Astring_20nick_29" args="(std::string nick)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classuserrec.html">userrec</a> * Server::FindNick           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>nick</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Attempts to look up a nick and return a pointer to it. 
<p>
This function will return NULL if the nick does not exist.
<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00588">588</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.<div class="fragment"><pre class="fragment"><a name="l00589"></a>00589 {
<a name="l00590"></a>00590         <span class="keywordflow">return</span> Find(nick);
<a name="l00591"></a>00591 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="GetAdmin_28_29"></a><!-- doxytag: member="Server::GetAdmin" ref="GetAdmin_28_29" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classAdmin.html">Admin</a> Server::GetAdmin           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the information of the server as returned by the /ADMIN command. 
<p>
See the <a class="el" href="classAdmin.html">Admin</a> class for further information of the return value. The members <a class="el" href="classAdmin.html#Nick">Admin::Nick</a>, <a class="el" href="classAdmin.html#Email">Admin::Email</a> and <a class="el" href="classAdmin.html#Name">Admin::Name</a> contain the information for the server where the module is loaded.
<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00628">628</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.<div class="fragment"><pre class="fragment"><a name="l00629"></a>00629 {
<a name="l00630"></a>00630         <span class="keywordflow">return</span> <a class="code" href="classAdmin.html">Admin</a>(getadminname(),getadminemail(),getadminnick());
<a name="l00631"></a>00631 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="GetNetworkName_28_29"></a><!-- doxytag: member="Server::GetNetworkName" ref="GetNetworkName_28_29" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="namespaceirc.html#string">std::string</a> Server::GetNetworkName           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the network name, global to all linked servers. 
<p>

<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00618">618</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.<div class="fragment"><pre class="fragment"><a name="l00619"></a>00619 {
<a name="l00620"></a>00620         <span class="keywordflow">return</span> getnetworkname();
<a name="l00621"></a>00621 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="GetServerDescription_28_29"></a><!-- doxytag: member="Server::GetServerDescription" ref="GetServerDescription_28_29" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="namespaceirc.html#string">std::string</a> Server::GetServerDescription           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the server description string of the local server. 
<p>

<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00623">623</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.<div class="fragment"><pre class="fragment"><a name="l00624"></a>00624 {
<a name="l00625"></a>00625         <span class="keywordflow">return</span> getserverdesc();
<a name="l00626"></a>00626 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="GetServerName_28_29"></a><!-- doxytag: member="Server::GetServerName" ref="GetServerName_28_29" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="namespaceirc.html#string">std::string</a> Server::GetServerName           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the server name of the server where the module is loaded. 
<p>

<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00613">613</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.<div class="fragment"><pre class="fragment"><a name="l00614"></a>00614 {
<a name="l00615"></a>00615         <span class="keywordflow">return</span> getservername();
<a name="l00616"></a>00616 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="GetUsers_28chanrec_20_2Achan_29"></a><!-- doxytag: member="Server::GetUsers" ref="GetUsers_28chanrec_20_2Achan_29" args="(chanrec *chan)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="modules_8h.html#chanuserlist">chanuserlist</a> Server::GetUsers           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classchanrec.html">chanrec</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>chan</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Fetches the userlist of a channel. 
<p>
This function must be here and not a member of userrec or chanrec due to include constraints.
<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00453">453</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.
<p>
References <a class="el" href="channels_8cpp-source.html#l00215">chanrec::GetUsers()</a>, and <a class="el" href="channels_8cpp.html#list_5BMAXBUF_5D">list</a>.<div class="fragment"><pre class="fragment"><a name="l00454"></a>00454 {
<a name="l00455"></a>00455         <a class="code" href="modules_8h.html#chanuserlist">chanuserlist</a> userl;
<a name="l00456"></a>00456         userl.clear();
<a name="l00457"></a>00457         std::vector&lt;char*&gt; *<a class="code" href="channels_8cpp.html#list_5BMAXBUF_5D">list</a> = chan-&gt;<a class="code" href="classchanrec.html#GetUsers_28_29">GetUsers</a>();
<a name="l00458"></a>00458         <span class="keywordflow">for</span> (std::vector&lt;char*&gt;::iterator i = list-&gt;begin(); i != list-&gt;end(); i++)
<a name="l00459"></a>00459         {
<a name="l00460"></a>00460                 <span class="keywordtype">char</span>* o = *i;
<a name="l00461"></a>00461                 userl.push_back((<a class="code" href="classuserrec.html">userrec</a>*)o);
<a name="l00462"></a>00462         }
<a name="l00463"></a>00463         <span class="keywordflow">return</span> userl;
<a name="l00464"></a>00464 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="IsNick_28std_3A_3Astring_20nick_29"></a><!-- doxytag: member="Server::IsNick" ref="IsNick_28std_3A_3Astring_20nick_29" args="(std::string nick)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool Server::IsNick           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>nick</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns true if a nick is valid. 
<p>
Nicks for unregistered connections will return false.
<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00583">583</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.
<p>
References <a class="el" href="message_8h.html#isnick_28const_20char_20_2An_29">isnick()</a>.<div class="fragment"><pre class="fragment"><a name="l00584"></a>00584 {
<a name="l00585"></a>00585         <span class="keywordflow">return</span> (<a class="code" href="message_8h.html#isnick_28const_20char_20_2An_29">isnick</a>(nick.c_str()) != 0);
<a name="l00586"></a>00586 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="IsOnChannel_28userrec_20_2AUser_2C_20chanrec_20_2AChan_29"></a><!-- doxytag: member="Server::IsOnChannel" ref="IsOnChannel_28userrec_20_2AUser_2C_20chanrec_20_2AChan_29" args="(userrec *User, chanrec *Chan)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool Server::IsOnChannel           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classuserrec.html">userrec</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>User</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classchanrec.html">chanrec</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>Chan</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Checks if a user is on a channel. 
<p>
This function will return true or false to indicate if user 'User' is on channel 'Chan'.
<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00608">608</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.
<p>
References <a class="el" href="message_8h.html#has_5Fchannel_28userrec_20_2Au_2C_20chanrec_20_2Ac_29">has_channel()</a>.<div class="fragment"><pre class="fragment"><a name="l00609"></a>00609 {
<a name="l00610"></a>00610         <span class="keywordflow">return</span> <a class="code" href="message_8h.html#has_5Fchannel_28userrec_20_2Au_2C_20chanrec_20_2Ac_29">has_channel</a>(User,Chan);
<a name="l00611"></a>00611 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="IsUlined_28std_3A_3Astring_20server_29"></a><!-- doxytag: member="Server::IsUlined" ref="IsUlined_28std_3A_3Astring_20server_29" args="(std::string server)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool Server::IsUlined           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>server</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns true if the servername you give is ulined. 
<p>
ULined servers have extra privilages. They are allowed to change nicknames on remote servers, change modes of clients which are on remote servers and set modes of channels where there are no channel operators for that channel on the ulined server, amongst other things. Ulined server data is also broadcast across the mesh at all times as opposed to selectively messaged in the case of normal servers, as many ulined server types (such as services) do not support meshed links and must operate in this manner.
<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00475">475</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.
<p>
References <a class="el" href="commands_8h.html#is_5Fuline_28const_20char_20_2Aserver_29">is_uline()</a>.<div class="fragment"><pre class="fragment"><a name="l00476"></a>00476 {
<a name="l00477"></a>00477         <span class="keywordflow">return</span> <a class="code" href="commands_8h.html#is_5Fuline_28const_20char_20_2Aserver_29">is_uline</a>(server.c_str());
<a name="l00478"></a>00478 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="IsValidMask_28std_3A_3Astring_20mask_29"></a><!-- doxytag: member="Server::IsValidMask" ref="IsValidMask_28std_3A_3Astring_20mask_29" args="(std::string mask)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool Server::IsValidMask           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>mask</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns true if a nick!ident string is correctly formatted, false if otherwise. 
<p>

<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00793">793</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.<div class="fragment"><pre class="fragment"><a name="l00794"></a>00794 {
<a name="l00795"></a>00795         <span class="keyword">const</span> <span class="keywordtype">char</span>* dest = mask.c_str();
<a name="l00796"></a>00796         <span class="keywordflow">if</span> (strchr(dest,<span class="charliteral">'!'</span>)==0)
<a name="l00797"></a>00797                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00798"></a>00798         <span class="keywordflow">if</span> (strchr(dest,<span class="charliteral">'@'</span>)==0)
<a name="l00799"></a>00799                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00800"></a>00800         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; strlen(dest); i++)
<a name="l00801"></a>00801                 <span class="keywordflow">if</span> (dest[i] &lt; 32)
<a name="l00802"></a>00802                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00803"></a>00803         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; strlen(dest); i++)
<a name="l00804"></a>00804                 <span class="keywordflow">if</span> (dest[i] &gt; 126)
<a name="l00805"></a>00805                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00806"></a>00806         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0;
<a name="l00807"></a>00807         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; strlen(dest); i++)
<a name="l00808"></a>00808                 <span class="keywordflow">if</span> (dest[i] == <span class="charliteral">'!'</span>)
<a name="l00809"></a>00809                         c++;
<a name="l00810"></a>00810         <span class="keywordflow">if</span> (c&gt;1)
<a name="l00811"></a>00811                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00812"></a>00812         c = 0;
<a name="l00813"></a>00813         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; strlen(dest); i++)
<a name="l00814"></a>00814                 <span class="keywordflow">if</span> (dest[i] == <span class="charliteral">'@'</span>)
<a name="l00815"></a>00815                         c++;
<a name="l00816"></a>00816         <span class="keywordflow">if</span> (c&gt;1)
<a name="l00817"></a>00817                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00818"></a>00818 
<a name="l00819"></a>00819         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00820"></a>00820 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="IsValidModuleCommand_28std_3A_3Astring_20commandname_2C_20int_20pcnt_2C_20userrec_20_2Auser_29"></a><!-- doxytag: member="Server::IsValidModuleCommand" ref="IsValidModuleCommand_28std_3A_3Astring_20commandname_2C_20int_20pcnt_2C_20userrec_20_2Auser_29" args="(std::string commandname, int pcnt, userrec *user)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool Server::IsValidModuleCommand           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>commandname</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>pcnt</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classuserrec.html">userrec</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>user</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00485">485</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.<div class="fragment"><pre class="fragment"><a name="l00486"></a>00486 {
<a name="l00487"></a>00487         <span class="keywordflow">return</span> is_valid_cmd(commandname.c_str(), pcnt, user);
<a name="l00488"></a>00488 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="JoinUserToChannel_28userrec_20_2Auser_2C_20std_3A_3Astring_20cname_2C_20std_3A_3Astring_20key_29"></a><!-- doxytag: member="Server::JoinUserToChannel" ref="JoinUserToChannel_28userrec_20_2Auser_2C_20std_3A_3Astring_20cname_2C_20std_3A_3Astring_20key_29" args="(userrec *user, std::string cname, std::string key)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classchanrec.html">chanrec</a> * Server::JoinUserToChannel           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classuserrec.html">userrec</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>user</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>cname</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>key</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Forces a user to join a channel. 
<p>
This is similar to svsjoin and can be used to implement redirection, etc. On success, the return value is a valid pointer to a chanrec* of the channel the user was joined to. On failure, the result is NULL.
<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00443">443</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.<div class="fragment"><pre class="fragment"><a name="l00444"></a>00444 {
<a name="l00445"></a>00445         <span class="keywordflow">return</span> add_channel(user,cname.c_str(),key.c_str(),<span class="keyword">false</span>);
<a name="l00446"></a>00446 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="Log_28int_20level_2C_20std_3A_3Astring_20s_29"></a><!-- doxytag: member="Server::Log" ref="Log_28int_20level_2C_20std_3A_3Astring_20s_29" args="(int level, std::string s)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Server::Log           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>s</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Writes a log string. 
<p>
This method writes a line of text to the log. If the level given is lower than the level given in the configuration, this command has no effect.
<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00490">490</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.<div class="fragment"><pre class="fragment"><a name="l00491"></a>00491 {
<a name="l00492"></a>00492         log(level,<span class="stringliteral">"%s"</span>,s.c_str());
<a name="l00493"></a>00493 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="MatchText_28std_3A_3Astring_20sliteral_2C_20std_3A_3Astring_20spattern_29"></a><!-- doxytag: member="Server::MatchText" ref="MatchText_28std_3A_3Astring_20sliteral_2C_20std_3A_3Astring_20spattern_29" args="(std::string sliteral, std::string spattern)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool Server::MatchText           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>sliteral</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>spattern</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Matches text against a glob pattern. 
<p>
Uses the ircd's internal matching function to match string against a globbing pattern, e.g. *!*@*.com Returns true if the literal successfully matches the pattern, false if otherwise.
<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00430">430</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.<div class="fragment"><pre class="fragment"><a name="l00431"></a>00431 {
<a name="l00432"></a>00432         <span class="keywordtype">char</span> literal[MAXBUF],pattern[MAXBUF];
<a name="l00433"></a>00433         strlcpy(literal,sliteral.c_str(),MAXBUF);
<a name="l00434"></a>00434         strlcpy(pattern,spattern.c_str(),MAXBUF);
<a name="l00435"></a>00435         <span class="keywordflow">return</span> match(literal,pattern);
<a name="l00436"></a>00436 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="PartUserFromChannel_28userrec_20_2Auser_2C_20std_3A_3Astring_20cname_2C_20std_3A_3Astring_20reason_29"></a><!-- doxytag: member="Server::PartUserFromChannel" ref="PartUserFromChannel_28userrec_20_2Auser_2C_20std_3A_3Astring_20cname_2C_20std_3A_3Astring_20reason_29" args="(userrec *user, std::string cname, std::string reason)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classchanrec.html">chanrec</a> * Server::PartUserFromChannel           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classuserrec.html">userrec</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>user</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>cname</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>reason</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Forces a user to part a channel. 
<p>
This is similar to svspart and can be used to implement redirection, etc. Although the return value of this function is a pointer to a channel record, the returned data is undefined and should not be read or written to. This behaviour may be changed in a future version.
<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00448">448</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.<div class="fragment"><pre class="fragment"><a name="l00449"></a>00449 {
<a name="l00450"></a>00450         <span class="keywordflow">return</span> del_channel(user,cname.c_str(),reason.c_str(),<span class="keyword">false</span>);
<a name="l00451"></a>00451 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="PseudoToUser_28userrec_20_2Aalive_2C_20userrec_20_2Azombie_2C_20std_3A_3Astring_20message_29"></a><!-- doxytag: member="Server::PseudoToUser" ref="PseudoToUser_28userrec_20_2Aalive_2C_20userrec_20_2Azombie_2C_20std_3A_3Astring_20message_29" args="(userrec *alive, userrec *zombie, std::string message)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool Server::PseudoToUser           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classuserrec.html">userrec</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>alive</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classuserrec.html">userrec</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>zombie</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>message</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This user takes one user, and switches their file descriptor with another user, so that one user "becomes" the other. 
<p>
The user in 'alive' is booted off the server with the given message. The user referred to by 'zombie' should have previously been locked with Server::ZombifyUser, otherwise stale sockets and file descriptor leaks can occur. After this call, the pointer to alive will be invalid, and the pointer to zombie will be equivalent in effect to the old pointer to alive.
<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00708">708</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.
<p>
References <a class="el" href="channels_8h-source.html#l00252">ucrec::channel</a>, <a class="el" href="users_8h-source.html#l00149">userrec::chans</a>, <a class="el" href="users_8cpp-source.html#l00239">userrec::ClearBuffer()</a>, <a class="el" href="connection_8h-source.html#l00042">connection::fd</a>, <a class="el" href="modules_8h-source.html#l00101">FD_MAGIC_NUMBER</a>, <a class="el" href="connection_8h-source.html#l00046">connection::host</a>, <a class="el" href="users_8h-source.html#l00129">userrec::ident</a>, <a class="el" href="channels_8h-source.html#l00106">chanrec::name</a>, <a class="el" href="users_8h-source.html#l00124">userrec::nick</a>, <a class="el" href="channels_8h-source.html#l00131">chanrec::setby</a>, <a class="el" href="channels_8h-source.html#l00120">chanrec::topic</a>, and <a class="el" href="channels_8h-source.html#l00127">chanrec::topicset</a>.<div class="fragment"><pre class="fragment"><a name="l00709"></a>00709 {
<a name="l00710"></a>00710         zombie-&gt;<a class="code" href="classconnection.html#fd">fd</a> = alive-&gt;<a class="code" href="classconnection.html#fd">fd</a>;
<a name="l00711"></a>00711         alive-&gt;<a class="code" href="classconnection.html#fd">fd</a> = <a class="code" href="modules_8h.html#FD_5FMAGIC_5FNUMBER">FD_MAGIC_NUMBER</a>;
<a name="l00712"></a>00712         alive-&gt;<a class="code" href="classuserrec.html#ClearBuffer_28_29">ClearBuffer</a>();
<a name="l00713"></a>00713         Write(zombie-&gt;<a class="code" href="classconnection.html#fd">fd</a>,<span class="stringliteral">":%s!%s@%s NICK %s"</span>,alive-&gt;<a class="code" href="classuserrec.html#nick_5BNICKMAX_5D">nick</a>,alive-&gt;<a class="code" href="classuserrec.html#ident_5BIDENTMAX_2B_32_5D">ident</a>,alive-&gt;<a class="code" href="classconnection.html#host_5B_31_36_30_5D">host</a>,zombie-&gt;<a class="code" href="classuserrec.html#nick_5BNICKMAX_5D">nick</a>);
<a name="l00714"></a>00714         kill_link(alive,message.c_str());
<a name="l00715"></a>00715         <a class="code" href="modules_8cpp.html#fd_5Fref_5Ftable_5B_36_35_35_33_36_5D">fd_ref_table</a>[zombie-&gt;<a class="code" href="classconnection.html#fd">fd</a>] = zombie;
<a name="l00716"></a>00716         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i != MAXCHANS; i++)
<a name="l00717"></a>00717         {
<a name="l00718"></a>00718                 <span class="keywordflow">if</span> (zombie-&gt;<a class="code" href="classuserrec.html#chans_5BMAXCHANS_5D">chans</a>[i].<a class="code" href="classucrec.html#channel">channel</a> != NULL)
<a name="l00719"></a>00719                 {
<a name="l00720"></a>00720                         <span class="keywordflow">if</span> (zombie-&gt;<a class="code" href="classuserrec.html#chans_5BMAXCHANS_5D">chans</a>[i].<a class="code" href="classucrec.html#channel">channel</a>-&gt;<a class="code" href="classchanrec.html#name_5BCHANMAX_5D">name</a>)
<a name="l00721"></a>00721                         {
<a name="l00722"></a>00722                                 <a class="code" href="classchanrec.html">chanrec</a>* Ptr = zombie-&gt;<a class="code" href="classuserrec.html#chans_5BMAXCHANS_5D">chans</a>[i].<a class="code" href="classucrec.html#channel">channel</a>;
<a name="l00723"></a>00723                                 WriteFrom(zombie-&gt;<a class="code" href="classconnection.html#fd">fd</a>,zombie,<span class="stringliteral">"JOIN %s"</span>,Ptr-&gt;<a class="code" href="classchanrec.html#name_5BCHANMAX_5D">name</a>);
<a name="l00724"></a>00724                                 <span class="keywordflow">if</span> (Ptr-&gt;<a class="code" href="classchanrec.html#topicset">topicset</a>)
<a name="l00725"></a>00725                                 {
<a name="l00726"></a>00726                                         WriteServ(zombie-&gt;<a class="code" href="classconnection.html#fd">fd</a>,<span class="stringliteral">"332 %s %s :%s"</span>, zombie-&gt;<a class="code" href="classuserrec.html#nick_5BNICKMAX_5D">nick</a>, Ptr-&gt;<a class="code" href="classchanrec.html#name_5BCHANMAX_5D">name</a>, Ptr-&gt;<a class="code" href="classchanrec.html#topic_5BMAXBUF_5D">topic</a>);
<a name="l00727"></a>00727                                         WriteServ(zombie-&gt;<a class="code" href="classconnection.html#fd">fd</a>,<span class="stringliteral">"333 %s %s %s %d"</span>, zombie-&gt;<a class="code" href="classuserrec.html#nick_5BNICKMAX_5D">nick</a>, Ptr-&gt;<a class="code" href="classchanrec.html#name_5BCHANMAX_5D">name</a>, Ptr-&gt;<a class="code" href="classchanrec.html#setby_5BNICKMAX_5D">setby</a>, Ptr-&gt;<a class="code" href="classchanrec.html#topicset">topicset</a>);
<a name="l00728"></a>00728                                 }
<a name="l00729"></a>00729                                 userlist(zombie,Ptr);
<a name="l00730"></a>00730                                 WriteServ(zombie-&gt;<a class="code" href="classconnection.html#fd">fd</a>,<span class="stringliteral">"366 %s %s :End of /NAMES list."</span>, zombie-&gt;<a class="code" href="classuserrec.html#nick_5BNICKMAX_5D">nick</a>, Ptr-&gt;<a class="code" href="classchanrec.html#name_5BCHANMAX_5D">name</a>);
<a name="l00731"></a>00731 
<a name="l00732"></a>00732                         }
<a name="l00733"></a>00733                 }
<a name="l00734"></a>00734         }
<a name="l00735"></a>00735         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00736"></a>00736 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="QuitUser_28userrec_20_2Auser_2C_20std_3A_3Astring_20reason_29"></a><!-- doxytag: member="Server::QuitUser" ref="QuitUser_28userrec_20_2Auser_2C_20std_3A_3Astring_20reason_29" args="(userrec *user, std::string reason)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Server::QuitUser           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classuserrec.html">userrec</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>user</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>reason</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Forces a user to quit with the specified reason. 
<p>
To the user, it will appear as if they typed /QUIT themselves, except for the fact that this function may bypass the quit prefix specified in the config file.<p>
WARNING!<p>
Once you call this function, userrec* user will immediately become INVALID. You MUST NOT write to, or read from this pointer after calling the QuitUser method UNDER ANY CIRCUMSTANCES! The best course of action after calling this method is to immediately bail from your handler.
<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00470">470</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.<div class="fragment"><pre class="fragment"><a name="l00471"></a>00471 {
<a name="l00472"></a>00472         kill_link(user,reason.c_str());
<a name="l00473"></a>00473 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="RehashServer_28_29"></a><!-- doxytag: member="Server::RehashServer" ref="RehashServer_28_29" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Server::RehashServer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00407">407</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.<div class="fragment"><pre class="fragment"><a name="l00408"></a>00408 {
<a name="l00409"></a>00409         WriteOpers(<span class="stringliteral">"*** Rehashing config file"</span>);
<a name="l00410"></a>00410         ReadConfig(<span class="keyword">false</span>,NULL);
<a name="l00411"></a>00411 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="Send_28int_20Socket_2C_20std_3A_3Astring_20s_29"></a><!-- doxytag: member="Server::Send" ref="Send_28int_20Socket_2C_20std_3A_3Astring_20s_29" args="(int Socket, std::string s)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Server::Send           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>Socket</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>s</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sends a line of text down a TCP/IP socket. 
<p>
This method writes a line of text to an established socket, cutting it to 510 characters plus a carriage return and linefeed if required.
<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00505">505</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.<div class="fragment"><pre class="fragment"><a name="l00506"></a>00506 {
<a name="l00507"></a>00507         Write(Socket,<span class="stringliteral">"%s"</span>,s.c_str());
<a name="l00508"></a>00508 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="SendChannel_28userrec_20_2AUser_2C_20chanrec_20_2AChannel_2C_20std_3A_3Astring_20s_2C_20bool_20IncludeSender_29"></a><!-- doxytag: member="Server::SendChannel" ref="SendChannel_28userrec_20_2AUser_2C_20chanrec_20_2AChannel_2C_20std_3A_3Astring_20s_2C_20bool_20IncludeSender_29" args="(userrec *User, chanrec *Channel, std::string s, bool IncludeSender)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Server::SendChannel           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classuserrec.html">userrec</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>User</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classchanrec.html">chanrec</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>Channel</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>IncludeSender</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sends text from a user to a channel (mulicast). 
<p>
This method writes a line of text to a channel, with the given user's nick/ident /host combination prepended, as used in PRIVMSG etc commands (see RFC 1459). If the IncludeSender flag is set, then the text is also sent back to the user from which it originated, as seen in MODE (see RFC 1459).
<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00539">539</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.<div class="fragment"><pre class="fragment"><a name="l00540"></a>00540 {
<a name="l00541"></a>00541         <span class="keywordflow">if</span> (IncludeSender)
<a name="l00542"></a>00542         {
<a name="l00543"></a>00543                 WriteChannel(Channel,User,<span class="stringliteral">"%s"</span>,s.c_str());
<a name="l00544"></a>00544         }
<a name="l00545"></a>00545         <span class="keywordflow">else</span>
<a name="l00546"></a>00546         {
<a name="l00547"></a>00547                 ChanExceptSender(Channel,User,<span class="stringliteral">"%s"</span>,s.c_str());
<a name="l00548"></a>00548         }
<a name="l00549"></a>00549 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="SendChannelServerNotice_28std_3A_3Astring_20ServName_2C_20chanrec_20_2AChannel_2C_20std_3A_3Astring_20text_29"></a><!-- doxytag: member="Server::SendChannelServerNotice" ref="SendChannelServerNotice_28std_3A_3Astring_20ServName_2C_20chanrec_20_2AChannel_2C_20std_3A_3Astring_20text_29" args="(std::string ServName, chanrec *Channel, std::string text)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Server::SendChannelServerNotice           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>ServName</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classchanrec.html">chanrec</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>Channel</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>text</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Writes text to a channel, but from a server, including all. 
<p>
This can be used to send server notices to a group of users.
<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00534">534</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.<div class="fragment"><pre class="fragment"><a name="l00535"></a>00535 {
<a name="l00536"></a>00536         WriteChannelWithServ((<span class="keywordtype">char</span>*)ServName.c_str(), Channel, <span class="stringliteral">"%s"</span>, text.c_str());
<a name="l00537"></a>00537 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="SendCommon_28userrec_20_2AUser_2C_20std_3A_3Astring_20text_2C_20bool_20IncludeSender_29"></a><!-- doxytag: member="Server::SendCommon" ref="SendCommon_28userrec_20_2AUser_2C_20std_3A_3Astring_20text_2C_20bool_20IncludeSender_29" args="(userrec *User, std::string text, bool IncludeSender)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Server::SendCommon           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classuserrec.html">userrec</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>User</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>IncludeSender</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sends text from a user to one or more channels (mulicast). 
<p>
This method writes a line of text to all users which share a common channel with a given user, with the user's nick/ident/host combination prepended, as used in PRIVMSG etc commands (see RFC 1459). If the IncludeSender flag is set, then the text is also sent back to the user from which it originated, as seen in NICK (see RFC 1459). Otherwise, it is only sent to the other recipients, as seen in QUIT.
<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00556">556</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.<div class="fragment"><pre class="fragment"><a name="l00557"></a>00557 {
<a name="l00558"></a>00558         <span class="keywordflow">if</span> (IncludeSender)
<a name="l00559"></a>00559         {
<a name="l00560"></a>00560                 WriteCommon(User,<span class="stringliteral">"%s"</span>,text.c_str());
<a name="l00561"></a>00561         }
<a name="l00562"></a>00562         <span class="keywordflow">else</span>
<a name="l00563"></a>00563         {
<a name="l00564"></a>00564                 WriteCommonExcept(User,<span class="stringliteral">"%s"</span>,text.c_str());
<a name="l00565"></a>00565         }
<a name="l00566"></a>00566 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="SendFrom_28int_20Socket_2C_20userrec_20_2AUser_2C_20std_3A_3Astring_20s_29"></a><!-- doxytag: member="Server::SendFrom" ref="SendFrom_28int_20Socket_2C_20userrec_20_2AUser_2C_20std_3A_3Astring_20s_29" args="(int Socket, userrec *User, std::string s)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Server::SendFrom           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>Socket</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classuserrec.html">userrec</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>User</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>s</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sends text from a user to a socket. 
<p>
This method writes a line of text to an established socket, with the given user's nick/ident /host combination prepended, as used in PRIVSG etc commands (see RFC 1459)
<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00515">515</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.<div class="fragment"><pre class="fragment"><a name="l00516"></a>00516 {
<a name="l00517"></a>00517         WriteFrom(Socket,User,<span class="stringliteral">"%s"</span>,s.c_str());
<a name="l00518"></a>00518 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="SendMode_28char_20_2A_2Aparameters_2C_20int_20pcnt_2C_20userrec_20_2Auser_29"></a><!-- doxytag: member="Server::SendMode" ref="SendMode_28char_20_2A_2Aparameters_2C_20int_20pcnt_2C_20userrec_20_2Auser_29" args="(char **parameters, int pcnt, userrec *user)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Server::SendMode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char **&nbsp;</td>
          <td class="mdname" nowrap> <em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>pcnt</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classuserrec.html">userrec</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>user</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sends a servermode. 
<p>
you must format the parameters array with the target, modes and parameters for those modes.<p>
For example:<p>
char *modes[3];<p>
modes[0] = ChannelName;<p>
modes[1] = "+o";<p>
modes[2] = user-&gt;nick;<p>
Srv-&gt;SendMode(modes,3,user);<p>
The modes will originate from the server where the command was issued, however responses (e.g. numerics) will be sent to the user you provide as the third parameter. You must be sure to get the number of parameters correct in the pcnt parameter otherwise you could leave your server in an unstable state!
<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00500">500</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.
<p>
References <a class="el" href="mode_8h.html#server_5Fmode_28char_20_2A_2Aparameters_2C_20int_20pcnt_2C_20userrec_20_2Auser_29">server_mode()</a>.<div class="fragment"><pre class="fragment"><a name="l00501"></a>00501 {
<a name="l00502"></a>00502         <a class="code" href="mode_8h.html#server_5Fmode_28char_20_2A_2Aparameters_2C_20int_20pcnt_2C_20userrec_20_2Auser_29">server_mode</a>(parameters,pcnt,user);
<a name="l00503"></a>00503 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="SendOpers_28std_3A_3Astring_20s_29"></a><!-- doxytag: member="Server::SendOpers" ref="SendOpers_28std_3A_3Astring_20s_29" args="(std::string s)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Server::SendOpers           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>s</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sends text to all opers. 
<p>
This method sends a server notice to all opers with the usermode +s.
<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00425">425</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.<div class="fragment"><pre class="fragment"><a name="l00426"></a>00426 {
<a name="l00427"></a>00427         WriteOpers(<span class="stringliteral">"%s"</span>,s.c_str());
<a name="l00428"></a>00428 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="SendServ_28int_20Socket_2C_20std_3A_3Astring_20s_29"></a><!-- doxytag: member="Server::SendServ" ref="SendServ_28int_20Socket_2C_20std_3A_3Astring_20s_29" args="(int Socket, std::string s)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Server::SendServ           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>Socket</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>s</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sends text from the server to a socket. 
<p>
This method writes a line of text to an established socket, with the servername prepended as used by numerics (see RFC 1459)
<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00510">510</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.<div class="fragment"><pre class="fragment"><a name="l00511"></a>00511 {
<a name="l00512"></a>00512         WriteServ(Socket,<span class="stringliteral">"%s"</span>,s.c_str());
<a name="l00513"></a>00513 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="SendTo_28userrec_20_2ASource_2C_20userrec_20_2ADest_2C_20std_3A_3Astring_20s_29"></a><!-- doxytag: member="Server::SendTo" ref="SendTo_28userrec_20_2ASource_2C_20userrec_20_2ADest_2C_20std_3A_3Astring_20s_29" args="(userrec *Source, userrec *Dest, std::string s)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Server::SendTo           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classuserrec.html">userrec</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>Source</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classuserrec.html">userrec</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>s</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sends text from a user to another user. 
<p>
This method writes a line of text to a user, with a user's nick/ident /host combination prepended, as used in PRIVMSG etc commands (see RFC 1459) If you specify NULL as the source, then the data will originate from the local server, e.g. instead of:<p>
:user!ident TEXT<p>
The format will become:<p>
:localserver TEXT<p>
Which is useful for numerics and server notices to single users, etc.
<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00520">520</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.
<p>
References <a class="el" href="connection_8h-source.html#l00042">connection::fd</a>.<div class="fragment"><pre class="fragment"><a name="l00521"></a>00521 {
<a name="l00522"></a>00522         <span class="keywordflow">if</span> (!Source)
<a name="l00523"></a>00523         {
<a name="l00524"></a>00524                 <span class="comment">// if source is NULL, then the message originates from the local server</span>
<a name="l00525"></a>00525                 Write(Dest-&gt;<a class="code" href="classconnection.html#fd">fd</a>,<span class="stringliteral">":%s %s"</span>,this-&gt;GetServerName().c_str(),s.c_str());
<a name="l00526"></a>00526         }
<a name="l00527"></a>00527         <span class="keywordflow">else</span>
<a name="l00528"></a>00528         {
<a name="l00529"></a>00529                 <span class="comment">// otherwise it comes from the user specified</span>
<a name="l00530"></a>00530                 WriteTo(Source,Dest,<span class="stringliteral">"%s"</span>,s.c_str());
<a name="l00531"></a>00531         }
<a name="l00532"></a>00532 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="SendToModeMask_28std_3A_3Astring_20modes_2C_20int_20flags_2C_20std_3A_3Astring_20text_29"></a><!-- doxytag: member="Server::SendToModeMask" ref="SendToModeMask_28std_3A_3Astring_20modes_2C_20int_20flags_2C_20std_3A_3Astring_20text_29" args="(std::string modes, int flags, std::string text)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Server::SendToModeMask           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>modes</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>text</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sends to all users matching a mode mask You must specify one or more usermodes as the first parameter. 
<p>
These can be RFC specified modes such as +i, or module provided modes, including ones provided by your own module. In the second parameter you must place a flag value which indicates wether the modes you have given will be logically ANDed or OR'ed. You may use one of either WM_AND or WM_OR. for example, if you were to use:<p>
Serv-&gt;SendToModeMask("xi", WM_OR, "m00");<p>
Then the text 'm00' will be sent to all users with EITHER mode x or i. Conversely if you used WM_AND, the user must have both modes set to receive the message.
<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00438">438</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.<div class="fragment"><pre class="fragment"><a name="l00439"></a>00439 {
<a name="l00440"></a>00440         WriteMode(modes.c_str(),flags,<span class="stringliteral">"%s"</span>,text.c_str());
<a name="l00441"></a>00441 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="SendWallops_28userrec_20_2AUser_2C_20std_3A_3Astring_20text_29"></a><!-- doxytag: member="Server::SendWallops" ref="SendWallops_28userrec_20_2AUser_2C_20std_3A_3Astring_20text_29" args="(userrec *User, std::string text)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Server::SendWallops           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classuserrec.html">userrec</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>User</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>text</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sends a WALLOPS message. 
<p>
This method writes a WALLOPS message to all users with the +w flag, originating from the specified user.
<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00568">568</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.<div class="fragment"><pre class="fragment"><a name="l00569"></a>00569 {
<a name="l00570"></a>00570         WriteWallOps(User,<span class="keyword">false</span>,<span class="stringliteral">"%s"</span>,text.c_str());
<a name="l00571"></a>00571 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="UserToPseudo_28userrec_20_2Auser_2C_20std_3A_3Astring_20message_29"></a><!-- doxytag: member="Server::UserToPseudo" ref="UserToPseudo_28userrec_20_2Auser_2C_20std_3A_3Astring_20message_29" args="(userrec *user, std::string message)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool Server::UserToPseudo           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classuserrec.html">userrec</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>user</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="namespaceirc.html#string">std::string</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>message</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Remove a user's connection to the irc server, but leave their client in existence in the user hash. 
<p>
When you call this function, the user's file descriptor will be replaced with the value of FD_MAGIC_NUMBER and their old file descriptor will be closed. This idle client will remain until it is restored with a valid file descriptor, or is removed from IRC by an operator After this call, the pointer to user will be invalid.
<p>
Definition at line <a class="el" href="modules_8cpp-source.html#l00677">677</a> of file <a class="el" href="modules_8cpp-source.html">modules.cpp</a>.
<p>
References <a class="el" href="users_8cpp-source.html#l00239">userrec::ClearBuffer()</a>, <a class="el" href="modules_8h-source.html#l00023">DEBUG</a>, <a class="el" href="connection_8h-source.html#l00042">connection::fd</a>, <a class="el" href="modules_8h-source.html#l00101">FD_MAGIC_NUMBER</a>, <a class="el" href="connection_8h-source.html#l00046">connection::host</a>, and <a class="el" href="users_8h-source.html#l00129">userrec::ident</a>.<div class="fragment"><pre class="fragment"><a name="l00678"></a>00678 {
<a name="l00679"></a>00679         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> old_fd = user-&gt;<a class="code" href="classconnection.html#fd">fd</a>;
<a name="l00680"></a>00680         user-&gt;<a class="code" href="classconnection.html#fd">fd</a> = <a class="code" href="modules_8h.html#FD_5FMAGIC_5FNUMBER">FD_MAGIC_NUMBER</a>;
<a name="l00681"></a>00681         user-&gt;<a class="code" href="classuserrec.html#ClearBuffer_28_29">ClearBuffer</a>();
<a name="l00682"></a>00682         Write(old_fd,<span class="stringliteral">"ERROR :Closing link (%s@%s) [%s]"</span>,user-&gt;<a class="code" href="classuserrec.html#ident_5BIDENTMAX_2B_32_5D">ident</a>,user-&gt;<a class="code" href="classconnection.html#host_5B_31_36_30_5D">host</a>,message.c_str());
<a name="l00683"></a>00683 <span class="preprocessor">#ifdef USE_KQUEUE</span>
<a name="l00684"></a>00684 <span class="preprocessor"></span>        <span class="keyword">struct </span>kevent ke;
<a name="l00685"></a>00685         EV_SET(&amp;ke, old_fd, EVFILT_READ, EV_DELETE, 0, 0, NULL);
<a name="l00686"></a>00686         <span class="keywordtype">int</span> i = kevent(kq, &amp;ke, 1, 0, 0, NULL);
<a name="l00687"></a>00687         <span class="keywordflow">if</span> (i == -1)
<a name="l00688"></a>00688         {
<a name="l00689"></a>00689                 log(<a class="code" href="modules_8h.html#DEBUG">DEBUG</a>,<span class="stringliteral">"kqueue: Failed to remove user from queue!"</span>);
<a name="l00690"></a>00690         }
<a name="l00691"></a>00691 <span class="preprocessor">#endif</span>
<a name="l00692"></a>00692 <span class="preprocessor"></span><span class="preprocessor">#ifdef USE_EPOLL</span>
<a name="l00693"></a>00693 <span class="preprocessor"></span>        <span class="keyword">struct </span>epoll_event ev;
<a name="l00694"></a>00694         ev.events = EPOLLIN | EPOLLET;
<a name="l00695"></a>00695         ev.data.fd = old_fd;
<a name="l00696"></a>00696         <span class="keywordtype">int</span> i = epoll_ctl(ep, EPOLL_CTL_DEL, old_fd, &amp;ev);
<a name="l00697"></a>00697         <span class="keywordflow">if</span> (i &lt; 0)
<a name="l00698"></a>00698         {
<a name="l00699"></a>00699                 log(<a class="code" href="modules_8h.html#DEBUG">DEBUG</a>,<span class="stringliteral">"epoll: List deletion failure!"</span>);
<a name="l00700"></a>00700         }
<a name="l00701"></a>00701 <span class="preprocessor">#endif</span>
<a name="l00702"></a>00702 <span class="preprocessor"></span>
<a name="l00703"></a>00703         shutdown(old_fd,2);
<a name="l00704"></a>00704         close(old_fd);
<a name="l00705"></a>00705         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00706"></a>00706 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="modules_8h-source.html">modules.h</a><li><a class="el" href="modules_8cpp-source.html">modules.cpp</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Fri Dec 9 20:20:13 2005 for InspIRCd by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.4-20050815 </small></address>
</body>
</html>
