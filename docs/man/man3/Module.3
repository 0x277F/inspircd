.TH "Module" 3 "27 Nov 2005" "Version 1.0Betareleases" "InspIRCd" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Module \- Base class for all InspIRCd modules This class is the base class for InspIRCd modules.  

.PP
.SH SYNOPSIS
.br
.PP
\fC#include <modules.h>\fP
.PP
Inherits \fBclassbase\fP.
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBModule\fP ()"
.br
.RI "\fIDefault constructor creates a module class. \fP"
.ti -1c
.RI "virtual \fB~Module\fP ()"
.br
.RI "\fIDefault destructor destroys a module class. \fP"
.ti -1c
.RI "virtual \fBVersion\fP \fBGetVersion\fP ()"
.br
.RI "\fIReturns the version number of a Module. \fP"
.ti -1c
.RI "virtual void \fBOnUserConnect\fP (\fBuserrec\fP *user)"
.br
.RI "\fICalled when a user connects. \fP"
.ti -1c
.RI "virtual void \fBOnUserQuit\fP (\fBuserrec\fP *user)"
.br
.RI "\fICalled when a user quits. \fP"
.ti -1c
.RI "virtual void \fBOnUserDisconnect\fP (\fBuserrec\fP *user)"
.br
.RI "\fICalled whenever a user's socket is closed. \fP"
.ti -1c
.RI "virtual void \fBOnUserJoin\fP (\fBuserrec\fP *user, \fBchanrec\fP *channel)"
.br
.RI "\fICalled when a user joins a channel. \fP"
.ti -1c
.RI "virtual void \fBOnUserPart\fP (\fBuserrec\fP *user, \fBchanrec\fP *channel)"
.br
.RI "\fICalled when a user parts a channel. \fP"
.ti -1c
.RI "virtual void \fBOnPacketTransmit\fP (\fBstd::string\fP &data, \fBstd::string\fP serv)"
.br
.RI "\fICalled before a packet is transmitted across the irc network between two irc servers. \fP"
.ti -1c
.RI "virtual void \fBOnPacketReceive\fP (\fBstd::string\fP &data, \fBstd::string\fP serv)"
.br
.RI "\fICalled after a packet is received from another irc server. \fP"
.ti -1c
.RI "virtual void \fBOnRehash\fP ()"
.br
.RI "\fICalled on rehash. \fP"
.ti -1c
.RI "virtual void \fBOnServerRaw\fP (\fBstd::string\fP &raw, bool inbound, \fBuserrec\fP *user)"
.br
.RI "\fICalled when a raw command is transmitted or received. \fP"
.ti -1c
.RI "virtual int \fBOnExtendedMode\fP (\fBuserrec\fP *user, void *target, char modechar, int type, bool mode_on, \fBstring_list\fP &params)"
.br
.RI "\fICalled whenever an extended mode is to be processed. \fP"
.ti -1c
.RI "virtual int \fBOnUserPreJoin\fP (\fBuserrec\fP *user, \fBchanrec\fP *chan, const char *cname)"
.br
.RI "\fICalled whenever a user is about to join a channel, before any processing is done. \fP"
.ti -1c
.RI "virtual int \fBOnUserPreKick\fP (\fBuserrec\fP *source, \fBuserrec\fP *user, \fBchanrec\fP *chan, \fBstd::string\fP reason)"
.br
.RI "\fICalled whenever a user is about to be kicked. \fP"
.ti -1c
.RI "virtual void \fBOnUserKick\fP (\fBuserrec\fP *source, \fBuserrec\fP *user, \fBchanrec\fP *chan, \fBstd::string\fP reason)"
.br
.RI "\fICalled whenever a user is kicked. \fP"
.ti -1c
.RI "virtual void \fBOnOper\fP (\fBuserrec\fP *user)"
.br
.RI "\fICalled whenever a user opers locally. \fP"
.ti -1c
.RI "virtual void \fBOnInfo\fP (\fBuserrec\fP *user)"
.br
.RI "\fICalled whenever a user types /INFO. \fP"
.ti -1c
.RI "virtual void \fBOnWhois\fP (\fBuserrec\fP *source, \fBuserrec\fP *dest)"
.br
.RI "\fICalled whenever a /WHOIS is performed on a local user. \fP"
.ti -1c
.RI "virtual int \fBOnUserPreInvite\fP (\fBuserrec\fP *source, \fBuserrec\fP *dest, \fBchanrec\fP *channel)"
.br
.RI "\fICalled whenever a user is about to invite another user into a channel, before any processing is done. \fP"
.ti -1c
.RI "virtual int \fBOnUserPreMessage\fP (\fBuserrec\fP *user, void *dest, int target_type, \fBstd::string\fP &text)"
.br
.RI "\fICalled whenever a user is about to PRIVMSG A user or a channel, before any processing is done. \fP"
.ti -1c
.RI "virtual int \fBOnUserPreNotice\fP (\fBuserrec\fP *user, void *dest, int target_type, \fBstd::string\fP &text)"
.br
.RI "\fICalled whenever a user is about to NOTICE A user or a channel, before any processing is done. \fP"
.ti -1c
.RI "virtual int \fBOnUserPreNick\fP (\fBuserrec\fP *user, \fBstd::string\fP newnick)"
.br
.RI "\fICalled before any nickchange, local or remote. \fP"
.ti -1c
.RI "virtual void \fBOnUserPostNick\fP (\fBuserrec\fP *user, \fBstd::string\fP oldnick)"
.br
.RI "\fICalled after any nickchange, local or remote. \fP"
.ti -1c
.RI "virtual int \fBOnAccessCheck\fP (\fBuserrec\fP *source, \fBuserrec\fP *dest, \fBchanrec\fP *channel, int access_type)"
.br
.RI "\fICalled before an action which requires a channel privilage check. \fP"
.ti -1c
.RI "virtual \fBstring_list\fP \fBOnUserSync\fP (\fBuserrec\fP *user)"
.br
.RI "\fICalled during a netburst to sync user data. \fP"
.ti -1c
.RI "virtual \fBstring_list\fP \fBOnChannelSync\fP (\fBchanrec\fP *chan)"
.br
.RI "\fICalled during a netburst to sync channel data. \fP"
.ti -1c
.RI "virtual void \fBOn005Numeric\fP (\fBstd::string\fP &output)"
.br
.RI "\fICalled when a 005 numeric is about to be output. \fP"
.ti -1c
.RI "virtual int \fBOnKill\fP (\fBuserrec\fP *source, \fBuserrec\fP *dest, \fBstd::string\fP reason)"
.br
.RI "\fICalled when a client is disconnected by KILL. \fP"
.ti -1c
.RI "virtual void \fBOnLoadModule\fP (\fBModule\fP *mod, \fBstd::string\fP name)"
.br
.RI "\fICalled whenever a module is loaded. \fP"
.ti -1c
.RI "virtual void \fBOnUnloadModule\fP (\fBModule\fP *mod, \fBstd::string\fP name)"
.br
.RI "\fICalled whenever a module is unloaded. \fP"
.ti -1c
.RI "virtual void \fBOnBackgroundTimer\fP (time_t curtime)"
.br
.RI "\fICalled once every five seconds for background processing. \fP"
.ti -1c
.RI "virtual void \fBOnSendList\fP (\fBuserrec\fP *user, \fBchanrec\fP *channel, char mode)"
.br
.RI "\fICalled whenever a list is needed for a listmode. \fP"
.ti -1c
.RI "virtual int \fBOnPreCommand\fP (\fBstd::string\fP command, char **parameters, int pcnt, \fBuserrec\fP *user)"
.br
.RI "\fICalled whenever any command is about to be executed. \fP"
.ti -1c
.RI "virtual bool \fBOnCheckReady\fP (\fBuserrec\fP *user)"
.br
.RI "\fICalled to check if a user who is connecting can now be allowed to register If any modules return false for this function, the user is held in the waiting state until all modules return true. \fP"
.ti -1c
.RI "virtual void \fBOnUserRegister\fP (\fBuserrec\fP *user)"
.br
.RI "\fICalled whenever a user is about to register their connection (e.g. \fP"
.ti -1c
.RI "virtual int \fBOnRawMode\fP (\fBuserrec\fP *user, \fBchanrec\fP *chan, char mode, \fBstd::string\fP param, bool adding, int pcnt)"
.br
.RI "\fICalled whenever a mode character is processed. \fP"
.ti -1c
.RI "virtual int \fBOnCheckInvite\fP (\fBuserrec\fP *user, \fBchanrec\fP *chan)"
.br
.RI "\fICalled whenever a user joins a channel, to determine if invite checks should go ahead or not. \fP"
.ti -1c
.RI "virtual int \fBOnCheckKey\fP (\fBuserrec\fP *user, \fBchanrec\fP *chan, \fBstd::string\fP keygiven)"
.br
.RI "\fICalled whenever a user joins a channel, to determine if key checks should go ahead or not. \fP"
.ti -1c
.RI "virtual int \fBOnCheckLimit\fP (\fBuserrec\fP *user, \fBchanrec\fP *chan)"
.br
.RI "\fICalled whenever a user joins a channel, to determine if channel limit checks should go ahead or not. \fP"
.ti -1c
.RI "virtual int \fBOnCheckBan\fP (\fBuserrec\fP *user, \fBchanrec\fP *chan)"
.br
.RI "\fICalled whenever a user joins a channel, to determine if banlist checks should go ahead or not. \fP"
.ti -1c
.RI "virtual void \fBOnStats\fP (char symbol)"
.br
.RI "\fICalled on all /STATS commands This method is triggered for all /STATS use, including stats symbols handled by the core. \fP"
.ti -1c
.RI "virtual int \fBOnChangeLocalUserHost\fP (\fBuserrec\fP *user, \fBstd::string\fP newhost)"
.br
.RI "\fICalled whenever a change of a local users displayed host is attempted. \fP"
.ti -1c
.RI "virtual int \fBOnChangeLocalUserGECOS\fP (\fBuserrec\fP *user, \fBstd::string\fP newhost)"
.br
.RI "\fICalled whenever a change of a local users GECOS (fullname field) is attempted. \fP"
.ti -1c
.RI "virtual int \fBOnLocalTopicChange\fP (\fBuserrec\fP *user, \fBchanrec\fP *chan, \fBstd::string\fP topic)"
.br
.RI "\fICalled whenever a topic is changed by a local user. \fP"
.ti -1c
.RI "virtual void \fBOnEvent\fP (\fBEvent\fP *event)"
.br
.RI "\fICalled whenever an \fBEvent\fP class is sent to all module by another module. \fP"
.ti -1c
.RI "virtual char * \fBOnRequest\fP (\fBRequest\fP *request)"
.br
.RI "\fICalled whenever a \fBRequest\fP class is sent to your module by another module. \fP"
.ti -1c
.RI "virtual int \fBOnOperCompare\fP (\fBstd::string\fP password, \fBstd::string\fP input)"
.br
.RI "\fICalled whenever an oper password is to be compared to what a user has input. \fP"
.ti -1c
.RI "virtual void \fBOnGlobalOper\fP (\fBuserrec\fP *user)"
.br
.RI "\fICalled whenever a user is given usermode +o, anywhere on the network. \fP"
.ti -1c
.RI "virtual void \fBOnGlobalConnect\fP (\fBuserrec\fP *user)"
.br
.RI "\fICalled whenever a user connects, anywhere on the network. \fP"
.ti -1c
.RI "virtual int \fBOnAddBan\fP (\fBuserrec\fP *source, \fBchanrec\fP *channel, \fBstd::string\fP banmask)"
.br
.RI "\fICalled whenever a ban is added to a channel's list. \fP"
.ti -1c
.RI "virtual int \fBOnDelBan\fP (\fBuserrec\fP *source, \fBchanrec\fP *channel, \fBstd::string\fP banmask)"
.br
.RI "\fICalled whenever a ban is removed from a channel's list. \fP"
.ti -1c
.RI "virtual void \fBOnRawSocketAccept\fP (int fd, \fBstd::string\fP ip, int localport)"
.br
.RI "\fICalled immediately after any connection is accepted. \fP"
.ti -1c
.RI "virtual int \fBOnRawSocketWrite\fP (int fd, char *buffer, int count)"
.br
.RI "\fICalled immediately before any write() operation on a user's socket in the core. \fP"
.ti -1c
.RI "virtual void \fBOnRawSocketClose\fP (int fd)"
.br
.RI "\fICalled immediately before any socket is closed. \fP"
.ti -1c
.RI "virtual int \fBOnRawSocketRead\fP (int fd, char *buffer, unsigned int count, int &readresult)"
.br
.RI "\fICalled immediately before any read() operation on a client socket in the core. \fP"
.in -1c
.SH "Detailed Description"
.PP 
Base class for all InspIRCd modules This class is the base class for InspIRCd modules. 

All modules must inherit from this class, its methods will be called when irc server events occur. class inherited from module must be instantiated by the \fBModuleFactory\fP class (see relevent section) for the plugin to be initialised.
.PP
Definition at line 238 of file modules.h.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Module::Module ()"
.PP
Default constructor creates a module class. 
.PP
Definition at line 306 of file modules.cpp.
.PP
.nf
306 { }
.fi
.PP
.SS "Module::~Module ()\fC [virtual]\fP"
.PP
Default destructor destroys a module class. 
.PP
Definition at line 307 of file modules.cpp.
.PP
.nf
307 { }
.fi
.PP
.SH "Member Function Documentation"
.PP 
.SS "\fBVersion\fP Module::GetVersion ()\fC [virtual]\fP"
.PP
Returns the version number of a Module. 
.PP
The method should return a \fBVersion\fP object with its version information assigned via \fBVersion::Version\fP
.PP
Definition at line 319 of file modules.cpp.
.PP
References VF_VENDOR.
.PP
.nf
319 { return Version(1,0,0,0,VF_VENDOR); }
.fi
.PP
.SS "void Module::On005Numeric (\fBstd::string\fP & output)\fC [virtual]\fP"
.PP
Called when a 005 numeric is about to be output. 
.PP
The module should modify the 005 numeric if needed to indicate its features.
.PP
Definition at line 331 of file modules.cpp.
.PP
.nf
331 { };
.fi
.PP
.SS "int Module::OnAccessCheck (\fBuserrec\fP * source, \fBuserrec\fP * dest, \fBchanrec\fP * channel, int access_type)\fC [virtual]\fP"
.PP
Called before an action which requires a channel privilage check. 
.PP
This function is called before many functions which check a users status on a channel, for example before opping a user, deopping a user, kicking a user, etc. There are several values for access_type which indicate for what reason access is being checked. These are:
.br

.br
 AC_KICK (0) - A user is being kicked
.br
 AC_DEOP (1) - a user is being deopped
.br
 AC_OP (2) - a user is being opped
.br
 AC_VOICE (3) - a user is being voiced
.br
 AC_DEVOICE (4) - a user is being devoiced
.br
 AC_HALFOP (5) - a user is being halfopped
.br
 AC_DEHALFOP (6) - a user is being dehalfopped
.br
 AC_INVITE (7) - a user is being invited
.br
 AC_GENERAL_MODE (8) - a user channel mode is being changed<br>
.br
 Upon returning from your function you must return either ACR_DEFAULT, to indicate the module wishes to do nothing, or ACR_DENY where approprate to deny the action, and ACR_ALLOW where appropriate to allow the action. Please note that in the case of some access checks (such as AC_GENERAL_MODE) access may be denied 'upstream' causing other checks such as AC_DEOP to not be reached. Be very careful with use of the AC_GENERAL_MODE type, as it may inadvertently override the behaviour of other modules. When the access_type is AC_GENERAL_MODE, the destination of the mode will be NULL (as it has not yet been determined).
.PP
Definition at line 328 of file modules.cpp.
.PP
References ACR_DEFAULT.
.PP
.nf
328 { return ACR_DEFAULT; };
.fi
.PP
.SS "int Module::OnAddBan (\fBuserrec\fP * source, \fBchanrec\fP * channel, \fBstd::string\fP banmask)\fC [virtual]\fP"
.PP
Called whenever a ban is added to a channel's list. 
.PP
Return a non-zero value to 'eat' the mode change and prevent the ban from being added.
.PP
Definition at line 356 of file modules.cpp.
.PP
.nf
356 { return 0; };
.fi
.PP
.SS "void Module::OnBackgroundTimer (time_t curtime)\fC [virtual]\fP"
.PP
Called once every five seconds for background processing. 
.PP
This timer can be used to control timed features. Its period is not accurate enough to be used as a clock, but it is gauranteed to be called at least once in any five second period, directly from the main loop of the server.
.PP
Definition at line 335 of file modules.cpp.
.PP
.nf
335 { };
.fi
.PP
.SS "int Module::OnChangeLocalUserGECOS (\fBuserrec\fP * user, \fBstd::string\fP newhost)\fC [virtual]\fP"
.PP
Called whenever a change of a local users GECOS (fullname field) is attempted. 
.PP
return 1 to deny the name change, or 0 to allow it.
.PP
Definition at line 349 of file modules.cpp.
.PP
.nf
349 { return 0; };
.fi
.PP
.SS "int Module::OnChangeLocalUserHost (\fBuserrec\fP * user, \fBstd::string\fP newhost)\fC [virtual]\fP"
.PP
Called whenever a change of a local users displayed host is attempted. 
.PP
Return 1 to deny the host change, or 0 to allow it.
.PP
Definition at line 348 of file modules.cpp.
.PP
.nf
348 { return 0; };
.fi
.PP
.SS "\fBstring_list\fP Module::OnChannelSync (\fBchanrec\fP * chan)\fC [virtual]\fP"
.PP
Called during a netburst to sync channel data. 
.PP
This is called during the netburst on a per-channel basis. You should use this call to up any special channel-related things which are implemented by your module, e.g. sending listmodes. You may return multiple commands in the string_list.
.PP
Definition at line 330 of file modules.cpp.
.PP
.nf
330 { string_list empty; return empty; }
.fi
.PP
.SS "int Module::OnCheckBan (\fBuserrec\fP * user, \fBchanrec\fP * chan)\fC [virtual]\fP"
.PP
Called whenever a user joins a channel, to determine if banlist checks should go ahead or not. 
.PP
This method will always be called for each join, wether or not the user actually matches a channel ban, and determines the outcome of an if statement around the whole section of ban checking code. return 1 to explicitly allow the join to go ahead or 0 to ignore the event.
.PP
Definition at line 346 of file modules.cpp.
.PP
.nf
346 { return 0; };
.fi
.PP
.SS "int Module::OnCheckInvite (\fBuserrec\fP * user, \fBchanrec\fP * chan)\fC [virtual]\fP"
.PP
Called whenever a user joins a channel, to determine if invite checks should go ahead or not. 
.PP
This method will always be called for each join, wether or not the channel is actually +i, and determines the outcome of an if statement around the whole section of invite checking code. return 1 to explicitly allow the join to go ahead or 0 to ignore the event.
.PP
Definition at line 343 of file modules.cpp.
.PP
.nf
343 { return 0; };
.fi
.PP
.SS "int Module::OnCheckKey (\fBuserrec\fP * user, \fBchanrec\fP * chan, \fBstd::string\fP keygiven)\fC [virtual]\fP"
.PP
Called whenever a user joins a channel, to determine if key checks should go ahead or not. 
.PP
This method will always be called for each join, wether or not the channel is actually +k, and determines the outcome of an if statement around the whole section of key checking code. if the user specified no key, the keygiven string will be a valid but empty value. return 1 to explicitly allow the join to go ahead or 0 to ignore the event.
.PP
Definition at line 344 of file modules.cpp.
.PP
.nf
344 { return 0; };
.fi
.PP
.SS "int Module::OnCheckLimit (\fBuserrec\fP * user, \fBchanrec\fP * chan)\fC [virtual]\fP"
.PP
Called whenever a user joins a channel, to determine if channel limit checks should go ahead or not. 
.PP
This method will always be called for each join, wether or not the channel is actually +l, and determines the outcome of an if statement around the whole section of channel limit checking code. return 1 to explicitly allow the join to go ahead or 0 to ignore the event.
.PP
Definition at line 345 of file modules.cpp.
.PP
.nf
345 { return 0; };
.fi
.PP
.SS "bool Module::OnCheckReady (\fBuserrec\fP * user)\fC [virtual]\fP"
.PP
Called to check if a user who is connecting can now be allowed to register If any modules return false for this function, the user is held in the waiting state until all modules return true. 
.PP
For example a module which implements ident lookups will continue to return false for a user until their ident lookup is completed. Note that the registration timeout for a user overrides these checks, if the registration timeout is reached, the user is disconnected even if modules report that the user is not ready to connect.
.PP
Definition at line 338 of file modules.cpp.
.PP
.nf
338 { return true; };
.fi
.PP
.SS "int Module::OnDelBan (\fBuserrec\fP * source, \fBchanrec\fP * channel, \fBstd::string\fP banmask)\fC [virtual]\fP"
.PP
Called whenever a ban is removed from a channel's list. 
.PP
Return a non-zero value to 'eat' the mode change and prevent the ban from being removed.
.PP
Definition at line 357 of file modules.cpp.
.PP
.nf
357 { return 0; };
.fi
.PP
.SS "void Module::OnEvent (\fBEvent\fP * event)\fC [virtual]\fP"
.PP
Called whenever an \fBEvent\fP class is sent to all module by another module. 
.PP
Please see the documentation of \fBEvent::Send()\fP for further information. The \fBEvent\fP sent can always be assumed to be non-NULL, you should *always* check the value of \fBEvent::GetEventID()\fP before doing anything to the event data, and you should *not* change the event data in any way!
.PP
Definition at line 351 of file modules.cpp.
.PP
.nf
351 { return; };
.fi
.PP
.SS "int Module::OnExtendedMode (\fBuserrec\fP * user, void * target, char modechar, int type, bool mode_on, \fBstring_list\fP & params)\fC [virtual]\fP"
.PP
Called whenever an extended mode is to be processed. 
.PP
The type parameter is MT_SERVER, MT_CLIENT or MT_CHANNEL, dependent on where the mode is being changed. mode_on is set when the mode is being set, in which case params contains a list of parameters for the mode as strings. If mode_on is false, the mode is being removed, and parameters may contain the parameters for the mode, dependent on wether they were defined when a mode handler was set up with \fBServer::AddExtendedMode\fP If the mode is a channel mode, target is a chanrec*, and if it is a user mode, target is a userrec*. You must cast this value yourself to make use of it.
.PP
Definition at line 318 of file modules.cpp.
.PP
.nf
318 { return false; }
.fi
.PP
.SS "void Module::OnGlobalConnect (\fBuserrec\fP * user)\fC [virtual]\fP"
.PP
Called whenever a user connects, anywhere on the network. 
.PP
This event is informational only. You should not change any user information in this event. To do so, use the OnUserConnect method to change the state of local users.
.PP
Definition at line 355 of file modules.cpp.
.PP
.nf
355 { };
.fi
.PP
.SS "void Module::OnGlobalOper (\fBuserrec\fP * user)\fC [virtual]\fP"
.PP
Called whenever a user is given usermode +o, anywhere on the network. 
.PP
You cannot override this and prevent it from happening as it is already happened and such a task must be performed by another server. You can however bounce modes by sending servermodes out to reverse mode changes.
.PP
Definition at line 354 of file modules.cpp.
.PP
.nf
354 { };
.fi
.PP
.SS "void Module::OnInfo (\fBuserrec\fP * user)\fC [virtual]\fP"
.PP
Called whenever a user types /INFO. 
.PP
The userrec will contain the information of the user who typed the command. Modules may use this method to output their own credits in /INFO (which is the ircd's version of an about box). It is purposefully not possible to modify any info that has already been output, or halt the list. You must write a 371 numeric to the user, containing your info in the following format:
.PP
<nick> :information here
.PP
Definition at line 321 of file modules.cpp.
.PP
.nf
321 { };
.fi
.PP
.SS "int Module::OnKill (\fBuserrec\fP * source, \fBuserrec\fP * dest, \fBstd::string\fP reason)\fC [virtual]\fP"
.PP
Called when a client is disconnected by KILL. 
.PP
If a client is killed by a server, e.g. a nickname collision or protocol error, source is NULL. Return 1 from this function to prevent the kill, and 0 from this function to allow it as normal. If you prevent the kill no output will be sent to the client, it is down to your module to generate this information. NOTE: It is NOT advisable to stop kills which originate from servers. If you do so youre risking race conditions, desyncs and worse!
.PP
Definition at line 332 of file modules.cpp.
.PP
.nf
332 { return 0; };
.fi
.PP
.SS "void Module::OnLoadModule (\fBModule\fP * mod, \fBstd::string\fP name)\fC [virtual]\fP"
.PP
Called whenever a module is loaded. 
.PP
mod will contain a pointer to the module, and string will contain its name, for example m_widgets.so. This function is primary for dependency checking, your module may decide to enable some extra features if it sees that you have for example loaded 'm_killwidgets.so' with 'm_makewidgets.so'. It is highly recommended that modules do *NOT* bail if they cannot satisfy dependencies, but instead operate under reduced functionality, unless the dependency is absolutely neccessary (e.g. a module that extends the features of another module).
.PP
Definition at line 333 of file modules.cpp.
.PP
.nf
333 { };
.fi
.PP
.SS "int Module::OnLocalTopicChange (\fBuserrec\fP * user, \fBchanrec\fP * chan, \fBstd::string\fP topic)\fC [virtual]\fP"
.PP
Called whenever a topic is changed by a local user. 
.PP
Return 1 to deny the topic change, or 0 to allow it.
.PP
Definition at line 350 of file modules.cpp.
.PP
.nf
350 { return 0; };
.fi
.PP
.SS "void Module::OnOper (\fBuserrec\fP * user)\fC [virtual]\fP"
.PP
Called whenever a user opers locally. 
.PP
The userrec will contain the oper mode 'o' as this function is called after any modifications are made to the user's structure by the core.
.PP
Definition at line 320 of file modules.cpp.
.PP
.nf
320 { };
.fi
.PP
.SS "int Module::OnOperCompare (\fBstd::string\fP password, \fBstd::string\fP input)\fC [virtual]\fP"
.PP
Called whenever an oper password is to be compared to what a user has input. 
.PP
The password field (from the config file) is in 'password' and is to be compared against 'input'. This method allows for encryption of oper passwords and much more besides. You should return a nonzero value if you want to allow the comparison or zero if you wish to do nothing.
.PP
Definition at line 353 of file modules.cpp.
.PP
.nf
353 { return 0; };
.fi
.PP
.SS "void Module::OnPacketReceive (\fBstd::string\fP & data, \fBstd::string\fP serv)\fC [virtual]\fP"
.PP
Called after a packet is received from another irc server. 
.PP
This allows you to easily represent it in the correct ways to implement encryption, compression, digital signatures and anything else you may want to add. This should be regarded as a pre-processor and will be called immediately after the packet is received but before any other operations with the core of the ircd.
.PP
Definition at line 314 of file modules.cpp.
.PP
.nf
314 { }
.fi
.PP
.SS "void Module::OnPacketTransmit (\fBstd::string\fP & data, \fBstd::string\fP serv)\fC [virtual]\fP"
.PP
Called before a packet is transmitted across the irc network between two irc servers. 
.PP
This allows you to easily represent it in the correct ways to implement encryption, compression, digital signatures and anything else you may want to add. This should be regarded as a pre-processor and will be called before ANY other operations within the ircd core program.
.PP
Definition at line 313 of file modules.cpp.
.PP
.nf
313 { }
.fi
.PP
.SS "int Module::OnPreCommand (\fBstd::string\fP command, char ** parameters, int pcnt, \fBuserrec\fP * user)\fC [virtual]\fP"
.PP
Called whenever any command is about to be executed. 
.PP
This event occurs for all registered commands, wether they are registered in the core, or another module, but it will not occur for invalid commands (e.g. ones which do not exist within the command table). By returning 1 from this method you may prevent the command being executed. If you do this, no output is created by the core, and it is down to your module to produce any output neccessary. Note that unless you return 1, you should not destroy any structures (e.g. by using \fBServer::QuitUser\fP) otherwise when the command's handler function executes after your method returns, it will be passed an invalid pointer to the user object and crash!)
.PP
Definition at line 337 of file modules.cpp.
.PP
.nf
337 { return 0; };
.fi
.PP
.SS "int Module::OnRawMode (\fBuserrec\fP * user, \fBchanrec\fP * chan, char mode, \fBstd::string\fP param, bool adding, int pcnt)\fC [virtual]\fP"
.PP
Called whenever a mode character is processed. 
.PP
Return 1 from this function to block the mode character from being processed entirely, so that you may perform your own code instead. Note that this method allows you to override modes defined by other modes, but this is NOT RECOMMENDED!
.PP
Definition at line 342 of file modules.cpp.
.PP
.nf
342 { return 0; };
.fi
.PP
.SS "void Module::OnRawSocketAccept (int fd, \fBstd::string\fP ip, int localport)\fC [virtual]\fP"
.PP
Called immediately after any connection is accepted. 
.PP
This is intended for raw socket processing (e.g. modules which wrap the tcp connection within another library) and provides no information relating to a user record as the connection has not been assigned yet. There are no return values from this call as all modules get an opportunity if required to process the connection.
.PP
Definition at line 358 of file modules.cpp.
.PP
.nf
358 { };
.fi
.PP
.SS "void Module::OnRawSocketClose (int fd)\fC [virtual]\fP"
.PP
Called immediately before any socket is closed. 
.PP
When this event is called, shutdown() has not yet been called on the socket.
.PP
Definition at line 360 of file modules.cpp.
.PP
.nf
360 { };
.fi
.PP
.SS "int Module::OnRawSocketRead (int fd, char * buffer, unsigned int count, int & readresult)\fC [virtual]\fP"
.PP
Called immediately before any read() operation on a client socket in the core. 
.PP
This occurs AFTER the select() or poll() so there is always data waiting to be read when this event occurs. Your event should return 1 if it has handled the reading itself, which prevents the core just using read(). You should place any data read into buffer, up to but NOT GREATER THAN the value of count. The value of readresult must be identical to an actual result that might be returned from the read() system call, for example, number of bytes read upon success, 0 upon EOF or closed socket, and -1 for error. If your function returns a nonzero value, you MUST set readresult.
.PP
Definition at line 361 of file modules.cpp.
.PP
.nf
361 { return 0; };
.fi
.PP
.SS "int Module::OnRawSocketWrite (int fd, char * buffer, int count)\fC [virtual]\fP"
.PP
Called immediately before any write() operation on a user's socket in the core. 
.PP
Because this event is a low level event no user information is associated with it. It is intended for use by modules which may wrap connections within another API such as SSL for example. return a non-zero result if you have handled the write operation, in which case the core will not call write().
.PP
Definition at line 359 of file modules.cpp.
.PP
.nf
359 { return 0; };
.fi
.PP
.SS "void Module::OnRehash ()\fC [virtual]\fP"
.PP
Called on rehash. 
.PP
This method is called prior to a /REHASH or when a SIGHUP is received from the operating system. You should use it to reload any files so that your module keeps in step with the rest of the application.
.PP
Definition at line 315 of file modules.cpp.
.PP
.nf
315 { }
.fi
.PP
.SS "char * Module::OnRequest (\fBRequest\fP * request)\fC [virtual]\fP"
.PP
Called whenever a \fBRequest\fP class is sent to your module by another module. 
.PP
Please see the documentation of \fBRequest::Send()\fP for further information. The \fBRequest\fP sent can always be assumed to be non-NULL, you should not change the request object or its data. Your method may return arbitary data in the char* result which the requesting module may be able to use for pre-determined purposes (e.g. the results of an SQL query, etc).
.PP
Definition at line 352 of file modules.cpp.
.PP
Referenced by Request::Send().
.PP
.nf
352 { return NULL; };
.fi
.PP
.SS "void Module::OnSendList (\fBuserrec\fP * user, \fBchanrec\fP * channel, char mode)\fC [virtual]\fP"
.PP
Called whenever a list is needed for a listmode. 
.PP
For example, when a /MODE channel +b (without any other parameters) is called, if a module was handling +b this function would be called. The function can then output any lists it wishes to. Please note that all modules will see all mode characters to provide the ability to extend each other, so please only output a list if the mode character given matches the one(s) you want to handle.
.PP
Definition at line 336 of file modules.cpp.
.PP
.nf
336 { };
.fi
.PP
.SS "void Module::OnServerRaw (\fBstd::string\fP & raw, bool inbound, \fBuserrec\fP * user)\fC [virtual]\fP"
.PP
Called when a raw command is transmitted or received. 
.PP
This method is the lowest level of handler available to a module. It will be called with raw data which is passing through a connected socket. If you wish, you may munge this data by changing the string parameter 'raw'. If you do this, after your function exits it will immediately be cut down to 510 characters plus a carriage return and linefeed. For INBOUND messages only (where inbound is set to true) the value of user will be the userrec of the connection sending the data. This is not possible for outbound data because the data may be being routed to multiple targets.
.PP
Definition at line 316 of file modules.cpp.
.PP
.nf
316 { }
.fi
.PP
.SS "void Module::OnStats (char symbol)\fC [virtual]\fP"
.PP
Called on all /STATS commands This method is triggered for all /STATS use, including stats symbols handled by the core. 
.PP
Definition at line 347 of file modules.cpp.
.PP
.nf
347 { };
.fi
.PP
.SS "void Module::OnUnloadModule (\fBModule\fP * mod, \fBstd::string\fP name)\fC [virtual]\fP"
.PP
Called whenever a module is unloaded. 
.PP
mod will contain a pointer to the module, and string will contain its name, for example m_widgets.so. This function is primary for dependency checking, your module may decide to enable some extra features if it sees that you have for example loaded 'm_killwidgets.so' with 'm_makewidgets.so'. It is highly recommended that modules do *NOT* bail if they cannot satisfy dependencies, but instead operate under reduced functionality, unless the dependency is absolutely neccessary (e.g. a module that extends the features of another module).
.PP
Definition at line 334 of file modules.cpp.
.PP
.nf
334 { };
.fi
.PP
.SS "void Module::OnUserConnect (\fBuserrec\fP * user)\fC [virtual]\fP"
.PP
Called when a user connects. 
.PP
The details of the connecting user are available to you in the parameter userrec *user
.PP
Definition at line 308 of file modules.cpp.
.PP
.nf
308 { }
.fi
.PP
.SS "void Module::OnUserDisconnect (\fBuserrec\fP * user)\fC [virtual]\fP"
.PP
Called whenever a user's socket is closed. 
.PP
The details of the exiting user are available to you in the parameter userrec *user This event is called for all users, registered or not, as a cleanup method for modules which might assign resources to user, such as dns lookups, objects and sockets.
.PP
Definition at line 310 of file modules.cpp.
.PP
.nf
310 { }
.fi
.PP
.SS "void Module::OnUserJoin (\fBuserrec\fP * user, \fBchanrec\fP * channel)\fC [virtual]\fP"
.PP
Called when a user joins a channel. 
.PP
The details of the joining user are available to you in the parameter userrec *user, and the details of the channel they have joined is available in the variable chanrec *channel
.PP
Definition at line 311 of file modules.cpp.
.PP
.nf
311 { }
.fi
.PP
.SS "void Module::OnUserKick (\fBuserrec\fP * source, \fBuserrec\fP * user, \fBchanrec\fP * chan, \fBstd::string\fP reason)\fC [virtual]\fP"
.PP
Called whenever a user is kicked. 
.PP
If this method is called, the kick is already underway and cannot be prevented, so to prevent a kick, please use \fBModule::OnUserPreKick\fP instead of this method.
.PP
Definition at line 341 of file modules.cpp.
.PP
.nf
341 { };
.fi
.PP
.SS "void Module::OnUserPart (\fBuserrec\fP * user, \fBchanrec\fP * channel)\fC [virtual]\fP"
.PP
Called when a user parts a channel. 
.PP
The details of the leaving user are available to you in the parameter userrec *user, and the details of the channel they have left is available in the variable chanrec *channel
.PP
Definition at line 312 of file modules.cpp.
.PP
.nf
312 { }
.fi
.PP
.SS "void Module::OnUserPostNick (\fBuserrec\fP * user, \fBstd::string\fP oldnick)\fC [virtual]\fP"
.PP
Called after any nickchange, local or remote. 
.PP
This can be used to track users after nickchanges have been applied. Please note that although you can see remote nickchanges through this function, you should NOT make any changes to the userrec if the user is a remote user as this may cause a desnyc. check user->server before taking any action (including returning nonzero from the method). Because this method is called after the nickchange is taken place, no return values are possible to indicate forbidding of the nick change. Use OnUserPreNick for this.
.PP
Definition at line 327 of file modules.cpp.
.PP
.nf
327 { };
.fi
.PP
.SS "int Module::OnUserPreInvite (\fBuserrec\fP * source, \fBuserrec\fP * dest, \fBchanrec\fP * channel)\fC [virtual]\fP"
.PP
Called whenever a user is about to invite another user into a channel, before any processing is done. 
.PP
Returning 1 from this function stops the process immediately, causing no output to be sent to the user by the core. If you do this you must produce your own numerics, notices etc. This is useful for modules which may want to filter invites to channels.
.PP
Definition at line 323 of file modules.cpp.
.PP
.nf
323 { return 0; };
.fi
.PP
.SS "int Module::OnUserPreJoin (\fBuserrec\fP * user, \fBchanrec\fP * chan, const char * cname)\fC [virtual]\fP"
.PP
Called whenever a user is about to join a channel, before any processing is done. 
.PP
Returning a value of 1 from this function stops the process immediately, causing no output to be sent to the user by the core. If you do this you must produce your own numerics, notices etc. This is useful for modules which may want to mimic +b, +k, +l etc. Returning -1 from this function forces the join to be allowed, bypassing restrictions such as banlists, invite, keys etc.
.PP
IMPORTANT NOTE!
.PP
If the user joins a NEW channel which does not exist yet, OnUserPreJoin will be called BEFORE the channel record is created. This will cause chanrec* chan to be NULL. There is very little you can do in form of processing on the actual channel record at this point, however the channel NAME will still be passed in char* cname, so that you could for example implement a channel blacklist or whitelist, etc.
.PP
Definition at line 317 of file modules.cpp.
.PP
.nf
317 { return 0; }
.fi
.PP
.SS "int Module::OnUserPreKick (\fBuserrec\fP * source, \fBuserrec\fP * user, \fBchanrec\fP * chan, \fBstd::string\fP reason)\fC [virtual]\fP"
.PP
Called whenever a user is about to be kicked. 
.PP
Returning a value of 1 from this function stops the process immediately, causing no output to be sent to the user by the core. If you do this you must produce your own numerics, notices etc.
.PP
Definition at line 340 of file modules.cpp.
.PP
.nf
340 { return 0; };
.fi
.PP
.SS "int Module::OnUserPreMessage (\fBuserrec\fP * user, void * dest, int target_type, \fBstd::string\fP & text)\fC [virtual]\fP"
.PP
Called whenever a user is about to PRIVMSG A user or a channel, before any processing is done. 
.PP
Returning any nonzero value from this function stops the process immediately, causing no output to be sent to the user by the core. If you do this you must produce your own numerics, notices etc. This is useful for modules which may want to filter or redirect messages. target_type can be one of TYPE_USER or TYPE_CHANNEL. If the target_type value is a user, you must cast dest to a userrec* otherwise you must cast it to a chanrec*, this is the details of where the message is destined to be sent.
.PP
Definition at line 324 of file modules.cpp.
.PP
.nf
324 { return 0; };
.fi
.PP
.SS "int Module::OnUserPreNick (\fBuserrec\fP * user, \fBstd::string\fP newnick)\fC [virtual]\fP"
.PP
Called before any nickchange, local or remote. 
.PP
This can be used to implement Q-lines etc. Please note that although you can see remote nickchanges through this function, you should NOT make any changes to the userrec if the user is a remote user as this may cause a desnyc. check user->server before taking any action (including returning nonzero from the method). If your method returns nonzero, the nickchange is silently forbidden, and it is down to your module to generate some meaninful output.
.PP
Definition at line 326 of file modules.cpp.
.PP
.nf
326 { return 0; };
.fi
.PP
.SS "int Module::OnUserPreNotice (\fBuserrec\fP * user, void * dest, int target_type, \fBstd::string\fP & text)\fC [virtual]\fP"
.PP
Called whenever a user is about to NOTICE A user or a channel, before any processing is done. 
.PP
Returning any nonzero value from this function stops the process immediately, causing no output to be sent to the user by the core. If you do this you must produce your own numerics, notices etc. This is useful for modules which may want to filter or redirect messages. target_type can be one of TYPE_USER or TYPE_CHANNEL. If the target_type value is a user, you must cast dest to a userrec* otherwise you must cast it to a chanrec*, this is the details of where the message is destined to be sent. You may alter the message text as you wish before relinquishing control to the next module in the chain, and if no other modules block the text this altered form of the text will be sent out to the user and possibly to other servers.
.PP
Definition at line 325 of file modules.cpp.
.PP
.nf
325 { return 0; };
.fi
.PP
.SS "void Module::OnUserQuit (\fBuserrec\fP * user)\fC [virtual]\fP"
.PP
Called when a user quits. 
.PP
The details of the exiting user are available to you in the parameter userrec *user This event is only called when the user is fully registered when they quit. To catch raw disconnections, use the OnUserDisconnect method.
.PP
Definition at line 309 of file modules.cpp.
.PP
.nf
309 { }
.fi
.PP
.SS "void Module::OnUserRegister (\fBuserrec\fP * user)\fC [virtual]\fP"
.PP
Called whenever a user is about to register their connection (e.g. 
.PP
before the user is sent the MOTD etc). Modules can use this method if they are performing a function which must be done before the actual connection is completed (e.g. ident lookups, dnsbl lookups, etc). Note that you should NOT delete the user record here by causing a disconnection! Use OnUserConnect for that instead.
.PP
Definition at line 339 of file modules.cpp.
.PP
.nf
339 { };
.fi
.PP
.SS "\fBstring_list\fP Module::OnUserSync (\fBuserrec\fP * user)\fC [virtual]\fP"
.PP
Called during a netburst to sync user data. 
.PP
This is called during the netburst on a per-user basis. You should use this call to up any special user-related things which are implemented by your module, e.g. sending listmodes. You may return multiple commands in the string_list.
.PP
Definition at line 329 of file modules.cpp.
.PP
.nf
329 { string_list empty; return empty; }
.fi
.PP
.SS "void Module::OnWhois (\fBuserrec\fP * source, \fBuserrec\fP * dest)\fC [virtual]\fP"
.PP
Called whenever a /WHOIS is performed on a local user. 
.PP
The source parameter contains the details of the user who issued the WHOIS command, and the dest parameter contains the information of the user they are whoising.
.PP
Definition at line 322 of file modules.cpp.
.PP
.nf
322 { };
.fi
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for InspIRCd from the source code.
