.TH "serverrec" 3 "24 May 2005" "InspIRCd" \" -*- nroff -*-
.ad l
.nh
.SH NAME
serverrec \- A class that defines the local server or a remote server.  

.PP
.SH SYNOPSIS
.br
.PP
\fC#include <servers.h>\fP
.PP
Inherits \fBconnection\fP.
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBserverrec\fP ()"
.br
.RI "\fIConstructor. \fP"
.ti -1c
.RI "\fBserverrec\fP (char *n, long ver, bool jupe)"
.br
.RI "\fIConstructor which initialises some of the main variables. \fP"
.ti -1c
.RI "\fB~serverrec\fP ()"
.br
.RI "\fIDestructor. \fP"
.ti -1c
.RI "bool \fBCreateListener\fP (char *\fBhost\fP, int p)"
.br
.RI "\fICreate a listening socket on 'host' using port number 'p'. \fP"
.ti -1c
.RI "bool \fBBeginLink\fP (char *targethost, int \fBport\fP, char *password, char *servername, int myport)"
.br
.RI "\fIBegin an outbound link to another ircd at targethost. \fP"
.ti -1c
.RI "bool \fBMeshCookie\fP (char *targethost, int \fBport\fP, unsigned long cookie, char *servername)"
.br
.RI "\fIBegin an outbound mesh link to another ircd on a network you are already an authenticated member of. \fP"
.ti -1c
.RI "void \fBTerminateLink\fP (char *targethost)"
.br
.RI "\fITerminate a link to 'targethost' by calling the \fBircd_connector::CloseConnection\fP method. \fP"
.ti -1c
.RI "bool \fBSendPacket\fP (char *message, const char *\fBhost\fP)"
.br
.RI "\fISend a message to a server by name, if the server is unavailable directly route the packet via another server If the server still cannot be reached after attempting to route the message remotely, returns false. \fP"
.ti -1c
.RI "bool \fBRecvPacket\fP (std::deque< std::string > &messages, char *\fBhost\fP, std::deque< std::string > &sums)"
.br
.RI "\fIReturns the next available packet and returns true if data is available. \fP"
.ti -1c
.RI "\fBircd_connector\fP * \fBFindHost\fP (std::string \fBhost\fP)"
.br
.RI "\fIFind the \fBircd_connector\fP oject related to a certain servername given in 'host'. \fP"
.ti -1c
.RI "bool \fBAddIncoming\fP (int \fBfd\fP, char *targethost, int sourceport)"
.br
.RI "\fIAdd an incoming connection to the connection pool. \fP"
.ti -1c
.RI "void \fBFlushWriteBuffers\fP ()"
.br
.RI "\fIFlushes all data waiting to be written for all of this server's connections. \fP"
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "char \fBname\fP [MAXBUF]"
.br
.RI "\fIserver name \fP"
.ti -1c
.RI "long \fBpingtime\fP"
.br
.RI "\fIlast ping response (ms) \fP"
.ti -1c
.RI "long \fBusercount_i\fP"
.br
.RI "\fIinvisible users on server \fP"
.ti -1c
.RI "long \fBusercount\fP"
.br
.RI "\fInon-invisible users on server \fP"
.ti -1c
.RI "long \fBopercount\fP"
.br
.RI "\fIopers on server \fP"
.ti -1c
.RI "int \fBhops_away\fP"
.br
.RI "\fInumber of hops away (for quick access) \fP"
.ti -1c
.RI "long \fBversion\fP"
.br
.RI "\fIircd version \fP"
.ti -1c
.RI "bool \fBjupiter\fP"
.br
.RI "\fIis a JUPE server (faked to enforce a server ban) \fP"
.ti -1c
.RI "char \fBdescription\fP [MAXBUF]"
.br
.RI "\fIDescription of the server. \fP"
.ti -1c
.RI "char \fBnickserv\fP [NICKMAX]"
.br
.RI "\fIHolds nickserv's name on U:lined (services) servers (this is a kludge for ircservices which ASSUMES things :/). \fP"
.ti -1c
.RI "bool \fBsync_soon\fP"
.br
.ti -1c
.RI "std::vector< \fBircd_connector\fP > \fBconnectors\fP"
.br
.RI "\fIWith a serverrec, this is a list of all established server connections. \fP"
.in -1c
.SH "Detailed Description"
.PP 
A class that defines the local server or a remote server. Definition at line 30 of file servers.h.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "serverrec::serverrec ()"
.PP
Constructor. Definition at line 42 of file servers.cpp.
.PP
References connectors, connection::fd, hops_away, jupiter, connection::lastping, name, nickserv, opercount, pingtime, connection::signon, sync_soon, TIME, usercount, usercount_i, and version.
.PP
.nf
43 {
44         strlcpy(name,'',256);
45         pingtime = 0;
46         lastping = TIME;
47         usercount_i = usercount = opercount = version = 0;
48         hops_away = 1;
49         signon = TIME;
50         jupiter = false;
51         fd = 0;
52         sync_soon = false;
53         strlcpy(nickserv,'',NICKMAX);
54         connectors.clear();
55 }
.fi
.SS "serverrec::serverrec (char * n, long ver, bool jupe)"
.PP
Constructor which initialises some of the main variables. Definition at line 62 of file servers.cpp.
.PP
References connectors, connection::fd, hops_away, jupiter, connection::lastping, name, nickserv, opercount, connection::signon, sync_soon, TIME, usercount, usercount_i, and version.
.PP
.nf
63 {
64         strlcpy(name,n,256);
65         lastping = TIME;
66         usercount_i = usercount = opercount = 0;
67         version = ver;
68         hops_away = 1;
69         signon = TIME;
70         jupiter = jupe;
71         fd = 0;
72         sync_soon = false;
73         strlcpy(nickserv,'',NICKMAX);
74         connectors.clear();
75 }
.fi
.SS "serverrec::~\fBserverrec\fP ()"
.PP
Destructor. Definition at line 58 of file servers.cpp.
.PP
.nf
59 {
60 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "bool serverrec::AddIncoming (int fd, char * targethost, int sourceport)"
.PP
Add an incoming connection to the connection pool. (reserved for core use) Definition at line 207 of file servers.cpp.
.PP
References connectors, DEBUG, ircd_connector::SetDescriptor(), ircd_connector::SetHostAndPort(), ircd_connector::SetServerName(), ircd_connector::SetState(), and STATE_NOAUTH_INBOUND.
.PP
.nf
208 {
209         ircd_connector connector;
210 
211         // targethost has been turned into an ip...
212         // we dont want this as the server name.
213         connector.SetServerName(targethost);
214         connector.SetDescriptor(newfd);
215         connector.SetState(STATE_NOAUTH_INBOUND);
216         int flags = fcntl(newfd, F_GETFL, 0);
217         fcntl(newfd, F_SETFL, flags | O_NONBLOCK);
218         int sendbuf = 32768;
219         int recvbuf = 32768;
220         setsockopt(newfd,SOL_SOCKET,SO_SNDBUF,(const void *)&sendbuf,sizeof(sendbuf));
221         setsockopt(newfd,SOL_SOCKET,SO_RCVBUF,(const void *)&recvbuf,sizeof(sendbuf));
222         connector.SetHostAndPort(targethost, sourceport);
223         connector.SetState(STATE_NOAUTH_INBOUND);
224         log(DEBUG,'serverrec::AddIncoming() Added connection: %s:%d',targethost,sourceport);
225         this->connectors.push_back(connector);
226         return true;
227 }
.fi
.SS "bool serverrec::BeginLink (char * targethost, int port, char * password, char * servername, int myport)"
.PP
Begin an outbound link to another ircd at targethost. Definition at line 138 of file servers.cpp.
.PP
References connectors, connection::fd, FindHost(), ircd_connector::MakeOutboundConnection(), SendPacket(), ircd_connector::SetHostAndPort(), ircd_connector::SetServerName(), ircd_connector::SetState(), STATE_DISCONNECTED, and STATE_NOAUTH_OUTBOUND.
.PP
.nf
139 {
140         char connect[MAXBUF];
141 
142         ircd_connector connector;
143         ircd_connector *cn = this->FindHost(servername);
144 
145 
146         if (cn)
147         {
148                 WriteOpers('CONNECT aborted: Server %s already exists',servername);
149                 return false;
150         }
151 
152 
153         if (this->fd)
154         {
155                 if (connector.MakeOutboundConnection(targethost,newport))
156                 {
157                         // targethost has been turned into an ip...
158                         // we dont want this as the server name.
159                         connector.SetServerName(servername);
160                         snprintf(connect,MAXBUF,'S %s %s %lu %s :%s',getservername().c_str(),password,(unsigned long)myport,GetRevision().c_str(),getserverdesc().c_str());
161                         connector.SetState(STATE_NOAUTH_OUTBOUND);
162                         connector.SetHostAndPort(targethost, newport);
163                         this->connectors.push_back(connector);
164                         return this->SendPacket(connect, servername);
165                 }
166                 else
167                 {
168                         connector.SetState(STATE_DISCONNECTED);
169                         WriteOpers('Could not create outbound connection to %s:%d',targethost,newport);
170                 }
171         }
172         return false;
173 }
.fi
.SS "bool serverrec::CreateListener (char * host, int p)"
.PP
Create a listening socket on 'host' using port number 'p'. Definition at line 77 of file servers.cpp.
.PP
References connection::fd, MaxConn, and connection::port.
.PP
.nf
78 {
79         sockaddr_in host_address;
80         int flags;
81         in_addr addy;
82         int on = 0;
83         struct linger linger = { 0 };
84 
85         this->port = p;
86 
87         fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
88         if (fd <= 0)
89         {
90                 return false;
91         }
92 
93         setsockopt(fd,SOL_SOCKET,SO_REUSEADDR,(const char*)&on,sizeof(on));
94         linger.l_onoff = 1;
95         linger.l_linger = 1;
96         setsockopt(fd,SOL_SOCKET,SO_LINGER,(const char*)&linger,sizeof(linger));
97 
98         // attempt to increase socket sendq and recvq as high as its possible
99         // to get them on linux.
100         int sendbuf = 32768;
101         int recvbuf = 32768;
102         setsockopt(fd,SOL_SOCKET,SO_SNDBUF,(const void *)&sendbuf,sizeof(sendbuf));
103         setsockopt(fd,SOL_SOCKET,SO_RCVBUF,(const void *)&recvbuf,sizeof(sendbuf));
104 
105         memset((void*)&host_address, 0, sizeof(host_address));
106 
107         host_address.sin_family = AF_INET;
108 
109         if (!strcmp(newhost,''))
110         {
111                 host_address.sin_addr.s_addr = htonl(INADDR_ANY);
112         }
113         else
114         {
115                 inet_aton(newhost,&addy);
116                 host_address.sin_addr = addy;
117         }
118 
119         host_address.sin_port = htons(p);
120 
121         if (bind(fd,(sockaddr*)&host_address,sizeof(host_address))<0)
122         {
123                 return false;
124         }
125 
126         // make the socket non-blocking
127         flags = fcntl(fd, F_GETFL, 0);
128         fcntl(fd, F_SETFL, flags | O_NONBLOCK);
129 
130         this->port = p;
131 
132         listen(this->fd, MaxConn);
133 
134         return true;
135 }
.fi
.SS "\fBircd_connector\fP * serverrec::FindHost (std::string host)"
.PP
Find the \fBircd_connector\fP oject related to a certain servername given in 'host'. Definition at line 237 of file servers.cpp.
.PP
References connectors.
.PP
Referenced by BeginLink(), and SendPacket().
.PP
.nf
238 {
239         for (int i = 0; i < this->connectors.size(); i++)
240         {
241                 if (this->connectors[i].GetServerName() == findhost)
242                 {
243                         return &this->connectors[i];
244                 }
245         }
246         return NULL;
247 }
.fi
.SS "void serverrec::FlushWriteBuffers ()"
.PP
Flushes all data waiting to be written for all of this server's connections. Definition at line 249 of file servers.cpp.
.PP
References connectors, and STATE_DISCONNECTED.
.PP
.nf
250 {
251         for (int i = 0; i < this->connectors.size(); i++)
252         {
253                 if (this->connectors[i].GetState() != STATE_DISCONNECTED)
254                 {
255                         if (!this->connectors[i].CheckPing())
256                         {
257                                 WriteOpers('*** Lost single connection to %s: Ping timeout',this->connectors[i].GetServerName().c_str());
258                                 this->connectors[i].CloseConnection();
259                                 this->connectors[i].SetState(STATE_DISCONNECTED);
260                         }
261                 }
262                 if (this->connectors[i].HasBufferedOutput())
263                 {
264                         if (!this->connectors[i].FlushWriteBuf())
265                         {
266                                 // if we're here the write() caused an error, we cannot proceed
267                                 WriteOpers('*** Lost single connection to %s, link inactive and retrying: %s',this->connectors[i].GetServerName().c_str(),this->connectors[i].GetWriteError().c_str());
268                                 this->connectors[i].CloseConnection();
269                                 this->connectors[i].SetState(STATE_DISCONNECTED);
270                         }
271                 }
272         }
273 }
.fi
.SS "bool serverrec::MeshCookie (char * targethost, int port, unsigned long cookie, char * servername)"
.PP
Begin an outbound mesh link to another ircd on a network you are already an authenticated member of. Definition at line 176 of file servers.cpp.
.PP
References connectors, connection::fd, ircd_connector::MakeOutboundConnection(), SendPacket(), ircd_connector::SetHostAndPort(), ircd_connector::SetServerName(), ircd_connector::SetState(), STATE_CONNECTED, STATE_DISCONNECTED, and STATE_NOAUTH_OUTBOUND.
.PP
.nf
177 {
178         char connect[MAXBUF];
179 
180         ircd_connector connector;
181 
182         WriteOpers('Establishing meshed link to %s:%d',servername,newport);
183 
184         if (this->fd)
185         {
186                 if (connector.MakeOutboundConnection(targethost,newport))
187                 {
188                         // targethost has been turned into an ip...
189                         // we dont want this as the server name.
190                         connector.SetServerName(servername);
191                         snprintf(connect,MAXBUF,'- %lu %s :%s',cookie,getservername().c_str(),getserverdesc().c_str());
192                         connector.SetState(STATE_NOAUTH_OUTBOUND);
193                         connector.SetHostAndPort(targethost, newport);
194                         connector.SetState(STATE_CONNECTED);
195                         this->connectors.push_back(connector);
196                         return this->SendPacket(connect, servername);
197                 }
198                 else
199                 {
200                         connector.SetState(STATE_DISCONNECTED);
201                         WriteOpers('Could not create outbound connection to %s:%d',targethost,newport);
202                 }
203         }
204         return false;
205 }
.fi
.SS "bool serverrec::RecvPacket (std::deque< std::string > & messages, char * host, std::deque< std::string > & sums)"
.PP
Returns the next available packet and returns true if data is available. Writes the servername the data came from to 'host'. If no data is available this function returns false. This function will automatically close broken links and reroute pathways, generating split messages on the network. Definition at line 370 of file servers.cpp.
.PP
References already_have_sum(), connectors, DEBUG, and STATE_DISCONNECTED.
.PP
.nf
371 {
372         char data[65536];
373         memset(data, 0, 65536);
374         for (int i = 0; i < this->connectors.size(); i++)
375         {
376                 if (this->connectors[i].GetState() != STATE_DISCONNECTED)
377                 {
378                         // returns false if the packet could not be sent (e.g. target host down)
379                         int rcvsize = 0;
380 
381                         // check if theres any data on this socket
382                         // if not, continue onwards to the next.
383                         pollfd polls;
384                         polls.fd = this->connectors[i].GetDescriptor();
385                         polls.events = POLLIN;
386                         int ret = poll(&polls,1,1);
387                         if (ret <= 0) continue;
388 
389                         rcvsize = recv(this->connectors[i].GetDescriptor(),data,65000,0);
390                         data[rcvsize] = '\0';
391                         if (rcvsize == -1)
392                         {
393                                 if (errno != EAGAIN)
394                                 {
395                                         log(DEBUG,'recv() failed for serverrec::RecvPacket(): %s',strerror(errno));
396                                         log(DEBUG,'Disabling connector: %s',this->connectors[i].GetServerName().c_str());
397                                         this->connectors[i].CloseConnection();
398                                         this->connectors[i].SetState(STATE_DISCONNECTED);
399                                 }
400                         }
401                         int pushed = 0;
402                         if (rcvsize > 0)
403                         {
404                                 if (!this->connectors[i].AddBuffer(data))
405                                 {
406                                         WriteOpers('*** Read buffer for %s exceeds maximum, closing connection!',this->connectors[i].GetServerName().c_str());
407                                         this->connectors[i].CloseConnection();
408                                         this->connectors[i].SetState(STATE_DISCONNECTED);
409                                 }
410                                 if (this->connectors[i].BufferIsComplete())
411                                 {
412                                         this->connectors[i].ResetPing();
413                                         while (this->connectors[i].BufferIsComplete())
414                                         {
415                                                 std::string text = this->connectors[i].GetBuffer();
416                                                 if (text != '')
417                                                 {
418                                                         if ((text[0] == ':') && (text.find(' ') != std::string::npos))
419                                                         {
420                                                                 std::string orig = text;
421                                                                 log(DEBUG,'Original: %s',text.c_str());
422                                                                 std::string sum = text.substr(1,text.find(' ')-1);
423                                                                 text = text.substr(text.find(' ')+1,text.length());
424                                                                 std::string possible_token = text.substr(1,text.find(' ')-1);
425                                                                 if (possible_token.length() > 1)
426                                                                 {
427                                                                         sums.push_back('*');
428                                                                         text = orig;
429                                                                         log(DEBUG,'Non-mesh, non-tokenized string passed up the chain');
430                                                                 }
431                                                                 else
432                                                                 {
433                                                                         log(DEBUG,'Packet sum: '%s'',sum.c_str());
434                                                                         if ((already_have_sum(sum)) && (sum != '*'))
435                                                                         {
436                                                                                 // we don't accept dupes
437                                                                                 continue;
438                                                                         }
439                                                                         sums.push_back(sum.c_str());
440                                                                 }
441                                                         }
442                                                         else sums.push_back('*');
443                                                         messages.push_back(text.c_str());
444                                                         strlcpy(recvhost,this->connectors[i].GetServerName().c_str(),160);
445                                                         log(DEBUG,'serverrec::RecvPacket() %d:%s->%s',pushed++,recvhost,text.c_str());
446                                                 }
447                                         }
448                                         return true;
449                                 }
450                         }
451                 }
452         }
453         // nothing new yet -- message and host will be undefined
454         return false;
455 }
.fi
.SS "bool serverrec::SendPacket (char * message, const char * host)"
.PP
Send a message to a server by name, if the server is unavailable directly route the packet via another server If the server still cannot be reached after attempting to route the message remotely, returns false. Definition at line 275 of file servers.cpp.
.PP
References ircd_connector::AddWriteBuf(), ircd_connector::CloseConnection(), connectors, DEBUG, FindHost(), ircd_connector::FlushWriteBuf(), ircd_connector::GetServerName(), ircd_connector::GetState(), ircd_connector::GetWriteError(), ircd_connector::SetState(), and STATE_DISCONNECTED.
.PP
Referenced by BeginLink(), and MeshCookie().
.PP
.nf
276 {
277         if ((!message) || (!sendhost))
278                 return true;
279 
280         ircd_connector* cn = this->FindHost(sendhost);
281 
282         if (!strchr(message,'\n'))
283         {
284                 strlcat(message,'\n',MAXBUF);
285         }
286 
287         if (cn)
288         {
289                 log(DEBUG,'main: serverrec::SendPacket() sent '%s' to %s',message,cn->GetServerName().c_str());
290 
291                 if (cn->GetState() == STATE_DISCONNECTED)
292                 {
293                         // fix: can only route one hop to avoid a loop
294                         if (strncmp(message,'R ',2))
295                         {
296                                 log(DEBUG,'Not a double reroute');
297                                 // this route is down, we must re-route the packet through an available point in the mesh.
298                                 for (int k = 0; k < this->connectors.size(); k++)
299                                 {
300                                         log(DEBUG,'Check connector %d: %s',k,this->connectors[k].GetServerName().c_str());
301                                         // search for another point in the mesh which can 'reach' where we want to go
302                                         for (int m = 0; m < this->connectors[k].routes.size(); m++)
303                                         {
304                                                 if (!strcasecmp(this->connectors[k].routes[m].c_str(),sendhost))
305                                                 {
306                                                         log(DEBUG,'Found alternative route for packet: %s',this->connectors[k].GetServerName().c_str());
307                                                         char buffer[MAXBUF];
308                                                         snprintf(buffer,MAXBUF,'R %s %s',sendhost,message);
309                                                         this->SendPacket(buffer,this->connectors[k].GetServerName().c_str());
310                                                         return true;
311                                                 }
312                                         }
313                                 }
314                         }
315                         char buffer[MAXBUF];
316                         snprintf(buffer,MAXBUF,'& %s',sendhost);
317                         WriteOpers('*** All connections to %s lost.',sendhost);
318                         NetSendToAllExcept(sendhost,buffer);
319                         DoSplit(sendhost);
320                         return false;
321                 }
322 
323                 // returns false if the packet could not be sent (e.g. target host down)
324                 if (!cn->AddWriteBuf(message))
325                 {
326                         // if we're here, there was an error pending, and the send cannot proceed
327                         log(DEBUG,'cn->AddWriteBuf() failed for serverrec::SendPacket(): %s',cn->GetWriteError().c_str());
328                         log(DEBUG,'Disabling connector: %s',cn->GetServerName().c_str());
329                         cn->CloseConnection();
330                         cn->SetState(STATE_DISCONNECTED);
331                         WriteOpers('*** Lost single connection to %s, link inactive and retrying: %s',cn->GetServerName().c_str(),cn->GetWriteError().c_str());
332                         // retry the packet along a new route so either arrival OR failure are gauranteed (bugfix)
333                         return this->SendPacket(message,sendhost);
334                 }
335                 if (!cn->FlushWriteBuf())
336                 {
337                         // if we're here the write() caused an error, we cannot proceed
338                         log(DEBUG,'cn->FlushWriteBuf() failed for serverrec::SendPacket(): %s',cn->GetWriteError().c_str());
339                         log(DEBUG,'Disabling connector: %s',cn->GetServerName().c_str());
340                         cn->CloseConnection();
341                         cn->SetState(STATE_DISCONNECTED);
342                         WriteOpers('*** Lost single connection to %s, link inactive and retrying: %s',cn->GetServerName().c_str(),cn->GetWriteError().c_str());
343                         // retry the packet along a new route so either arrival OR failure are gauranteed
344                         return this->SendPacket(message,sendhost);
345                 }
346                 return true;
347         }
348 }
.fi
.SS "void serverrec::TerminateLink (char * targethost)"
.PP
Terminate a link to 'targethost' by calling the \fBircd_connector::CloseConnection\fP method. Definition at line 229 of file servers.cpp.
.PP
.nf
230 {
231         // this locates the targethost in the serverrec::connectors vector of the class,
232         // and terminates it by sending it an SQUIT token and closing its descriptor.
233         // TerminateLink with a null string causes a terminate of ALL links
234 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "std::vector<\fBircd_connector\fP> \fBserverrec::connectors\fP"
.PP
With a serverrec, this is a list of all established server connections. Definition at line 81 of file servers.h.
.PP
Referenced by AddIncoming(), BeginLink(), FindHost(), FlushWriteBuffers(), MeshCookie(), RecvPacket(), SendPacket(), and serverrec().
.SS "char \fBserverrec::description\fP[MAXBUF]"
.PP
Description of the server. Definition at line 61 of file servers.h.
.SS "int \fBserverrec::hops_away\fP"
.PP
number of hops away (for quick access) Definition at line 51 of file servers.h.
.PP
Referenced by serverrec().
.SS "bool \fBserverrec::jupiter\fP"
.PP
is a JUPE server (faked to enforce a server ban) Definition at line 57 of file servers.h.
.PP
Referenced by serverrec().
.SS "char \fBserverrec::name\fP[MAXBUF]"
.PP
server name Definition at line 36 of file servers.h.
.PP
Referenced by serverrec().
.SS "char \fBserverrec::nickserv\fP[NICKMAX]"
.PP
Holds nickserv's name on U:lined (services) servers (this is a kludge for ircservices which ASSUMES things :/). Definition at line 65 of file servers.h.
.PP
Referenced by serverrec().
.SS "long \fBserverrec::opercount\fP"
.PP
opers on server Definition at line 48 of file servers.h.
.PP
Referenced by serverrec().
.SS "long \fBserverrec::pingtime\fP"
.PP
last ping response (ms) Definition at line 39 of file servers.h.
.PP
Referenced by serverrec().
.SS "bool \fBserverrec::sync_soon\fP"
.PP
Definition at line 67 of file servers.h.
.PP
Referenced by serverrec().
.SS "long \fBserverrec::usercount\fP"
.PP
non-invisible users on server Definition at line 45 of file servers.h.
.PP
Referenced by serverrec().
.SS "long \fBserverrec::usercount_i\fP"
.PP
invisible users on server Definition at line 42 of file servers.h.
.PP
Referenced by serverrec().
.SS "long \fBserverrec::version\fP"
.PP
ircd version Definition at line 54 of file servers.h.
.PP
Referenced by serverrec().

.SH "Author"
.PP 
Generated automatically by Doxygen for InspIRCd from the source code.
