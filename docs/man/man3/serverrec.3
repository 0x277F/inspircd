.TH "serverrec" 3 "30 May 2005" "InspIRCd" \" -*- nroff -*-
.ad l
.nh
.SH NAME
serverrec \- A class that defines the local server or a remote server.  

.PP
.SH SYNOPSIS
.br
.PP
\fC#include <servers.h>\fP
.PP
Inherits \fBconnection\fP.
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBserverrec\fP ()"
.br
.RI "\fIConstructor. \fP"
.ti -1c
.RI "\fBserverrec\fP (char *n, long ver, bool jupe)"
.br
.RI "\fIConstructor which initialises some of the main variables. \fP"
.ti -1c
.RI "\fB~serverrec\fP ()"
.br
.RI "\fIDestructor. \fP"
.ti -1c
.RI "bool \fBCreateListener\fP (char *\fBhost\fP, int p)"
.br
.RI "\fICreate a listening socket on 'host' using port number 'p'. \fP"
.ti -1c
.RI "bool \fBBeginLink\fP (char *targethost, int \fBport\fP, char *password, char *servername, int myport)"
.br
.RI "\fIBegin an outbound link to another ircd at targethost. \fP"
.ti -1c
.RI "bool \fBMeshCookie\fP (char *targethost, int \fBport\fP, unsigned long cookie, char *servername)"
.br
.RI "\fIBegin an outbound mesh link to another ircd on a network you are already an authenticated member of. \fP"
.ti -1c
.RI "void \fBTerminateLink\fP (char *targethost)"
.br
.RI "\fITerminate a link to 'targethost' by calling the \fBircd_connector::CloseConnection\fP method. \fP"
.ti -1c
.RI "bool \fBSendPacket\fP (char *message, const char *\fBhost\fP)"
.br
.RI "\fISend a message to a server by name, if the server is unavailable directly route the packet via another server If the server still cannot be reached after attempting to route the message remotely, returns false. \fP"
.ti -1c
.RI "bool \fBRecvPacket\fP (std::deque< std::string > &messages, char *\fBhost\fP, std::deque< std::string > &sums)"
.br
.RI "\fIReturns the next available packet and returns true if data is available. \fP"
.ti -1c
.RI "\fBircd_connector\fP * \fBFindHost\fP (std::string \fBhost\fP)"
.br
.RI "\fIFind the \fBircd_connector\fP oject related to a certain servername given in 'host'. \fP"
.ti -1c
.RI "bool \fBAddIncoming\fP (int \fBfd\fP, char *targethost, int sourceport)"
.br
.RI "\fIAdd an incoming connection to the connection pool. \fP"
.ti -1c
.RI "void \fBFlushWriteBuffers\fP ()"
.br
.RI "\fIFlushes all data waiting to be written for all of this server's connections. \fP"
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "char \fBname\fP [MAXBUF]"
.br
.RI "\fIserver name \fP"
.ti -1c
.RI "long \fBpingtime\fP"
.br
.RI "\fIlast ping response (ms) \fP"
.ti -1c
.RI "long \fBusercount_i\fP"
.br
.RI "\fIinvisible users on server \fP"
.ti -1c
.RI "long \fBusercount\fP"
.br
.RI "\fInon-invisible users on server \fP"
.ti -1c
.RI "long \fBopercount\fP"
.br
.RI "\fIopers on server \fP"
.ti -1c
.RI "int \fBhops_away\fP"
.br
.RI "\fInumber of hops away (for quick access) \fP"
.ti -1c
.RI "long \fBversion\fP"
.br
.RI "\fIircd version \fP"
.ti -1c
.RI "bool \fBjupiter\fP"
.br
.RI "\fIis a JUPE server (faked to enforce a server ban) \fP"
.ti -1c
.RI "char \fBdescription\fP [MAXBUF]"
.br
.RI "\fIDescription of the server. \fP"
.ti -1c
.RI "char \fBnickserv\fP [NICKMAX]"
.br
.RI "\fIHolds nickserv's name on U:lined (services) servers (this is a kludge for ircservices which ASSUMES things :/). \fP"
.ti -1c
.RI "bool \fBsync_soon\fP"
.br
.ti -1c
.RI "std::vector< \fBircd_connector\fP > \fBconnectors\fP"
.br
.RI "\fIWith a serverrec, this is a list of all established server connections. \fP"
.in -1c
.SH "Detailed Description"
.PP 
A class that defines the local server or a remote server. Definition at line 30 of file servers.h.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "serverrec::serverrec ()"
.PP
Constructor. Definition at line 46 of file servers.cpp.
.PP
References connectors, connection::fd, hops_away, jupiter, connection::lastping, name, nickserv, opercount, pingtime, connection::signon, sync_soon, TIME, usercount, usercount_i, and version.
.PP
.nf
47 {
48         strlcpy(name,'',256);
49         pingtime = 0;
50         lastping = TIME;
51         usercount_i = usercount = opercount = version = 0;
52         hops_away = 1;
53         signon = TIME;
54         jupiter = false;
55         fd = 0;
56         sync_soon = false;
57         strlcpy(nickserv,'',NICKMAX);
58         connectors.clear();
59 }
.fi
.SS "serverrec::serverrec (char * n, long ver, bool jupe)"
.PP
Constructor which initialises some of the main variables. Definition at line 66 of file servers.cpp.
.PP
References connectors, connection::fd, hops_away, jupiter, connection::lastping, name, nickserv, opercount, connection::signon, sync_soon, TIME, usercount, usercount_i, and version.
.PP
.nf
67 {
68         strlcpy(name,n,256);
69         lastping = TIME;
70         usercount_i = usercount = opercount = 0;
71         version = ver;
72         hops_away = 1;
73         signon = TIME;
74         jupiter = jupe;
75         fd = 0;
76         sync_soon = false;
77         strlcpy(nickserv,'',NICKMAX);
78         connectors.clear();
79 }
.fi
.SS "serverrec::~\fBserverrec\fP ()"
.PP
Destructor. Definition at line 62 of file servers.cpp.
.PP
.nf
63 {
64 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "bool serverrec::AddIncoming (int fd, char * targethost, int sourceport)"
.PP
Add an incoming connection to the connection pool. (reserved for core use) Definition at line 212 of file servers.cpp.
.PP
References connectors, DEBUG, ircd_connector::SetDescriptor(), ircd_connector::SetHostAndPort(), ircd_connector::SetServerName(), ircd_connector::SetState(), and STATE_NOAUTH_INBOUND.
.PP
.nf
213 {
214         ircd_connector connector;
215 
216         // targethost has been turned into an ip...
217         // we dont want this as the server name.
218         connector.SetServerName(targethost);
219         connector.SetDescriptor(newfd);
220         connector.SetState(STATE_NOAUTH_INBOUND);
221         int flags = fcntl(newfd, F_GETFL, 0);
222         fcntl(newfd, F_SETFL, flags | O_NONBLOCK);
223         int sendbuf = 32768;
224         int recvbuf = 32768;
225         setsockopt(newfd,SOL_SOCKET,SO_SNDBUF,(const void *)&sendbuf,sizeof(sendbuf));
226         setsockopt(newfd,SOL_SOCKET,SO_RCVBUF,(const void *)&recvbuf,sizeof(sendbuf));
227         connector.SetHostAndPort(targethost, sourceport);
228         connector.SetState(STATE_NOAUTH_INBOUND);
229         log(DEBUG,'serverrec::AddIncoming() Added connection: %s:%d',targethost,sourceport);
230         this->connectors.push_back(connector);
231         return true;
232 }
.fi
.SS "bool serverrec::BeginLink (char * targethost, int port, char * password, char * servername, int myport)"
.PP
Begin an outbound link to another ircd at targethost. Definition at line 142 of file servers.cpp.
.PP
References connectors, connection::fd, FindHost(), ircd_connector::MakeOutboundConnection(), SendPacket(), ircd_connector::SetHostAndPort(), ircd_connector::SetServerName(), ircd_connector::SetState(), STATE_DISCONNECTED, and STATE_NOAUTH_OUTBOUND.
.PP
.nf
143 {
144         char connect[MAXBUF];
145 
146         ircd_connector connector;
147         ircd_connector *cn = this->FindHost(servername);
148 
149 
150         if (cn)
151         {
152                 WriteOpers('CONNECT aborted: Server %s already exists',servername);
153                 return false;
154         }
155 
156 
157         if (this->fd)
158         {
159                 if (connector.MakeOutboundConnection(targethost,newport))
160                 {
161                         // targethost has been turned into an ip...
162                         // we dont want this as the server name.
163                         connector.SetServerName(servername);
164                         snprintf(connect,MAXBUF,'S %s %s %lu %s :%s',getservername().c_str(),password,(unsigned long)myport,GetRevision().c_str(),getserverdesc().c_str());
165                         connector.SetState(STATE_NOAUTH_OUTBOUND);
166                         connector.SetHostAndPort(targethost, newport);
167                         this->connectors.push_back(connector);
168                         // this packet isn't actually sent until the socket connects -- the STATE_NOAUTH_OUTBOUND state
169                         // queues outbound data until the socket is polled as writeable (e.g. the connection is established)
170                         return this->SendPacket(connect, servername);
171                 }
172                 else
173                 {
174                         connector.SetState(STATE_DISCONNECTED);
175                         WriteOpers('Could not create outbound connection to %s:%d',targethost,newport);
176                 }
177         }
178         return false;
179 }
.fi
.SS "bool serverrec::CreateListener (char * host, int p)"
.PP
Create a listening socket on 'host' using port number 'p'. Definition at line 81 of file servers.cpp.
.PP
References connection::fd, MaxConn, and connection::port.
.PP
.nf
82 {
83         sockaddr_in host_address;
84         int flags;
85         in_addr addy;
86         int on = 0;
87         struct linger linger = { 0 };
88 
89         this->port = p;
90 
91         fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
92         if (fd <= 0)
93         {
94                 return false;
95         }
96 
97         setsockopt(fd,SOL_SOCKET,SO_REUSEADDR,(const char*)&on,sizeof(on));
98         linger.l_onoff = 1;
99         linger.l_linger = 1;
100         setsockopt(fd,SOL_SOCKET,SO_LINGER,(const char*)&linger,sizeof(linger));
101 
102         // attempt to increase socket sendq and recvq as high as its possible
103         // to get them on linux.
104         int sendbuf = 32768;
105         int recvbuf = 32768;
106         setsockopt(fd,SOL_SOCKET,SO_SNDBUF,(const void *)&sendbuf,sizeof(sendbuf));
107         setsockopt(fd,SOL_SOCKET,SO_RCVBUF,(const void *)&recvbuf,sizeof(sendbuf));
108 
109         memset((void*)&host_address, 0, sizeof(host_address));
110 
111         host_address.sin_family = AF_INET;
112 
113         if (!strcmp(newhost,''))
114         {
115                 host_address.sin_addr.s_addr = htonl(INADDR_ANY);
116         }
117         else
118         {
119                 inet_aton(newhost,&addy);
120                 host_address.sin_addr = addy;
121         }
122 
123         host_address.sin_port = htons(p);
124 
125         if (bind(fd,(sockaddr*)&host_address,sizeof(host_address))<0)
126         {
127                 return false;
128         }
129 
130         // make the socket non-blocking
131         flags = fcntl(fd, F_GETFL, 0);
132         fcntl(fd, F_SETFL, flags | O_NONBLOCK);
133 
134         this->port = p;
135 
136         listen(this->fd, MaxConn);
137 
138         return true;
139 }
.fi
.SS "\fBircd_connector\fP * serverrec::FindHost (std::string host)"
.PP
Find the \fBircd_connector\fP oject related to a certain servername given in 'host'. Definition at line 242 of file servers.cpp.
.PP
References connectors.
.PP
Referenced by BeginLink(), and SendPacket().
.PP
.nf
243 {
244         for (int i = 0; i < this->connectors.size(); i++)
245         {
246                 if (this->connectors[i].GetServerName() == findhost)
247                 {
248                         return &this->connectors[i];
249                 }
250         }
251         return NULL;
252 }
.fi
.SS "void serverrec::FlushWriteBuffers ()"
.PP
Flushes all data waiting to be written for all of this server's connections. Definition at line 274 of file servers.cpp.
.PP
References connectors, has_been_netsplit, IsRoutable(), STATE_DISCONNECTED, STATE_NOAUTH_INBOUND, STATE_NOAUTH_OUTBOUND, and TIME.
.PP
.nf
275 {
276         char buffer[MAXBUF];
277         for (int i = 0; i < this->connectors.size(); i++)
278         {
279                 // don't try and ping a NOAUTH_OUTBOUND state, its not authed yet!
280                 if ((this->connectors[i].GetState() == STATE_NOAUTH_OUTBOUND) && (TIME > this->connectors[i].age+30))
281                 {
282                         // however if we reach this timer its connected timed out :)
283                         WriteOpers('*** Connection to %s timed out',this->connectors[i].GetServerName().c_str());
284                         snprintf(buffer,MAXBUF,'& %s',this->connectors[i].GetServerName().c_str());
285                         NetSendToAllExcept(this->connectors[i].GetServerName().c_str(),buffer);
286                         DoSplit(this->connectors[i].GetServerName().c_str());
287                         return;
288                 }
289                 if ((this->connectors[i].GetState() == STATE_NOAUTH_INBOUND) && (TIME > this->connectors[i].age+30))
290                 {
291                         WriteOpers('*** Connection from %s timed out',this->connectors[i].GetServerName().c_str());
292                         snprintf(buffer,MAXBUF,'& %s',this->connectors[i].GetServerName().c_str());
293                         NetSendToAllExcept(this->connectors[i].GetServerName().c_str(),buffer);
294                         DoSplit(this->connectors[i].GetServerName().c_str());
295                         return;
296                 }
297                 if (this->connectors[i].GetState() != STATE_DISCONNECTED)
298                 {
299                         if (!this->connectors[i].CheckPing())
300                         {
301                                 WriteOpers('*** Lost single connection to %s: Ping timeout',this->connectors[i].GetServerName().c_str());
302                                 this->connectors[i].CloseConnection();
303                                 this->connectors[i].SetState(STATE_DISCONNECTED);
304                                 if (!IsRoutable(this->connectors[i].GetServerName()))
305                                 {
306                                         WriteOpers('*** Server %s is no longer routable, disconnecting.',this->connectors[i].GetServerName().c_str());
307                                         snprintf(buffer,MAXBUF,'& %s',this->connectors[i].GetServerName().c_str());
308                                         NetSendToAllExcept(this->connectors[i].GetServerName().c_str(),buffer);
309                                         DoSplit(this->connectors[i].GetServerName().c_str());
310                                 }
311                                 has_been_netsplit = true;
312                         }
313                 }
314                 if ((this->connectors[i].GetWriteError() !='') && (this->connectors[i].GetState() != STATE_DISCONNECTED))
315                 {
316                         // if we're here the write() caused an error, we cannot proceed
317                         WriteOpers('*** Lost single connection to %s, link inactive and retrying: %s',this->connectors[i].GetServerName().c_str(),this->connectors[i].GetWriteError().c_str());
318                         this->connectors[i].CloseConnection();
319                         this->connectors[i].SetState(STATE_DISCONNECTED);
320                         if (!IsRoutable(this->connectors[i].GetServerName()))
321                         {
322                                 WriteOpers('*** Server %s is no longer routable, disconnecting.',this->connectors[i].GetServerName().c_str());
323                                 snprintf(buffer,MAXBUF,'& %s',this->connectors[i].GetServerName().c_str());
324                                 NetSendToAllExcept(this->connectors[i].GetServerName().c_str(),buffer);
325                                 DoSplit(this->connectors[i].GetServerName().c_str());
326                         }
327                         has_been_netsplit = true;
328                 }
329                 if ((this->connectors[i].HasBufferedOutput()) && (this->connectors[i].GetState() != STATE_DISCONNECTED))
330                 {
331                         if (!this->connectors[i].FlushWriteBuf())
332                         {
333                                 // if we're here the write() caused an error, we cannot proceed
334                                 WriteOpers('*** Lost single connection to %s, link inactive and retrying: %s',this->connectors[i].GetServerName().c_str(),this->connectors[i].GetWriteError().c_str());
335                                 this->connectors[i].CloseConnection();
336                                 this->connectors[i].SetState(STATE_DISCONNECTED);
337                                 if (!IsRoutable(this->connectors[i].GetServerName()))
338                                 {
339                                         WriteOpers('*** Server %s is no longer routable, disconnecting.',this->connectors[i].GetServerName().c_str());
340                                         snprintf(buffer,MAXBUF,'& %s',this->connectors[i].GetServerName().c_str());
341                                         NetSendToAllExcept(this->connectors[i].GetServerName().c_str(),buffer);
342                                         DoSplit(this->connectors[i].GetServerName().c_str());
343                                 }
344                                 has_been_netsplit = true;
345                         }
346                 }
347         }
348 }
.fi
.SS "bool serverrec::MeshCookie (char * targethost, int port, unsigned long cookie, char * servername)"
.PP
Begin an outbound mesh link to another ircd on a network you are already an authenticated member of. Definition at line 182 of file servers.cpp.
.PP
References connectors, connection::fd, ircd_connector::MakeOutboundConnection(), SendPacket(), ircd_connector::SetHostAndPort(), ircd_connector::SetServerName(), ircd_connector::SetState(), STATE_DISCONNECTED, and STATE_NOAUTH_OUTBOUND.
.PP
.nf
183 {
184         char connect[MAXBUF];
185 
186         ircd_connector connector;
187 
188         WriteOpers('Establishing meshed link to %s:%d',servername,newport);
189 
190         if (this->fd)
191         {
192                 if (connector.MakeOutboundConnection(targethost,newport))
193                 {
194                         // targethost has been turned into an ip...
195                         // we dont want this as the server name.
196                         connector.SetServerName(servername);
197                         snprintf(connect,MAXBUF,'- %lu %s :%s',cookie,getservername().c_str(),getserverdesc().c_str());
198                         connector.SetState(STATE_NOAUTH_OUTBOUND);
199                         connector.SetHostAndPort(targethost, newport);
200                         this->connectors.push_back(connector);
201                         return this->SendPacket(connect, servername);
202                 }
203                 else
204                 {
205                         connector.SetState(STATE_DISCONNECTED);
206                         WriteOpers('Could not create outbound connection to %s:%d',targethost,newport);
207                 }
208         }
209         return false;
210 }
.fi
.SS "bool serverrec::RecvPacket (std::deque< std::string > & messages, char * host, std::deque< std::string > & sums)"
.PP
Returns the next available packet and returns true if data is available. Writes the servername the data came from to 'host'. If no data is available this function returns false. This function will automatically close broken links and reroute pathways, generating split messages on the network. Definition at line 445 of file servers.cpp.
.PP
References already_have_sum(), connectors, DEBUG, has_been_netsplit, IsRoutable(), and STATE_DISCONNECTED.
.PP
.nf
446 {
447         char data[65536],buffer[MAXBUF];
448         memset(data, 0, 65536);
449         for (int i = 0; i < this->connectors.size(); i++)
450         {
451                 if (this->connectors[i].GetState() != STATE_DISCONNECTED)
452                 {
453                         // returns false if the packet could not be sent (e.g. target host down)
454                         int rcvsize = 0;
455 
456                         // check if theres any data on this socket
457                         // if not, continue onwards to the next.
458                         pollfd polls;
459                         polls.fd = this->connectors[i].GetDescriptor();
460                         polls.events = POLLIN;
461                         int ret = poll(&polls,1,1);
462                         if (ret <= 0) continue;
463 
464                         rcvsize = recv(this->connectors[i].GetDescriptor(),data,65000,0);
465                         data[rcvsize] = '\0';
466                         if (rcvsize == 0)
467                         {
468                                 log(DEBUG,'recv() failed for serverrec::RecvPacket(): EOF');
469                                 log(DEBUG,'Disabling connector: %s',this->connectors[i].GetServerName().c_str());
470                                 this->connectors[i].CloseConnection();
471                                 this->connectors[i].SetState(STATE_DISCONNECTED);
472                                 if (!IsRoutable(this->connectors[i].GetServerName()))
473                                 {
474                                         WriteOpers('*** Server %s is no longer routable, disconnecting (EOF)',this->connectors[i].GetServerName().c_str());
475                                         snprintf(buffer,MAXBUF,'& %s',this->connectors[i].GetServerName().c_str());
476                                         NetSendToAllExcept(this->connectors[i].GetServerName().c_str(),buffer);
477                                         DoSplit(this->connectors[i].GetServerName().c_str());
478                                 }
479                                 has_been_netsplit = true;
480                         }
481                         if (rcvsize == -1)
482                         {
483                                 if (errno != EAGAIN)
484                                 {
485                                         log(DEBUG,'recv() failed for serverrec::RecvPacket(): %s',strerror(errno));
486                                         log(DEBUG,'Disabling connector: %s',this->connectors[i].GetServerName().c_str());
487                                         this->connectors[i].CloseConnection();
488                                         this->connectors[i].SetState(STATE_DISCONNECTED);
489                                         if (!IsRoutable(this->connectors[i].GetServerName()))
490                                         {
491                                                 WriteOpers('*** Server %s is no longer routable, disconnecting.',this->connectors[i].GetServerName().c_str());
492                                                 snprintf(buffer,MAXBUF,'& %s',this->connectors[i].GetServerName().c_str());
493                                                 NetSendToAllExcept(this->connectors[i].GetServerName().c_str(),buffer);
494                                                 DoSplit(this->connectors[i].GetServerName().c_str());
495                                         }
496                                         has_been_netsplit = true;
497                                 }
498                         }
499                         int pushed = 0;
500                         if (rcvsize > 0)
501                         {
502                                 if (!this->connectors[i].AddBuffer(data))
503                                 {
504                                         WriteOpers('*** Read buffer for %s exceeds maximum, closing connection!',this->connectors[i].GetServerName().c_str());
505                                         this->connectors[i].CloseConnection();
506                                         this->connectors[i].SetState(STATE_DISCONNECTED);
507                                         if (!IsRoutable(this->connectors[i].GetServerName()))
508                                         {
509                                                 WriteOpers('*** Server %s is no longer routable, disconnecting.',this->connectors[i].GetServerName().c_str());
510                                                 snprintf(buffer,MAXBUF,'& %s',this->connectors[i].GetServerName().c_str());
511                                                 NetSendToAllExcept(this->connectors[i].GetServerName().c_str(),buffer);
512                                                 DoSplit(this->connectors[i].GetServerName().c_str());
513                                         }
514                                         has_been_netsplit = true;
515                                 }
516                                 if (this->connectors[i].BufferIsComplete())
517                                 {
518                                         this->connectors[i].ResetPing();
519                                         while (this->connectors[i].BufferIsComplete())
520                                         {
521                                                 std::string text = this->connectors[i].GetBuffer();
522                                                 if (text != '')
523                                                 {
524                                                         if ((text[0] == ':') && (text.find(' ') != std::string::npos))
525                                                         {
526                                                                 std::string orig = text;
527                                                                 log(DEBUG,'Original: %s',text.c_str());
528                                                                 std::string sum = text.substr(1,text.find(' ')-1);
529                                                                 text = text.substr(text.find(' ')+1,text.length());
530                                                                 std::string possible_token = text.substr(1,text.find(' ')-1);
531                                                                 if (possible_token.length() > 1)
532                                                                 {
533                                                                         sums.push_back('*');
534                                                                         text = orig;
535                                                                         log(DEBUG,'Non-mesh, non-tokenized string passed up the chain');
536                                                                 }
537                                                                 else
538                                                                 {
539                                                                         log(DEBUG,'Packet sum: '%s'',sum.c_str());
540                                                                         if ((already_have_sum(sum)) && (sum != '*'))
541                                                                         {
542                                                                                 // we don't accept dupes
543                                                                                 continue;
544                                                                         }
545                                                                         sums.push_back(sum.c_str());
546                                                                 }
547                                                         }
548                                                         else sums.push_back('*');
549                                                         messages.push_back(text.c_str());
550                                                         strlcpy(recvhost,this->connectors[i].GetServerName().c_str(),160);
551                                                         log(DEBUG,'serverrec::RecvPacket() %d:%s->%s',pushed++,recvhost,text.c_str());
552                                                 }
553                                         }
554                                         return true;
555                                 }
556                         }
557                 }
558         }
559         // nothing new yet -- message and host will be undefined
560         return false;
561 }
.fi
.SS "bool serverrec::SendPacket (char * message, const char * host)"
.PP
Send a message to a server by name, if the server is unavailable directly route the packet via another server If the server still cannot be reached after attempting to route the message remotely, returns false. Definition at line 350 of file servers.cpp.
.PP
References ircd_connector::AddWriteBuf(), ircd_connector::CloseConnection(), connectors, DEBUG, FindHost(), ircd_connector::FlushWriteBuf(), ircd_connector::GetServerName(), ircd_connector::GetState(), ircd_connector::GetWriteError(), ircd_connector::SetState(), and STATE_DISCONNECTED.
.PP
Referenced by BeginLink(), and MeshCookie().
.PP
.nf
351 {
352         if ((!message) || (!sendhost))
353                 return true;
354 
355         ircd_connector* cn = this->FindHost(sendhost);
356 
357         if (!strchr(message,'\n'))
358         {
359                 strlcat(message,'\n',MAXBUF);
360         }
361 
362         if (cn)
363         {
364                 log(DEBUG,'main: serverrec::SendPacket() sent '%s' to %s',message,cn->GetServerName().c_str());
365 
366                 if (cn->GetState() == STATE_DISCONNECTED)
367                 {
368                         // fix: can only route one hop to avoid a loop
369                         if (strncmp(message,'R ',2))
370                         {
371                                 log(DEBUG,'Not a double reroute');
372                                 // this route is down, we must re-route the packet through an available point in the mesh.
373                                 for (int k = 0; k < this->connectors.size(); k++)
374                                 {
375                                         log(DEBUG,'Check connector %d: %s',k,this->connectors[k].GetServerName().c_str());
376                                         // search for another point in the mesh which can 'reach' where we want to go
377                                         for (int m = 0; m < this->connectors[k].routes.size(); m++)
378                                         {
379                                                 if (!strcasecmp(this->connectors[k].routes[m].c_str(),sendhost))
380                                                 {
381                                                         log(DEBUG,'Found alternative route for packet: %s',this->connectors[k].GetServerName().c_str());
382                                                         char buffer[MAXBUF];
383                                                         snprintf(buffer,MAXBUF,'R %s %s',sendhost,message);
384                                                         this->SendPacket(buffer,this->connectors[k].GetServerName().c_str());
385                                                         return true;
386                                                 }
387                                         }
388                                 }
389                         }
390                         char buffer[MAXBUF];
391                         snprintf(buffer,MAXBUF,'& %s',sendhost);
392                         WriteOpers('*** All connections to %s lost.',sendhost);
393                         NetSendToAllExcept(sendhost,buffer);
394                         DoSplit(sendhost);
395                         return false;
396                 }
397 
398                 // returns false if the packet could not be sent (e.g. target host down)
399                 if (!cn->AddWriteBuf(message))
400                 {
401                         // if we're here, there was an error pending, and the send cannot proceed
402                         log(DEBUG,'cn->AddWriteBuf() failed for serverrec::SendPacket(): %s',cn->GetWriteError().c_str());
403                         log(DEBUG,'Disabling connector: %s',cn->GetServerName().c_str());
404                         cn->CloseConnection();
405                         cn->SetState(STATE_DISCONNECTED);
406                         WriteOpers('*** Lost single connection to %s, link inactive and retrying: %s',cn->GetServerName().c_str(),cn->GetWriteError().c_str());
407                         // retry the packet along a new route so either arrival OR failure are gauranteed (bugfix)
408                         return this->SendPacket(message,sendhost);
409                 }
410                 if (!cn->FlushWriteBuf())
411                 {
412                         // if we're here the write() caused an error, we cannot proceed
413                         log(DEBUG,'cn->FlushWriteBuf() failed for serverrec::SendPacket(): %s',cn->GetWriteError().c_str());
414                         log(DEBUG,'Disabling connector: %s',cn->GetServerName().c_str());
415                         cn->CloseConnection();
416                         cn->SetState(STATE_DISCONNECTED);
417                         WriteOpers('*** Lost single connection to %s, link inactive and retrying: %s',cn->GetServerName().c_str(),cn->GetWriteError().c_str());
418                         // retry the packet along a new route so either arrival OR failure are gauranteed
419                         return this->SendPacket(message,sendhost);
420                 }
421                 return true;
422         }
423 }
.fi
.SS "void serverrec::TerminateLink (char * targethost)"
.PP
Terminate a link to 'targethost' by calling the \fBircd_connector::CloseConnection\fP method. Definition at line 234 of file servers.cpp.
.PP
.nf
235 {
236         // this locates the targethost in the serverrec::connectors vector of the class,
237        // and terminates it by sending it an SQUIT token and closing its descriptor.
238         // TerminateLink with a null string causes a terminate of ALL links
239 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "std::vector<\fBircd_connector\fP> \fBserverrec::connectors\fP"
.PP
With a serverrec, this is a list of all established server connections. Definition at line 81 of file servers.h.
.PP
Referenced by AddIncoming(), BeginLink(), FindHost(), FlushWriteBuffers(), IsRoutable(), MeshCookie(), RecvPacket(), SendPacket(), and serverrec().
.SS "char \fBserverrec::description\fP[MAXBUF]"
.PP
Description of the server. Definition at line 61 of file servers.h.
.SS "int \fBserverrec::hops_away\fP"
.PP
number of hops away (for quick access) Definition at line 51 of file servers.h.
.PP
Referenced by serverrec().
.SS "bool \fBserverrec::jupiter\fP"
.PP
is a JUPE server (faked to enforce a server ban) Definition at line 57 of file servers.h.
.PP
Referenced by serverrec().
.SS "char \fBserverrec::name\fP[MAXBUF]"
.PP
server name Definition at line 36 of file servers.h.
.PP
Referenced by serverrec().
.SS "char \fBserverrec::nickserv\fP[NICKMAX]"
.PP
Holds nickserv's name on U:lined (services) servers (this is a kludge for ircservices which ASSUMES things :/). Definition at line 65 of file servers.h.
.PP
Referenced by serverrec().
.SS "long \fBserverrec::opercount\fP"
.PP
opers on server Definition at line 48 of file servers.h.
.PP
Referenced by serverrec().
.SS "long \fBserverrec::pingtime\fP"
.PP
last ping response (ms) Definition at line 39 of file servers.h.
.PP
Referenced by serverrec().
.SS "bool \fBserverrec::sync_soon\fP"
.PP
Definition at line 67 of file servers.h.
.PP
Referenced by serverrec().
.SS "long \fBserverrec::usercount\fP"
.PP
non-invisible users on server Definition at line 45 of file servers.h.
.PP
Referenced by serverrec().
.SS "long \fBserverrec::usercount_i\fP"
.PP
invisible users on server Definition at line 42 of file servers.h.
.PP
Referenced by serverrec().
.SS "long \fBserverrec::version\fP"
.PP
ircd version Definition at line 54 of file servers.h.
.PP
Referenced by serverrec().

.SH "Author"
.PP 
Generated automatically by Doxygen for InspIRCd from the source code.
