.TH "InspSocket" 3 "9 Dec 2005" "Version 1.0Betareleases" "InspIRCd" \" -*- nroff -*-
.ad l
.nh
.SH NAME
InspSocket \- 
.SH SYNOPSIS
.br
.PP
\fC#include <socket.h>\fP
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBInspSocket\fP ()"
.br
.ti -1c
.RI "\fBInspSocket\fP (int newfd, char *ip)"
.br
.ti -1c
.RI "\fBInspSocket\fP (\fBstd::string\fP \fBhost\fP, int \fBport\fP, bool listening, unsigned long maxtime)"
.br
.ti -1c
.RI "virtual bool \fBOnConnected\fP ()"
.br
.ti -1c
.RI "virtual void \fBOnError\fP (\fBInspSocketError\fP e)"
.br
.ti -1c
.RI "virtual int \fBOnDisconnect\fP ()"
.br
.ti -1c
.RI "virtual bool \fBOnDataReady\fP ()"
.br
.ti -1c
.RI "virtual void \fBOnTimeout\fP ()"
.br
.ti -1c
.RI "virtual void \fBOnClose\fP ()"
.br
.ti -1c
.RI "virtual char * \fBRead\fP ()"
.br
.ti -1c
.RI "\fBstd::string\fP \fBGetIP\fP ()"
.br
.ti -1c
.RI "virtual int \fBWrite\fP (\fBstd::string\fP data)"
.br
.ti -1c
.RI "virtual int \fBOnIncomingConnection\fP (int newfd, char *ip)"
.br
.ti -1c
.RI "void \fBSetState\fP (\fBInspSocketState\fP s)"
.br
.ti -1c
.RI "\fBInspSocketState\fP \fBGetState\fP ()"
.br
.ti -1c
.RI "bool \fBPoll\fP ()"
.br
.ti -1c
.RI "virtual void \fBClose\fP ()"
.br
.ti -1c
.RI "virtual \fB~InspSocket\fP ()"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "int \fBfd\fP"
.br
.ti -1c
.RI "\fBstd::string\fP \fBhost\fP"
.br
.ti -1c
.RI "int \fBport\fP"
.br
.ti -1c
.RI "\fBInspSocketState\fP \fBstate\fP"
.br
.ti -1c
.RI "sockaddr_in \fBaddr\fP"
.br
.ti -1c
.RI "in_addr \fBaddy\fP"
.br
.ti -1c
.RI "time_t \fBtimeout_end\fP"
.br
.ti -1c
.RI "bool \fBtimeout\fP"
.br
.ti -1c
.RI "pollfd \fBpolls\fP"
.br
.ti -1c
.RI "char \fBibuf\fP [16384]"
.br
.ti -1c
.RI "\fBstd::string\fP \fBIP\fP"
.br
.ti -1c
.RI "sockaddr_in \fBclient\fP"
.br
.ti -1c
.RI "sockaddr_in \fBserver\fP"
.br
.ti -1c
.RI "socklen_t \fBlength\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line 30 of file socket.h.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "InspSocket::InspSocket ()"
.PP
Definition at line 46 of file socket.cpp.
.PP
References I_DISCONNECTED, and state.
.PP
.nf
47 {
48         this->state = I_DISCONNECTED;
49 }
.fi
.PP
.SS "InspSocket::InspSocket (int newfd, char * ip)"
.PP
Definition at line 51 of file socket.cpp.
.PP
References fd, I_CONNECTED, IP, and state.
.PP
.nf
52 {
53         this->fd = newfd;
54         this->state = I_CONNECTED;
55         this->IP = ip;
56 }
.fi
.PP
.SS "InspSocket::InspSocket (\fBstd::string\fP host, int port, bool listening, unsigned long maxtime)"
.PP
Definition at line 58 of file socket.cpp.
.PP
References addr, addy, Close(), DEBUG, fd, I_CONNECTING, I_ERR_BIND, I_ERR_CONNECT, I_ERR_SOCKET, I_ERROR, I_LISTENING, IP, OnError(), state, timeout, and timeout_end.
.PP
.nf
59 {
60         if (listening) {
61                 if ((this->fd = OpenTCPSocket()) == ERROR)
62                 {
63                         this->fd = -1;
64                         this->state = I_ERROR;
65                         this->OnError(I_ERR_SOCKET);
66                         log(DEBUG,'OpenTCPSocket() error');
67                         return;
68                 }
69                 else
70                 {
71                         if (BindSocket(this->fd,this->client,this->server,port,(char*)host.c_str()) == ERROR)
72                         {
73                                 this->Close();
74                                 this->fd = -1;
75                                 this->state = I_ERROR;
76                                 this->OnError(I_ERR_BIND);
77                                 log(DEBUG,'BindSocket() error %s',strerror(errno));
78                                 return;
79                         }
80                         else
81                         {
82                                 this->state = I_LISTENING;
83                                 log(DEBUG,'New socket now in I_LISTENING state');
84                                 return;
85                         }
86                 }                       
87         } else {
88                 char* ip;
89                 this->host = host;
90                 hostent* hoste = gethostbyname(host.c_str());
91                 if (!hoste) {
92                         ip = (char*)host.c_str();
93                 } else {
94                         struct in_addr* ia = (in_addr*)hoste->h_addr;
95                         ip = inet_ntoa(*ia);
96                 }
97 
98                 this->IP = ip;
99 
100                 timeout_end = time(NULL)+maxtime;
101                 timeout = false;
102                 if ((this->fd = socket(AF_INET, SOCK_STREAM, 0)) == -1)
103                 {
104                         this->state = I_ERROR;
105                         this->OnError(I_ERR_SOCKET);
106                         return;
107                 }
108                 this->port = port;
109                 inet_aton(ip,&addy);
110                 addr.sin_family = AF_INET;
111                 addr.sin_addr = addy;
112                 addr.sin_port = htons(this->port);
113 
114                 int flags;
115                 flags = fcntl(this->fd, F_GETFL, 0);
116                 fcntl(this->fd, F_SETFL, flags | O_NONBLOCK);
117 
118                 if(connect(this->fd, (sockaddr*)&this->addr,sizeof(this->addr)) == -1)
119                 {
120                         if (errno != EINPROGRESS)
121                         {
122                                 this->Close();
123                                 this->OnError(I_ERR_CONNECT);
124                                 this->state = I_ERROR;
125                                 return;
126                         }
127                 }
128                 this->state = I_CONNECTING;
129                 return;
130         }
131 }
.fi
.PP
.SS "InspSocket::~InspSocket ()\fC [virtual]\fP"
.PP
Definition at line 254 of file socket.cpp.
.PP
References Close().
.PP
.nf
255 {
256         this->Close();
257 }
.fi
.PP
.SH "Member Function Documentation"
.PP 
.SS "void InspSocket::Close ()\fC [virtual]\fP"
.PP
Definition at line 133 of file socket.cpp.
.PP
References fd, and OnClose().
.PP
Referenced by InspSocket(), and ~InspSocket().
.PP
.nf
134 {
135         if (this->fd != -1)
136         {
137                 this->OnClose();
138                 shutdown(this->fd,2);
139                 close(this->fd);
140                 this->fd = -1;
141         }
142 }
.fi
.PP
.SS "\fBstd::string\fP InspSocket::GetIP ()"
.PP
Definition at line 144 of file socket.cpp.
.PP
References IP.
.PP
.nf
145 {
146         return this->IP;
147 }
.fi
.PP
.SS "\fBInspSocketState\fP InspSocket::GetState ()"
.PP
Definition at line 241 of file socket.cpp.
.PP
References state.
.PP
.nf
242 {
243         return this->state;
244 }
.fi
.PP
.SS "void InspSocket::OnClose ()\fC [virtual]\fP"
.PP
Definition at line 252 of file socket.cpp.
.PP
Referenced by Close().
.PP
.nf
252 { return; }
.fi
.PP
.SS "bool InspSocket::OnConnected ()\fC [virtual]\fP"
.PP
Definition at line 246 of file socket.cpp.
.PP
Referenced by Poll().
.PP
.nf
246 { return true; }
.fi
.PP
.SS "bool InspSocket::OnDataReady ()\fC [virtual]\fP"
.PP
Definition at line 250 of file socket.cpp.
.PP
Referenced by Poll().
.PP
.nf
250 { return true; }
.fi
.PP
.SS "int InspSocket::OnDisconnect ()\fC [virtual]\fP"
.PP
Definition at line 248 of file socket.cpp.
.PP
.nf
248 { return 0; }
.fi
.PP
.SS "void InspSocket::OnError (\fBInspSocketError\fP e)\fC [virtual]\fP"
.PP
Definition at line 247 of file socket.cpp.
.PP
Referenced by InspSocket(), and Poll().
.PP
.nf
247 { return; }
.fi
.PP
.SS "int InspSocket::OnIncomingConnection (int newfd, char * ip)\fC [virtual]\fP"
.PP
Definition at line 249 of file socket.cpp.
.PP
Referenced by Poll().
.PP
.nf
249 { return 0; }
.fi
.PP
.SS "void InspSocket::OnTimeout ()\fC [virtual]\fP"
.PP
Definition at line 251 of file socket.cpp.
.PP
Referenced by Poll().
.PP
.nf
251 { return; }
.fi
.PP
.SS "bool InspSocket::Poll ()"
.PP
Definition at line 191 of file socket.cpp.
.PP
References client, fd, I_CONNECTED, I_CONNECTING, I_ERR_TIMEOUT, I_ERROR, I_LISTENING, length, OnConnected(), OnDataReady(), OnError(), OnIncomingConnection(), OnTimeout(), polls, SetState(), state, timeout, and timeout_end.
.PP
.nf
192 {
193         if ((time(NULL) > timeout_end) && (this->state == I_CONNECTING))
194         {
195                 // for non-listening sockets, the timeout can occur
196                 // which causes termination of the connection after
197                 // the given number of seconds without a successful
198                 // connection.
199                 this->OnTimeout();
200                 this->OnError(I_ERR_TIMEOUT);
201                 timeout = true;
202                 this->state = I_ERROR;
203                 return false;
204         }
205         polls.fd = this->fd;
206         state == I_CONNECTING ? polls.events = POLLOUT : polls.events = POLLIN;
207         int ret = poll(&polls,1,1);
208 
209         if (ret > 0)
210         {
211                 int incoming = -1;
212                 
213                 switch (this->state)
214                 {
215                         case I_CONNECTING:
216                                 this->SetState(I_CONNECTED);
217                                 return this->OnConnected();
218                         break;
219                         case I_LISTENING:
220                                 length = sizeof (client);
221                                 incoming = accept (this->fd, (sockaddr*)&client,&length);
222                                 this->OnIncomingConnection(incoming,inet_ntoa(client.sin_addr));
223                                 return true;
224                         break;
225                         case I_CONNECTED:
226                                 return this->OnDataReady();
227                         break;
228                         default:
229                         break;
230                 }
231         }
232         return true;
233 }
.fi
.PP
.SS "char * InspSocket::Read ()\fC [virtual]\fP"
.PP
Definition at line 149 of file socket.cpp.
.PP
References DEBUG, and ibuf.
.PP
.nf
150 {
151         int n = recv(this->fd,this->ibuf,sizeof(this->ibuf),0);
152         if (n > 0)
153         {
154                 ibuf[n] = 0;
155                 return ibuf;
156         }
157         else
158         {
159                 log(DEBUG,'EOF or error on socket');
160                 return NULL;
161         }
162 }
.fi
.PP
.SS "void InspSocket::SetState (\fBInspSocketState\fP s)"
.PP
Definition at line 235 of file socket.cpp.
.PP
References DEBUG, and state.
.PP
Referenced by Poll().
.PP
.nf
236 {
237         log(DEBUG,'Socket state change');
238         this->state = s;
239 }
.fi
.PP
.SS "int InspSocket::Write (\fBstd::string\fP data)\fC [virtual]\fP"
.PP
Definition at line 168 of file socket.cpp.
.PP
.nf
169 {
170         char* d = (char*)data.c_str();
171         unsigned int written = 0;
172         int n = 0;
173         int s = data.length();
174         while ((written < data.length()) && (n >= 0))
175         {
176                 n = send(this->fd,d,s,0);
177                 if (n > 0)
178                 {
179                         // If we didnt write everything, advance
180                         // the pointers so that when we retry
181                         // the next time around the loop, we try
182                         // to write what we failed to write before.
183                         written += n;
184                         s -= n;
185                         d += n;
186                 }
187         }
188         return written;
189 }
.fi
.PP
.SH "Member Data Documentation"
.PP 
.SS "sockaddr_in \fBInspSocket::addr\fP\fC [private]\fP"
.PP
Definition at line 37 of file socket.h.
.PP
Referenced by InspSocket().
.SS "in_addr \fBInspSocket::addy\fP\fC [private]\fP"
.PP
Definition at line 38 of file socket.h.
.PP
Referenced by InspSocket().
.SS "sockaddr_in \fBInspSocket::client\fP\fC [private]\fP"
.PP
Definition at line 44 of file socket.h.
.PP
Referenced by Poll().
.SS "int \fBInspSocket::fd\fP\fC [private]\fP"
.PP
Definition at line 33 of file socket.h.
.PP
Referenced by Close(), InspSocket(), and Poll().
.SS "\fBstd::string\fP \fBInspSocket::host\fP\fC [private]\fP"
.PP
Definition at line 34 of file socket.h.
.SS "char \fBInspSocket::ibuf\fP[16384]\fC [private]\fP"
.PP
Definition at line 42 of file socket.h.
.PP
Referenced by Read().
.SS "\fBstd::string\fP \fBInspSocket::IP\fP\fC [private]\fP"
.PP
Definition at line 43 of file socket.h.
.PP
Referenced by GetIP(), and InspSocket().
.SS "socklen_t \fBInspSocket::length\fP\fC [private]\fP"
.PP
Definition at line 46 of file socket.h.
.PP
Referenced by Poll().
.SS "pollfd \fBInspSocket::polls\fP\fC [private]\fP"
.PP
Definition at line 41 of file socket.h.
.PP
Referenced by Poll().
.SS "int \fBInspSocket::port\fP\fC [private]\fP"
.PP
Definition at line 35 of file socket.h.
.SS "sockaddr_in \fBInspSocket::server\fP\fC [private]\fP"
.PP
Definition at line 45 of file socket.h.
.SS "\fBInspSocketState\fP \fBInspSocket::state\fP\fC [private]\fP"
.PP
Definition at line 36 of file socket.h.
.PP
Referenced by GetState(), InspSocket(), Poll(), and SetState().
.SS "bool \fBInspSocket::timeout\fP\fC [private]\fP"
.PP
Definition at line 40 of file socket.h.
.PP
Referenced by InspSocket(), and Poll().
.SS "time_t \fBInspSocket::timeout_end\fP\fC [private]\fP"
.PP
Definition at line 39 of file socket.h.
.PP
Referenced by InspSocket(), and Poll().

.SH "Author"
.PP 
Generated automatically by Doxygen for InspIRCd from the source code.
