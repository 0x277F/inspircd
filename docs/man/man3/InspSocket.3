.TH "InspSocket" 3 "14 Dec 2005" "Version 1.0Betareleases" "InspIRCd" \" -*- nroff -*-
.ad l
.nh
.SH NAME
InspSocket \- InspSocket is an extendable socket class which modules can use for TCP socket support.  

.PP
.SH SYNOPSIS
.br
.PP
\fC#include <socket.h>\fP
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBInspSocket\fP ()"
.br
.RI "\fIThe default constructor does nothing and should not be used. \fP"
.ti -1c
.RI "\fBInspSocket\fP (int newfd, char *ip)"
.br
.RI "\fIThis constructor is used to associate an existing connecting with an InspSocket class. \fP"
.ti -1c
.RI "\fBInspSocket\fP (\fBstd::string\fP \fBhost\fP, int \fBport\fP, bool listening, unsigned long maxtime)"
.br
.RI "\fIThis constructor is used to create a new socket, either listening for connections, or an outbound connection to another host. \fP"
.ti -1c
.RI "virtual bool \fBOnConnected\fP ()"
.br
.RI "\fIThis method is called when an outbound connection on your socket is completed. \fP"
.ti -1c
.RI "virtual void \fBOnError\fP (\fBInspSocketError\fP e)"
.br
.RI "\fIThis method is called when an error occurs. \fP"
.ti -1c
.RI "virtual int \fBOnDisconnect\fP ()"
.br
.RI "\fIWhen an established connection is terminated, the OnDisconnect method is triggered. \fP"
.ti -1c
.RI "virtual bool \fBOnDataReady\fP ()"
.br
.RI "\fIWhen there is data waiting to be read on a socket, the \fBOnDataReady()\fP method is called. \fP"
.ti -1c
.RI "virtual void \fBOnTimeout\fP ()"
.br
.RI "\fIWhen an outbound connection fails, and the attempt times out, you will receive this event. \fP"
.ti -1c
.RI "virtual void \fBOnClose\fP ()"
.br
.RI "\fIWhenever close() is called, \fBOnClose()\fP will be called first. \fP"
.ti -1c
.RI "virtual char * \fBRead\fP ()"
.br
.RI "\fIReads all pending bytes from the socket into a char* array which can be up to 16 kilobytes in length. \fP"
.ti -1c
.RI "\fBstd::string\fP \fBGetIP\fP ()"
.br
.RI "\fIReturns the IP address associated with this connection, or an empty string if no IP address exists. \fP"
.ti -1c
.RI "bool \fBTimeout\fP (time_t current)"
.br
.RI "\fIThis function checks if the socket has timed out yet, given the current time in the parameter. \fP"
.ti -1c
.RI "virtual int \fBWrite\fP (\fBstd::string\fP data)"
.br
.RI "\fIWrites a \fBstd::string\fP to the socket. \fP"
.ti -1c
.RI "virtual int \fBOnIncomingConnection\fP (int newfd, char *ip)"
.br
.RI "\fIIf your socket is a listening socket, when a new connection comes in on the socket this method will be called. \fP"
.ti -1c
.RI "void \fBSetState\fP (\fBInspSocketState\fP s)"
.br
.RI "\fIChanges the socket's state. \fP"
.ti -1c
.RI "\fBInspSocketState\fP \fBGetState\fP ()"
.br
.RI "\fIReturns the current socket state. \fP"
.ti -1c
.RI "bool \fBPoll\fP ()"
.br
.RI "\fIOnly the core should call this function. \fP"
.ti -1c
.RI "int \fBGetFd\fP ()"
.br
.RI "\fIThis method returns the socket's file descriptor as assigned by the operating system, or -1 if no descriptor has been assigned. \fP"
.ti -1c
.RI "virtual void \fBClose\fP ()"
.br
.RI "\fIThis method causes the socket to close, and may also be triggered by other methods such as OnTimeout and OnError. \fP"
.ti -1c
.RI "virtual \fB~InspSocket\fP ()"
.br
.RI "\fIThe destructor may implicitly call \fBOnClose()\fP, and will close() and shutdown() the file descriptor used for this socket. \fP"
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "int \fBfd\fP"
.br
.RI "\fIThe file descriptor of this socket. \fP"
.ti -1c
.RI "\fBstd::string\fP \fBhost\fP"
.br
.RI "\fIThe hostname connected to. \fP"
.ti -1c
.RI "int \fBport\fP"
.br
.RI "\fIThe port connected to, or the port this socket is listening on. \fP"
.ti -1c
.RI "\fBInspSocketState\fP \fBstate\fP"
.br
.RI "\fIThe state for this socket, either listening, connecting, connected or error. \fP"
.ti -1c
.RI "sockaddr_in \fBaddr\fP"
.br
.RI "\fIThe host being connected to, in sockaddr form. \fP"
.ti -1c
.RI "in_addr \fBaddy\fP"
.br
.RI "\fIThe host being connected to, in in_addr form. \fP"
.ti -1c
.RI "time_t \fBtimeout_end\fP"
.br
.RI "\fIWhen this time is reached, the socket times out if it is in the CONNECTING state. \fP"
.ti -1c
.RI "bool \fBtimeout\fP"
.br
.RI "\fIThis value is true if the socket has timed out. \fP"
.ti -1c
.RI "char \fBibuf\fP [16384]"
.br
.RI "\fISocket input buffer, used by read(). \fP"
.ti -1c
.RI "\fBstd::string\fP \fBIP\fP"
.br
.RI "\fIThe IP address being connected to stored in string form for easy retrieval by accessors. \fP"
.ti -1c
.RI "sockaddr_in \fBclient\fP"
.br
.RI "\fIClient sockaddr structure used by accept(). \fP"
.ti -1c
.RI "sockaddr_in \fBserver\fP"
.br
.RI "\fI\fBServer\fP sockaddr structure used by accept(). \fP"
.ti -1c
.RI "socklen_t \fBlength\fP"
.br
.RI "\fIUsed by accept() to indicate the sizes of the sockaddr_in structures. \fP"
.in -1c
.SH "Detailed Description"
.PP 
InspSocket is an extendable socket class which modules can use for TCP socket support. 

It is fully integrated into InspIRCds socket loop and attaches its sockets to the core's instance of the \fBSocketEngine\fP class, meaning that any sockets you create have the same power and abilities as a socket created by the core itself. To use InspSocket, you must inherit a class from it, and use the InspSocket constructors to establish connections and bindings.
.PP
Definition at line 47 of file socket.h.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "InspSocket::InspSocket ()"
.PP
The default constructor does nothing and should not be used. 
.PP
Definition at line 48 of file socket.cpp.
.PP
References I_DISCONNECTED, and state.
.PP
.nf
49 {
50         this->state = I_DISCONNECTED;
51 }
.fi
.PP
.SS "InspSocket::InspSocket (int newfd, char * ip)"
.PP
This constructor is used to associate an existing connecting with an InspSocket class. 
.PP
The given file descriptor must be valid, and when initialized, the InspSocket will be set with the given IP address and placed in CONNECTED state.
.PP
Definition at line 53 of file socket.cpp.
.PP
References SocketEngine::AddFd(), fd, I_CONNECTED, IP, state, and X_ESTAB_MODULE.
.PP
.nf
54 {
55         this->fd = newfd;
56         this->state = I_CONNECTED;
57         this->IP = ip;
58         SE->AddFd(this->fd,true,X_ESTAB_MODULE);
59         socket_ref[this->fd] = this;
60 }
.fi
.PP
.SS "InspSocket::InspSocket (\fBstd::string\fP host, int port, bool listening, unsigned long maxtime)"
.PP
This constructor is used to create a new socket, either listening for connections, or an outbound connection to another host. 
.PP
\fBParameters:\fP
.RS 4
\fIhost\fP The hostname to connect to, or bind to 
.br
\fIport\fP The port number to connect to, or bind to 
.br
\fIlistening\fP true to listen on the given host:port pair, or false to connect to them 
.br
\fImaxtime\fP Number of seconds to wait, if connecting, before the connection times out and an \fBOnTimeout()\fP event is generated
.RE
.PP

.PP
Definition at line 62 of file socket.cpp.
.PP
References SocketEngine::AddFd(), addr, addy, BindSocket(), Close(), DEBUG, ERROR, fd, I_CONNECTING, I_ERR_BIND, I_ERR_CONNECT, I_ERR_SOCKET, I_ERROR, I_LISTENING, IP, log(), OnError(), OpenTCPSocket(), state, timeout, timeout_end, and X_ESTAB_MODULE.
.PP
.nf
63 {
64         if (listening) {
65                 if ((this->fd = OpenTCPSocket()) == ERROR)
66                 {
67                         this->fd = -1;
68                         this->state = I_ERROR;
69                         this->OnError(I_ERR_SOCKET);
70                         log(DEBUG,'OpenTCPSocket() error');
71                         return;
72                 }
73                 else
74                 {
75                         if (BindSocket(this->fd,this->client,this->server,port,(char*)host.c_str()) == ERROR)
76                         {
77                                 this->Close();
78                                 this->fd = -1;
79                                 this->state = I_ERROR;
80                                 this->OnError(I_ERR_BIND);
81                                 log(DEBUG,'BindSocket() error %s',strerror(errno));
82                                 return;
83                         }
84                         else
85                         {
86                                 this->state = I_LISTENING;
87                                 SE->AddFd(this->fd,true,X_ESTAB_MODULE);
88                                 socket_ref[this->fd] = this;
89                                 log(DEBUG,'New socket now in I_LISTENING state');
90                                 return;
91                         }
92                 }                       
93         } else {
94                 char* ip;
95                 this->host = host;
96                 hostent* hoste = gethostbyname(host.c_str());
97                 if (!hoste) {
98                         ip = (char*)host.c_str();
99                 } else {
100                         struct in_addr* ia = (in_addr*)hoste->h_addr;
101                         ip = inet_ntoa(*ia);
102                 }
103 
104                 this->IP = ip;
105 
106                 timeout_end = time(NULL)+maxtime;
107                 timeout = false;
108                 if ((this->fd = socket(AF_INET, SOCK_STREAM, 0)) == -1)
109                 {
110                         this->state = I_ERROR;
111                         this->OnError(I_ERR_SOCKET);
112                         return;
113                 }
114                 this->port = port;
115                 inet_aton(ip,&addy);
116                 addr.sin_family = AF_INET;
117                 addr.sin_addr = addy;
118                 addr.sin_port = htons(this->port);
119 
120                 int flags;
121                 flags = fcntl(this->fd, F_GETFL, 0);
122                 fcntl(this->fd, F_SETFL, flags | O_NONBLOCK);
123 
124                 if(connect(this->fd, (sockaddr*)&this->addr,sizeof(this->addr)) == -1)
125                 {
126                         if (errno != EINPROGRESS)
127                         {
128                                 this->Close();
129                                 this->OnError(I_ERR_CONNECT);
130                                 this->state = I_ERROR;
131                                 return;
132                         }
133                 }
134                 this->state = I_CONNECTING;
135                 SE->AddFd(this->fd,false,X_ESTAB_MODULE);
136                 socket_ref[this->fd] = this;
137                 return;
138         }
139 }
.fi
.PP
.SS "InspSocket::~InspSocket ()\fC [virtual]\fP"
.PP
The destructor may implicitly call \fBOnClose()\fP, and will close() and shutdown() the file descriptor used for this socket. 
.PP
Definition at line 272 of file socket.cpp.
.PP
References Close().
.PP
.nf
273 {
274         this->Close();
275 }
.fi
.PP
.SH "Member Function Documentation"
.PP 
.SS "void InspSocket::Close ()\fC [virtual]\fP"
.PP
This method causes the socket to close, and may also be triggered by other methods such as OnTimeout and OnError. 
.PP
Definition at line 141 of file socket.cpp.
.PP
References fd, and OnClose().
.PP
Referenced by InspSocket(), and ~InspSocket().
.PP
.nf
142 {
143         if (this->fd != -1)
144         {
145                 this->OnClose();
146                 shutdown(this->fd,2);
147                 close(this->fd);
148                 socket_ref[this->fd] = NULL;
149                 this->fd = -1;
150         }
151 }
.fi
.PP
.SS "int InspSocket::GetFd ()"
.PP
This method returns the socket's file descriptor as assigned by the operating system, or -1 if no descriptor has been assigned. 
.PP
Definition at line 259 of file socket.cpp.
.PP
References fd.
.PP
.nf
260 {
261         return this->fd;
262 }
.fi
.PP
.SS "\fBstd::string\fP InspSocket::GetIP ()"
.PP
Returns the IP address associated with this connection, or an empty string if no IP address exists. 
.PP
Definition at line 153 of file socket.cpp.
.PP
References IP.
.PP
.nf
154 {
155         return this->IP;
156 }
.fi
.PP
.SS "\fBInspSocketState\fP InspSocket::GetState ()"
.PP
Returns the current socket state. 
.PP
Definition at line 254 of file socket.cpp.
.PP
References state.
.PP
.nf
255 {
256         return this->state;
257 }
.fi
.PP
.SS "void InspSocket::OnClose ()\fC [virtual]\fP"
.PP
Whenever close() is called, \fBOnClose()\fP will be called first. 
.PP
Please note that this means OnClose will be called alongside \fBOnError()\fP, \fBOnTimeout()\fP, and \fBClose()\fP, and also when cancelling a listening socket by calling the destructor indirectly.
.PP
Definition at line 270 of file socket.cpp.
.PP
Referenced by Close().
.PP
.nf
270 { return; }
.fi
.PP
.SS "bool InspSocket::OnConnected ()\fC [virtual]\fP"
.PP
This method is called when an outbound connection on your socket is completed. 
.PP
\fBReturns:\fP
.RS 4
false to abort the connection, true to continue
.RE
.PP

.PP
Definition at line 264 of file socket.cpp.
.PP
Referenced by Poll().
.PP
.nf
264 { return true; }
.fi
.PP
.SS "bool InspSocket::OnDataReady ()\fC [virtual]\fP"
.PP
When there is data waiting to be read on a socket, the \fBOnDataReady()\fP method is called. 
.PP
Within this method, you *MUST* call the \fBRead()\fP method to read any pending data. At its lowest level, this event is signalled by the core via the socket engine. If you return false from this function, the core removes your socket from its list and erases it from the socket engine, then calls \fBInspSocket::Close()\fP and deletes it. 
.PP
\fBReturns:\fP
.RS 4
false to close the socket
.RE
.PP

.PP
Definition at line 268 of file socket.cpp.
.PP
Referenced by Poll().
.PP
.nf
268 { return true; }
.fi
.PP
.SS "int InspSocket::OnDisconnect ()\fC [virtual]\fP"
.PP
When an established connection is terminated, the OnDisconnect method is triggered. 
.PP
Definition at line 266 of file socket.cpp.
.PP
.nf
266 { return 0; }
.fi
.PP
.SS "void InspSocket::OnError (\fBInspSocketError\fP e)\fC [virtual]\fP"
.PP
This method is called when an error occurs. 
.PP
A closed socket in itself is not an error, however errors also generate close events. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The error type which occured
.RE
.PP

.PP
Definition at line 265 of file socket.cpp.
.PP
Referenced by InspSocket(), and Timeout().
.PP
.nf
265 { return; }
.fi
.PP
.SS "int InspSocket::OnIncomingConnection (int newfd, char * ip)\fC [virtual]\fP"
.PP
If your socket is a listening socket, when a new connection comes in on the socket this method will be called. 
.PP
Given the new file descriptor in the parameters, and the IP, it is recommended you copy them to a new instance of your socket class, e.g.:
.PP
MySocket* newsocket = new MySocket(newfd,ip);
.PP
Once you have done this, you can then associate the new socket with the core using \fBServer::AddSocket()\fP.
.PP
Definition at line 267 of file socket.cpp.
.PP
Referenced by Poll().
.PP
.nf
267 { return 0; }
.fi
.PP
.SS "void InspSocket::OnTimeout ()\fC [virtual]\fP"
.PP
When an outbound connection fails, and the attempt times out, you will receive this event. 
.PP
The mthod will trigger once maxtime secons are reached (as given in the constructor) just before the socket's descriptor is closed.
.PP
Definition at line 269 of file socket.cpp.
.PP
Referenced by Timeout().
.PP
.nf
269 { return; }
.fi
.PP
.SS "bool InspSocket::Poll ()"
.PP
Only the core should call this function. 
.PP
When called, it is assumed the socket is ready to read data, and the method call routes the event to the various methods of InspSocket for you to handle. This can also cause the socket's state to change.
.PP
Definition at line 217 of file socket.cpp.
.PP
References SocketEngine::AddFd(), client, SocketEngine::DelFd(), I_CONNECTED, I_CONNECTING, I_LISTENING, length, OnConnected(), OnDataReady(), OnIncomingConnection(), SetState(), and X_ESTAB_MODULE.
.PP
.nf
218 {
219         int incoming = -1;
220         
221         switch (this->state)
222         {
223                 case I_CONNECTING:
224                         this->SetState(I_CONNECTED);
225                         /* Our socket was in write-state, so delete it and re-add it
226                          * in read-state.
227                          */
228                         SE->DelFd(this->fd);
229                         SE->AddFd(this->fd,true,X_ESTAB_MODULE);
230                         return this->OnConnected();
231                 break;
232                 case I_LISTENING:
233                         length = sizeof (client);
234                         incoming = accept (this->fd, (sockaddr*)&client,&length);
235                         this->OnIncomingConnection(incoming,inet_ntoa(client.sin_addr));
236                         return true;
237                 break;
238                 case I_CONNECTED:
239                         return this->OnDataReady();
240                 break;
241                 default:
242                 break;
243         }
244 
245         return true;
246 }
.fi
.PP
.SS "char * InspSocket::Read ()\fC [virtual]\fP"
.PP
Reads all pending bytes from the socket into a char* array which can be up to 16 kilobytes in length. 
.PP
Definition at line 158 of file socket.cpp.
.PP
References DEBUG, ibuf, and log().
.PP
.nf
159 {
160         int n = recv(this->fd,this->ibuf,sizeof(this->ibuf),0);
161         if (n > 0)
162         {
163                 ibuf[n] = 0;
164                 return ibuf;
165         }
166         else
167         {
168                 log(DEBUG,'EOF or error on socket');
169                 return NULL;
170         }
171 }
.fi
.PP
.SS "void InspSocket::SetState (\fBInspSocketState\fP s)"
.PP
Changes the socket's state. 
.PP
The core uses this to change socket states, and you should not call it directly.
.PP
Definition at line 248 of file socket.cpp.
.PP
References DEBUG, log(), and state.
.PP
Referenced by Poll().
.PP
.nf
249 {
250         log(DEBUG,'Socket state change');
251         this->state = s;
252 }
.fi
.PP
.SS "bool InspSocket::Timeout (time_t current)"
.PP
This function checks if the socket has timed out yet, given the current time in the parameter. 
.PP
\fBReturns:\fP
.RS 4
true if timed out, false if not timed out
.RE
.PP

.PP
Definition at line 200 of file socket.cpp.
.PP
References I_CONNECTING, I_ERR_TIMEOUT, I_ERROR, OnError(), OnTimeout(), state, timeout, and timeout_end.
.PP
.nf
201 {
202         if ((this->state == I_CONNECTING) && (current > timeout_end))
203         {
204                 // for non-listening sockets, the timeout can occur
205                 // which causes termination of the connection after
206                 // the given number of seconds without a successful
207                 // connection.
208                 this->OnTimeout();
209                 this->OnError(I_ERR_TIMEOUT);
210                 timeout = true;
211                 this->state = I_ERROR;
212                 return true;
213         }
214         return false;
215 }
.fi
.PP
.SS "int InspSocket::Write (\fBstd::string\fP data)\fC [virtual]\fP"
.PP
Writes a \fBstd::string\fP to the socket. 
.PP
No carriage returns or linefeeds are appended to the string. 
.PP
\fBParameters:\fP
.RS 4
\fIdata\fP The data to send
.RE
.PP

.PP
Definition at line 177 of file socket.cpp.
.PP
.nf
178 {
179         char* d = (char*)data.c_str();
180         unsigned int written = 0;
181         int n = 0;
182         int s = data.length();
183         while ((written < data.length()) && (n >= 0))
184         {
185                 n = send(this->fd,d,s,0);
186                 if (n > 0)
187                 {
188                         // If we didnt write everything, advance
189                         // the pointers so that when we retry
190                         // the next time around the loop, we try
191                         // to write what we failed to write before.
192                         written += n;
193                         s -= n;
194                         d += n;
195                 }
196         }
197         return written;
198 }
.fi
.PP
.SH "Member Data Documentation"
.PP 
.SS "sockaddr_in \fBInspSocket::addr\fP\fC [private]\fP"
.PP
The host being connected to, in sockaddr form. 
.PP
Definition at line 78 of file socket.h.
.PP
Referenced by InspSocket().
.SS "in_addr \fBInspSocket::addy\fP\fC [private]\fP"
.PP
The host being connected to, in in_addr form. 
.PP
Definition at line 84 of file socket.h.
.PP
Referenced by InspSocket().
.SS "sockaddr_in \fBInspSocket::client\fP\fC [private]\fP"
.PP
Client sockaddr structure used by accept(). 
.PP
Definition at line 119 of file socket.h.
.PP
Referenced by Poll().
.SS "int \fBInspSocket::fd\fP\fC [private]\fP"
.PP
The file descriptor of this socket. 
.PP
Definition at line 54 of file socket.h.
.PP
Referenced by Close(), GetFd(), and InspSocket().
.SS "\fBstd::string\fP \fBInspSocket::host\fP\fC [private]\fP"
.PP
The hostname connected to. 
.PP
Definition at line 59 of file socket.h.
.SS "char \fBInspSocket::ibuf\fP[16384]\fC [private]\fP"
.PP
Socket input buffer, used by read(). 
.PP
The class which extends InspSocket is expected to implement an extendable buffer which can grow much larger than 16k, this buffer is just designed to be temporary storage. space.
.PP
Definition at line 106 of file socket.h.
.PP
Referenced by Read().
.SS "\fBstd::string\fP \fBInspSocket::IP\fP\fC [private]\fP"
.PP
The IP address being connected to stored in string form for easy retrieval by accessors. 
.PP
Definition at line 113 of file socket.h.
.PP
Referenced by GetIP(), and InspSocket().
.SS "socklen_t \fBInspSocket::length\fP\fC [private]\fP"
.PP
Used by accept() to indicate the sizes of the sockaddr_in structures. 
.PP
Definition at line 131 of file socket.h.
.PP
Referenced by Poll().
.SS "int \fBInspSocket::port\fP\fC [private]\fP"
.PP
The port connected to, or the port this socket is listening on. 
.PP
Definition at line 65 of file socket.h.
.SS "sockaddr_in \fBInspSocket::server\fP\fC [private]\fP"
.PP
\fBServer\fP sockaddr structure used by accept(). 
.PP
Definition at line 125 of file socket.h.
.SS "\fBInspSocketState\fP \fBInspSocket::state\fP\fC [private]\fP"
.PP
The state for this socket, either listening, connecting, connected or error. 
.PP
Definition at line 72 of file socket.h.
.PP
Referenced by GetState(), InspSocket(), SetState(), and Timeout().
.SS "bool \fBInspSocket::timeout\fP\fC [private]\fP"
.PP
This value is true if the socket has timed out. 
.PP
Definition at line 97 of file socket.h.
.PP
Referenced by InspSocket(), and Timeout().
.SS "time_t \fBInspSocket::timeout_end\fP\fC [private]\fP"
.PP
When this time is reached, the socket times out if it is in the CONNECTING state. 
.PP
Definition at line 91 of file socket.h.
.PP
Referenced by InspSocket(), and Timeout().

.SH "Author"
.PP 
Generated automatically by Doxygen for InspIRCd from the source code.
