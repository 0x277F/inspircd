.TH "InspSocket" 3 "12 Dec 2005" "Version 1.0Betareleases" "InspIRCd" \" -*- nroff -*-
.ad l
.nh
.SH NAME
InspSocket \- 
.SH SYNOPSIS
.br
.PP
\fC#include <socket.h>\fP
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBInspSocket\fP ()"
.br
.ti -1c
.RI "\fBInspSocket\fP (int newfd, char *ip)"
.br
.ti -1c
.RI "\fBInspSocket\fP (\fBstd::string\fP \fBhost\fP, int \fBport\fP, bool listening, unsigned long maxtime)"
.br
.ti -1c
.RI "virtual bool \fBOnConnected\fP ()"
.br
.ti -1c
.RI "virtual void \fBOnError\fP (\fBInspSocketError\fP e)"
.br
.ti -1c
.RI "virtual int \fBOnDisconnect\fP ()"
.br
.ti -1c
.RI "virtual bool \fBOnDataReady\fP ()"
.br
.ti -1c
.RI "virtual void \fBOnTimeout\fP ()"
.br
.ti -1c
.RI "virtual void \fBOnClose\fP ()"
.br
.ti -1c
.RI "virtual char * \fBRead\fP ()"
.br
.ti -1c
.RI "\fBstd::string\fP \fBGetIP\fP ()"
.br
.ti -1c
.RI "virtual int \fBWrite\fP (\fBstd::string\fP data)"
.br
.ti -1c
.RI "virtual int \fBOnIncomingConnection\fP (int newfd, char *ip)"
.br
.ti -1c
.RI "void \fBSetState\fP (\fBInspSocketState\fP s)"
.br
.ti -1c
.RI "\fBInspSocketState\fP \fBGetState\fP ()"
.br
.ti -1c
.RI "bool \fBPoll\fP ()"
.br
.ti -1c
.RI "int \fBGetFd\fP ()"
.br
.ti -1c
.RI "virtual void \fBClose\fP ()"
.br
.ti -1c
.RI "virtual \fB~InspSocket\fP ()"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "int \fBfd\fP"
.br
.ti -1c
.RI "\fBstd::string\fP \fBhost\fP"
.br
.ti -1c
.RI "int \fBport\fP"
.br
.ti -1c
.RI "\fBInspSocketState\fP \fBstate\fP"
.br
.ti -1c
.RI "sockaddr_in \fBaddr\fP"
.br
.ti -1c
.RI "in_addr \fBaddy\fP"
.br
.ti -1c
.RI "time_t \fBtimeout_end\fP"
.br
.ti -1c
.RI "bool \fBtimeout\fP"
.br
.ti -1c
.RI "pollfd \fBpolls\fP"
.br
.ti -1c
.RI "char \fBibuf\fP [16384]"
.br
.ti -1c
.RI "\fBstd::string\fP \fBIP\fP"
.br
.ti -1c
.RI "sockaddr_in \fBclient\fP"
.br
.ti -1c
.RI "sockaddr_in \fBserver\fP"
.br
.ti -1c
.RI "socklen_t \fBlength\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line 30 of file socket.h.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "InspSocket::InspSocket ()"
.PP
Definition at line 49 of file socket.cpp.
.PP
References I_DISCONNECTED, and state.
.PP
.nf
50 {
51         this->state = I_DISCONNECTED;
52 }
.fi
.PP
.SS "InspSocket::InspSocket (int newfd, char * ip)"
.PP
Definition at line 54 of file socket.cpp.
.PP
References SocketEngine::AddFd(), fd, I_CONNECTED, IP, state, and X_ESTAB_MODULE.
.PP
.nf
55 {
56         this->fd = newfd;
57         this->state = I_CONNECTED;
58         this->IP = ip;
59         SE->AddFd(this->fd,true,X_ESTAB_MODULE);
60 }
.fi
.PP
.SS "InspSocket::InspSocket (\fBstd::string\fP host, int port, bool listening, unsigned long maxtime)"
.PP
Definition at line 62 of file socket.cpp.
.PP
References SocketEngine::AddFd(), addr, addy, Close(), DEBUG, fd, I_CONNECTING, I_ERR_BIND, I_ERR_CONNECT, I_ERR_SOCKET, I_ERROR, I_LISTENING, IP, OnError(), state, timeout, timeout_end, and X_ESTAB_MODULE.
.PP
.nf
63 {
64         if (listening) {
65                 if ((this->fd = OpenTCPSocket()) == ERROR)
66                 {
67                         this->fd = -1;
68                         this->state = I_ERROR;
69                         this->OnError(I_ERR_SOCKET);
70                         log(DEBUG,'OpenTCPSocket() error');
71                         return;
72                 }
73                 else
74                 {
75                         if (BindSocket(this->fd,this->client,this->server,port,(char*)host.c_str()) == ERROR)
76                         {
77                                 this->Close();
78                                 this->fd = -1;
79                                 this->state = I_ERROR;
80                                 this->OnError(I_ERR_BIND);
81                                 log(DEBUG,'BindSocket() error %s',strerror(errno));
82                                 return;
83                         }
84                         else
85                         {
86                                 this->state = I_LISTENING;
87                                 SE->AddFd(this->fd,true,X_ESTAB_MODULE);
88                                 log(DEBUG,'New socket now in I_LISTENING state');
89                                 return;
90                         }
91                 }                       
92         } else {
93                 char* ip;
94                 this->host = host;
95                 hostent* hoste = gethostbyname(host.c_str());
96                 if (!hoste) {
97                         ip = (char*)host.c_str();
98                 } else {
99                         struct in_addr* ia = (in_addr*)hoste->h_addr;
100                         ip = inet_ntoa(*ia);
101                 }
102 
103                 this->IP = ip;
104 
105                 timeout_end = time(NULL)+maxtime;
106                 timeout = false;
107                 if ((this->fd = socket(AF_INET, SOCK_STREAM, 0)) == -1)
108                 {
109                         this->state = I_ERROR;
110                         this->OnError(I_ERR_SOCKET);
111                         return;
112                 }
113                 this->port = port;
114                 inet_aton(ip,&addy);
115                 addr.sin_family = AF_INET;
116                 addr.sin_addr = addy;
117                 addr.sin_port = htons(this->port);
118 
119                 int flags;
120                 flags = fcntl(this->fd, F_GETFL, 0);
121                 fcntl(this->fd, F_SETFL, flags | O_NONBLOCK);
122 
123                 if(connect(this->fd, (sockaddr*)&this->addr,sizeof(this->addr)) == -1)
124                 {
125                         if (errno != EINPROGRESS)
126                         {
127                                 this->Close();
128                                 this->OnError(I_ERR_CONNECT);
129                                 this->state = I_ERROR;
130                                 return;
131                         }
132                 }
133                 this->state = I_CONNECTING;
134                 SE->AddFd(this->fd,false,X_ESTAB_MODULE);
135                 return;
136         }
137 }
.fi
.PP
.SS "InspSocket::~InspSocket ()\fC [virtual]\fP"
.PP
Definition at line 265 of file socket.cpp.
.PP
References Close().
.PP
.nf
266 {
267         this->Close();
268 }
.fi
.PP
.SH "Member Function Documentation"
.PP 
.SS "void InspSocket::Close ()\fC [virtual]\fP"
.PP
Definition at line 139 of file socket.cpp.
.PP
References fd, and OnClose().
.PP
Referenced by InspSocket(), and ~InspSocket().
.PP
.nf
140 {
141         if (this->fd != -1)
142         {
143                 this->OnClose();
144                 shutdown(this->fd,2);
145                 close(this->fd);
146                 this->fd = -1;
147         }
148 }
.fi
.PP
.SS "int InspSocket::GetFd ()"
.PP
Definition at line 252 of file socket.cpp.
.PP
References fd.
.PP
.nf
253 {
254         return this->fd;
255 }
.fi
.PP
.SS "\fBstd::string\fP InspSocket::GetIP ()"
.PP
Definition at line 150 of file socket.cpp.
.PP
References IP.
.PP
.nf
151 {
152         return this->IP;
153 }
.fi
.PP
.SS "\fBInspSocketState\fP InspSocket::GetState ()"
.PP
Definition at line 247 of file socket.cpp.
.PP
References state.
.PP
.nf
248 {
249         return this->state;
250 }
.fi
.PP
.SS "void InspSocket::OnClose ()\fC [virtual]\fP"
.PP
Definition at line 263 of file socket.cpp.
.PP
Referenced by Close().
.PP
.nf
263 { return; }
.fi
.PP
.SS "bool InspSocket::OnConnected ()\fC [virtual]\fP"
.PP
Definition at line 257 of file socket.cpp.
.PP
Referenced by Poll().
.PP
.nf
257 { return true; }
.fi
.PP
.SS "bool InspSocket::OnDataReady ()\fC [virtual]\fP"
.PP
Definition at line 261 of file socket.cpp.
.PP
Referenced by Poll().
.PP
.nf
261 { return true; }
.fi
.PP
.SS "int InspSocket::OnDisconnect ()\fC [virtual]\fP"
.PP
Definition at line 259 of file socket.cpp.
.PP
.nf
259 { return 0; }
.fi
.PP
.SS "void InspSocket::OnError (\fBInspSocketError\fP e)\fC [virtual]\fP"
.PP
Definition at line 258 of file socket.cpp.
.PP
Referenced by InspSocket(), and Poll().
.PP
.nf
258 { return; }
.fi
.PP
.SS "int InspSocket::OnIncomingConnection (int newfd, char * ip)\fC [virtual]\fP"
.PP
Definition at line 260 of file socket.cpp.
.PP
Referenced by Poll().
.PP
.nf
260 { return 0; }
.fi
.PP
.SS "void InspSocket::OnTimeout ()\fC [virtual]\fP"
.PP
Definition at line 262 of file socket.cpp.
.PP
Referenced by Poll().
.PP
.nf
262 { return; }
.fi
.PP
.SS "bool InspSocket::Poll ()"
.PP
Definition at line 197 of file socket.cpp.
.PP
References SocketEngine::AddFd(), client, SocketEngine::DelFd(), I_CONNECTED, I_CONNECTING, I_ERR_TIMEOUT, I_ERROR, I_LISTENING, length, OnConnected(), OnDataReady(), OnError(), OnIncomingConnection(), OnTimeout(), SetState(), state, timeout, timeout_end, and X_ESTAB_MODULE.
.PP
.nf
198 {
199         if ((time(NULL) > timeout_end) && (this->state == I_CONNECTING))
200         {
201                 // for non-listening sockets, the timeout can occur
202                 // which causes termination of the connection after
203                 // the given number of seconds without a successful
204                 // connection.
205                 this->OnTimeout();
206                 this->OnError(I_ERR_TIMEOUT);
207                 timeout = true;
208                 this->state = I_ERROR;
209                 return false;
210         }
211 
212         int incoming = -1;
213         
214         switch (this->state)
215         {
216                 case I_CONNECTING:
217                         this->SetState(I_CONNECTED);
218                         /* Our socket was in write-state, so delete it and re-add it
219                          * in read-state.
220                          */
221                         SE->DelFd(this->fd);
222                         SE->AddFd(this->fd,true,X_ESTAB_MODULE);
223                         return this->OnConnected();
224                 break;
225                 case I_LISTENING:
226                         length = sizeof (client);
227                         incoming = accept (this->fd, (sockaddr*)&client,&length);
228                         this->OnIncomingConnection(incoming,inet_ntoa(client.sin_addr));
229                         return true;
230                 break;
231                 case I_CONNECTED:
232                         return this->OnDataReady();
233                 break;
234                 default:
235                 break;
236         }
237 
238         return true;
239 }
.fi
.PP
.SS "char * InspSocket::Read ()\fC [virtual]\fP"
.PP
Definition at line 155 of file socket.cpp.
.PP
References DEBUG, and ibuf.
.PP
.nf
156 {
157         int n = recv(this->fd,this->ibuf,sizeof(this->ibuf),0);
158         if (n > 0)
159         {
160                 ibuf[n] = 0;
161                 return ibuf;
162         }
163         else
164         {
165                 log(DEBUG,'EOF or error on socket');
166                 return NULL;
167         }
168 }
.fi
.PP
.SS "void InspSocket::SetState (\fBInspSocketState\fP s)"
.PP
Definition at line 241 of file socket.cpp.
.PP
References DEBUG, and state.
.PP
Referenced by Poll().
.PP
.nf
242 {
243         log(DEBUG,'Socket state change');
244         this->state = s;
245 }
.fi
.PP
.SS "int InspSocket::Write (\fBstd::string\fP data)\fC [virtual]\fP"
.PP
Definition at line 174 of file socket.cpp.
.PP
.nf
175 {
176         char* d = (char*)data.c_str();
177         unsigned int written = 0;
178         int n = 0;
179         int s = data.length();
180         while ((written < data.length()) && (n >= 0))
181         {
182                 n = send(this->fd,d,s,0);
183                 if (n > 0)
184                 {
185                         // If we didnt write everything, advance
186                         // the pointers so that when we retry
187                         // the next time around the loop, we try
188                         // to write what we failed to write before.
189                         written += n;
190                         s -= n;
191                         d += n;
192                 }
193         }
194         return written;
195 }
.fi
.PP
.SH "Member Data Documentation"
.PP 
.SS "sockaddr_in \fBInspSocket::addr\fP\fC [private]\fP"
.PP
Definition at line 37 of file socket.h.
.PP
Referenced by InspSocket().
.SS "in_addr \fBInspSocket::addy\fP\fC [private]\fP"
.PP
Definition at line 38 of file socket.h.
.PP
Referenced by InspSocket().
.SS "sockaddr_in \fBInspSocket::client\fP\fC [private]\fP"
.PP
Definition at line 44 of file socket.h.
.PP
Referenced by Poll().
.SS "int \fBInspSocket::fd\fP\fC [private]\fP"
.PP
Definition at line 33 of file socket.h.
.PP
Referenced by Close(), GetFd(), and InspSocket().
.SS "\fBstd::string\fP \fBInspSocket::host\fP\fC [private]\fP"
.PP
Definition at line 34 of file socket.h.
.SS "char \fBInspSocket::ibuf\fP[16384]\fC [private]\fP"
.PP
Definition at line 42 of file socket.h.
.PP
Referenced by Read().
.SS "\fBstd::string\fP \fBInspSocket::IP\fP\fC [private]\fP"
.PP
Definition at line 43 of file socket.h.
.PP
Referenced by GetIP(), and InspSocket().
.SS "socklen_t \fBInspSocket::length\fP\fC [private]\fP"
.PP
Definition at line 46 of file socket.h.
.PP
Referenced by Poll().
.SS "pollfd \fBInspSocket::polls\fP\fC [private]\fP"
.PP
Definition at line 41 of file socket.h.
.SS "int \fBInspSocket::port\fP\fC [private]\fP"
.PP
Definition at line 35 of file socket.h.
.SS "sockaddr_in \fBInspSocket::server\fP\fC [private]\fP"
.PP
Definition at line 45 of file socket.h.
.SS "\fBInspSocketState\fP \fBInspSocket::state\fP\fC [private]\fP"
.PP
Definition at line 36 of file socket.h.
.PP
Referenced by GetState(), InspSocket(), Poll(), and SetState().
.SS "bool \fBInspSocket::timeout\fP\fC [private]\fP"
.PP
Definition at line 40 of file socket.h.
.PP
Referenced by InspSocket(), and Poll().
.SS "time_t \fBInspSocket::timeout_end\fP\fC [private]\fP"
.PP
Definition at line 39 of file socket.h.
.PP
Referenced by InspSocket(), and Poll().

.SH "Author"
.PP 
Generated automatically by Doxygen for InspIRCd from the source code.
