.TH "InspSocket" 3 "19 Dec 2005" "Version 1.0Betareleases" "InspIRCd" \" -*- nroff -*-
.ad l
.nh
.SH NAME
InspSocket \- InspSocket is an extendable socket class which modules can use for TCP socket support.  

.PP
.SH SYNOPSIS
.br
.PP
\fC#include <socket.h>\fP
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBInspSocket\fP ()"
.br
.RI "\fIThe default constructor does nothing and should not be used. \fP"
.ti -1c
.RI "\fBInspSocket\fP (int newfd, char *ip)"
.br
.RI "\fIThis constructor is used to associate an existing connecting with an InspSocket class. \fP"
.ti -1c
.RI "\fBInspSocket\fP (\fBstd::string\fP \fBhost\fP, int \fBport\fP, bool listening, unsigned long maxtime)"
.br
.RI "\fIThis constructor is used to create a new socket, either listening for connections, or an outbound connection to another host. \fP"
.ti -1c
.RI "virtual bool \fBOnConnected\fP ()"
.br
.RI "\fIThis method is called when an outbound connection on your socket is completed. \fP"
.ti -1c
.RI "virtual void \fBOnError\fP (\fBInspSocketError\fP e)"
.br
.RI "\fIThis method is called when an error occurs. \fP"
.ti -1c
.RI "virtual int \fBOnDisconnect\fP ()"
.br
.RI "\fIWhen an established connection is terminated, the OnDisconnect method is triggered. \fP"
.ti -1c
.RI "virtual bool \fBOnDataReady\fP ()"
.br
.RI "\fIWhen there is data waiting to be read on a socket, the \fBOnDataReady()\fP method is called. \fP"
.ti -1c
.RI "virtual void \fBOnTimeout\fP ()"
.br
.RI "\fIWhen an outbound connection fails, and the attempt times out, you will receive this event. \fP"
.ti -1c
.RI "virtual void \fBOnClose\fP ()"
.br
.RI "\fIWhenever close() is called, \fBOnClose()\fP will be called first. \fP"
.ti -1c
.RI "virtual char * \fBRead\fP ()"
.br
.RI "\fIReads all pending bytes from the socket into a char* array which can be up to 16 kilobytes in length. \fP"
.ti -1c
.RI "\fBstd::string\fP \fBGetIP\fP ()"
.br
.RI "\fIReturns the IP address associated with this connection, or an empty string if no IP address exists. \fP"
.ti -1c
.RI "bool \fBTimeout\fP (time_t current)"
.br
.RI "\fIThis function checks if the socket has timed out yet, given the current time in the parameter. \fP"
.ti -1c
.RI "virtual int \fBWrite\fP (\fBstd::string\fP data)"
.br
.RI "\fIWrites a \fBstd::string\fP to the socket. \fP"
.ti -1c
.RI "virtual int \fBOnIncomingConnection\fP (int newfd, char *ip)"
.br
.RI "\fIIf your socket is a listening socket, when a new connection comes in on the socket this method will be called. \fP"
.ti -1c
.RI "void \fBSetState\fP (\fBInspSocketState\fP s)"
.br
.RI "\fIChanges the socket's state. \fP"
.ti -1c
.RI "\fBInspSocketState\fP \fBGetState\fP ()"
.br
.RI "\fIReturns the current socket state. \fP"
.ti -1c
.RI "bool \fBPoll\fP ()"
.br
.RI "\fIOnly the core should call this function. \fP"
.ti -1c
.RI "int \fBGetFd\fP ()"
.br
.RI "\fIThis method returns the socket's file descriptor as assigned by the operating system, or -1 if no descriptor has been assigned. \fP"
.ti -1c
.RI "virtual void \fBClose\fP ()"
.br
.RI "\fIThis method causes the socket to close, and may also be triggered by other methods such as OnTimeout and OnError. \fP"
.ti -1c
.RI "virtual \fB~InspSocket\fP ()"
.br
.RI "\fIThe destructor may implicitly call \fBOnClose()\fP, and will close() and shutdown() the file descriptor used for this socket. \fP"
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "void \fBFlushWriteBuffer\fP ()"
.br
.RI "\fIFlushes the write buffer. \fP"
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "int \fBfd\fP"
.br
.RI "\fIThe file descriptor of this socket. \fP"
.ti -1c
.RI "\fBstd::string\fP \fBhost\fP"
.br
.RI "\fIThe hostname connected to. \fP"
.ti -1c
.RI "int \fBport\fP"
.br
.RI "\fIThe port connected to, or the port this socket is listening on. \fP"
.ti -1c
.RI "\fBInspSocketState\fP \fBstate\fP"
.br
.RI "\fIThe state for this socket, either listening, connecting, connected or error. \fP"
.ti -1c
.RI "sockaddr_in \fBaddr\fP"
.br
.RI "\fIThe host being connected to, in sockaddr form. \fP"
.ti -1c
.RI "in_addr \fBaddy\fP"
.br
.RI "\fIThe host being connected to, in in_addr form. \fP"
.ti -1c
.RI "time_t \fBtimeout_end\fP"
.br
.RI "\fIWhen this time is reached, the socket times out if it is in the CONNECTING state. \fP"
.ti -1c
.RI "bool \fBtimeout\fP"
.br
.RI "\fIThis value is true if the socket has timed out. \fP"
.ti -1c
.RI "char \fBibuf\fP [65535]"
.br
.RI "\fISocket input buffer, used by read(). \fP"
.ti -1c
.RI "\fBstd::string\fP \fBBuffer\fP"
.br
.RI "\fIThe output buffer for this socket. \fP"
.ti -1c
.RI "\fBstd::string\fP \fBIP\fP"
.br
.RI "\fIThe IP address being connected to stored in string form for easy retrieval by accessors. \fP"
.ti -1c
.RI "sockaddr_in \fBclient\fP"
.br
.RI "\fIClient sockaddr structure used by accept(). \fP"
.ti -1c
.RI "sockaddr_in \fBserver\fP"
.br
.RI "\fI\fBServer\fP sockaddr structure used by accept(). \fP"
.ti -1c
.RI "socklen_t \fBlength\fP"
.br
.RI "\fIUsed by accept() to indicate the sizes of the sockaddr_in structures. \fP"
.in -1c
.SH "Detailed Description"
.PP 
InspSocket is an extendable socket class which modules can use for TCP socket support. 

It is fully integrated into InspIRCds socket loop and attaches its sockets to the core's instance of the \fBSocketEngine\fP class, meaning that any sockets you create have the same power and abilities as a socket created by the core itself. To use InspSocket, you must inherit a class from it, and use the InspSocket constructors to establish connections and bindings.
.PP
Definition at line 47 of file socket.h.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "InspSocket::InspSocket ()"
.PP
The default constructor does nothing and should not be used. 
.PP
Definition at line 45 of file socket.cpp.
.PP
References I_DISCONNECTED, and state.
.PP
.nf
46 {
47         this->state = I_DISCONNECTED;
48 }
.fi
.PP
.SS "InspSocket::InspSocket (int newfd, char * ip)"
.PP
This constructor is used to associate an existing connecting with an InspSocket class. 
.PP
The given file descriptor must be valid, and when initialized, the InspSocket will be set with the given IP address and placed in CONNECTED state.
.PP
Definition at line 50 of file socket.cpp.
.PP
References SocketEngine::AddFd(), fd, I_CONNECTED, IP, InspIRCd::SE, state, and X_ESTAB_MODULE.
.PP
.nf
51 {
52         this->fd = newfd;
53         this->state = I_CONNECTED;
54         this->IP = ip;
55         ServerInstance->SE->AddFd(this->fd,true,X_ESTAB_MODULE);
56         socket_ref[this->fd] = this;
57 }
.fi
.PP
.SS "InspSocket::InspSocket (\fBstd::string\fP host, int port, bool listening, unsigned long maxtime)"
.PP
This constructor is used to create a new socket, either listening for connections, or an outbound connection to another host. 
.PP
\fBParameters:\fP
.RS 4
\fIhost\fP The hostname to connect to, or bind to 
.br
\fIport\fP The port number to connect to, or bind to 
.br
\fIlistening\fP true to listen on the given host:port pair, or false to connect to them 
.br
\fImaxtime\fP Number of seconds to wait, if connecting, before the connection times out and an \fBOnTimeout()\fP event is generated
.RE
.PP

.PP
Definition at line 59 of file socket.cpp.
.PP
References SocketEngine::AddFd(), addr, addy, BindSocket(), Close(), DEBUG, ERROR, fd, I_CONNECTING, I_ERR_BIND, I_ERR_CONNECT, I_ERR_SOCKET, I_ERROR, I_LISTENING, IP, log(), OnError(), OpenTCPSocket(), InspIRCd::SE, state, timeout, timeout_end, and X_ESTAB_MODULE.
.PP
.nf
60 {
61         if (listening) {
62                 if ((this->fd = OpenTCPSocket()) == ERROR)
63                 {
64                         this->fd = -1;
65                         this->state = I_ERROR;
66                         this->OnError(I_ERR_SOCKET);
67                         log(DEBUG,'OpenTCPSocket() error');
68                         return;
69                 }
70                 else
71                 {
72                         if (BindSocket(this->fd,this->client,this->server,port,(char*)host.c_str()) == ERROR)
73                         {
74                                 this->Close();
75                                 this->fd = -1;
76                                 this->state = I_ERROR;
77                                 this->OnError(I_ERR_BIND);
78                                 log(DEBUG,'BindSocket() error %s',strerror(errno));
79                                 return;
80                         }
81                         else
82                         {
83                                 this->state = I_LISTENING;
84                                 ServerInstance->SE->AddFd(this->fd,true,X_ESTAB_MODULE);
85                                 socket_ref[this->fd] = this;
86                                 log(DEBUG,'New socket now in I_LISTENING state');
87                                 return;
88                         }
89                 }                       
90         } else {
91                 char* ip;
92                 this->host = host;
93                 hostent* hoste = gethostbyname(host.c_str());
94                 if (!hoste) {
95                         ip = (char*)host.c_str();
96                 } else {
97                         struct in_addr* ia = (in_addr*)hoste->h_addr;
98                         ip = inet_ntoa(*ia);
99                 }
100 
101                 this->IP = ip;
102 
103                 timeout_end = time(NULL)+maxtime;
104                 timeout = false;
105                 if ((this->fd = socket(AF_INET, SOCK_STREAM, 0)) == -1)
106                 {
107                         this->state = I_ERROR;
108                         this->OnError(I_ERR_SOCKET);
109                         return;
110                 }
111                 this->port = port;
112                 inet_aton(ip,&addy);
113                 addr.sin_family = AF_INET;
114                 addr.sin_addr = addy;
115                 addr.sin_port = htons(this->port);
116 
117                 int flags;
118                 flags = fcntl(this->fd, F_GETFL, 0);
119                 fcntl(this->fd, F_SETFL, flags | O_NONBLOCK);
120 
121                 if(connect(this->fd, (sockaddr*)&this->addr,sizeof(this->addr)) == -1)
122                 {
123                         if (errno != EINPROGRESS)
124                         {
125                                 this->Close();
126                                 this->OnError(I_ERR_CONNECT);
127                                 this->state = I_ERROR;
128                                 return;
129                         }
130                 }
131                 this->state = I_CONNECTING;
132                 ServerInstance->SE->AddFd(this->fd,false,X_ESTAB_MODULE);
133                 socket_ref[this->fd] = this;
134                 return;
135         }
136 }
.fi
.PP
.SS "InspSocket::~InspSocket ()\fC [virtual]\fP"
.PP
The destructor may implicitly call \fBOnClose()\fP, and will close() and shutdown() the file descriptor used for this socket. 
.PP
Definition at line 271 of file socket.cpp.
.PP
References Close().
.PP
.nf
272 {
273         this->Close();
274 }
.fi
.PP
.SH "Member Function Documentation"
.PP 
.SS "void InspSocket::Close ()\fC [virtual]\fP"
.PP
This method causes the socket to close, and may also be triggered by other methods such as OnTimeout and OnError. 
.PP
Definition at line 138 of file socket.cpp.
.PP
References fd, and OnClose().
.PP
Referenced by InspSocket(), and ~InspSocket().
.PP
.nf
139 {
140         if (this->fd != -1)
141         {
142                 this->OnClose();
143                 shutdown(this->fd,2);
144                 close(this->fd);
145                 socket_ref[this->fd] = NULL;
146                 this->fd = -1;
147         }
148 }
.fi
.PP
.SS "void InspSocket::FlushWriteBuffer ()\fC [private]\fP"
.PP
Flushes the write buffer. 
.PP
Definition at line 181 of file socket.cpp.
.PP
References Buffer.
.PP
Referenced by Timeout(), and Write().
.PP
.nf
182 {
183         int result = 0;
184         if (this->Buffer.length())
185         {
186                 result = send(this->fd,this->Buffer.c_str(),this->Buffer.length(),0);
187                 if (result > 0)
188                 {
189                         /* If we wrote some, advance the buffer forwards */
190                         char* n = (char*)this->Buffer.c_str();
191                         n += result;
192                         this->Buffer = n;
193                 }
194         }
195 }
.fi
.PP
.SS "int InspSocket::GetFd ()"
.PP
This method returns the socket's file descriptor as assigned by the operating system, or -1 if no descriptor has been assigned. 
.PP
Definition at line 258 of file socket.cpp.
.PP
References fd.
.PP
.nf
259 {
260         return this->fd;
261 }
.fi
.PP
.SS "\fBstd::string\fP InspSocket::GetIP ()"
.PP
Returns the IP address associated with this connection, or an empty string if no IP address exists. 
.PP
Definition at line 150 of file socket.cpp.
.PP
References IP.
.PP
.nf
151 {
152         return this->IP;
153 }
.fi
.PP
.SS "\fBInspSocketState\fP InspSocket::GetState ()"
.PP
Returns the current socket state. 
.PP
Definition at line 253 of file socket.cpp.
.PP
References state.
.PP
.nf
254 {
255         return this->state;
256 }
.fi
.PP
.SS "void InspSocket::OnClose ()\fC [virtual]\fP"
.PP
Whenever close() is called, \fBOnClose()\fP will be called first. 
.PP
Please note that this means OnClose will be called alongside \fBOnError()\fP, \fBOnTimeout()\fP, and \fBClose()\fP, and also when cancelling a listening socket by calling the destructor indirectly.
.PP
Definition at line 269 of file socket.cpp.
.PP
Referenced by Close().
.PP
.nf
269 { return; }
.fi
.PP
.SS "bool InspSocket::OnConnected ()\fC [virtual]\fP"
.PP
This method is called when an outbound connection on your socket is completed. 
.PP
\fBReturns:\fP
.RS 4
false to abort the connection, true to continue
.RE
.PP

.PP
Definition at line 263 of file socket.cpp.
.PP
Referenced by Poll().
.PP
.nf
263 { return true; }
.fi
.PP
.SS "bool InspSocket::OnDataReady ()\fC [virtual]\fP"
.PP
When there is data waiting to be read on a socket, the \fBOnDataReady()\fP method is called. 
.PP
Within this method, you *MUST* call the \fBRead()\fP method to read any pending data. At its lowest level, this event is signalled by the core via the socket engine. If you return false from this function, the core removes your socket from its list and erases it from the socket engine, then calls \fBInspSocket::Close()\fP and deletes it. 
.PP
\fBReturns:\fP
.RS 4
false to close the socket
.RE
.PP

.PP
Definition at line 267 of file socket.cpp.
.PP
Referenced by Poll().
.PP
.nf
267 { return true; }
.fi
.PP
.SS "int InspSocket::OnDisconnect ()\fC [virtual]\fP"
.PP
When an established connection is terminated, the OnDisconnect method is triggered. 
.PP
Definition at line 265 of file socket.cpp.
.PP
.nf
265 { return 0; }
.fi
.PP
.SS "void InspSocket::OnError (\fBInspSocketError\fP e)\fC [virtual]\fP"
.PP
This method is called when an error occurs. 
.PP
A closed socket in itself is not an error, however errors also generate close events. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The error type which occured
.RE
.PP

.PP
Definition at line 264 of file socket.cpp.
.PP
Referenced by InspSocket(), and Timeout().
.PP
.nf
264 { return; }
.fi
.PP
.SS "int InspSocket::OnIncomingConnection (int newfd, char * ip)\fC [virtual]\fP"
.PP
If your socket is a listening socket, when a new connection comes in on the socket this method will be called. 
.PP
Given the new file descriptor in the parameters, and the IP, it is recommended you copy them to a new instance of your socket class, e.g.:
.PP
MySocket* newsocket = new MySocket(newfd,ip);
.PP
Once you have done this, you can then associate the new socket with the core using \fBServer::AddSocket()\fP.
.PP
Definition at line 266 of file socket.cpp.
.PP
Referenced by Poll().
.PP
.nf
266 { return 0; }
.fi
.PP
.SS "void InspSocket::OnTimeout ()\fC [virtual]\fP"
.PP
When an outbound connection fails, and the attempt times out, you will receive this event. 
.PP
The mthod will trigger once maxtime secons are reached (as given in the constructor) just before the socket's descriptor is closed.
.PP
Definition at line 268 of file socket.cpp.
.PP
Referenced by Timeout().
.PP
.nf
268 { return; }
.fi
.PP
.SS "bool InspSocket::Poll ()"
.PP
Only the core should call this function. 
.PP
When called, it is assumed the socket is ready to read data, and the method call routes the event to the various methods of InspSocket for you to handle. This can also cause the socket's state to change.
.PP
Definition at line 216 of file socket.cpp.
.PP
References SocketEngine::AddFd(), client, SocketEngine::DelFd(), I_CONNECTED, I_CONNECTING, I_LISTENING, length, OnConnected(), OnDataReady(), OnIncomingConnection(), InspIRCd::SE, SetState(), and X_ESTAB_MODULE.
.PP
.nf
217 {
218         int incoming = -1;
219         
220         switch (this->state)
221         {
222                 case I_CONNECTING:
223                         this->SetState(I_CONNECTED);
224                         /* Our socket was in write-state, so delete it and re-add it
225                          * in read-state.
226                          */
227                         ServerInstance->SE->DelFd(this->fd);
228                         ServerInstance->SE->AddFd(this->fd,true,X_ESTAB_MODULE);
229                         return this->OnConnected();
230                 break;
231                 case I_LISTENING:
232                         length = sizeof (client);
233                         incoming = accept (this->fd, (sockaddr*)&client,&length);
234                         this->OnIncomingConnection(incoming,inet_ntoa(client.sin_addr));
235                         return true;
236                 break;
237                 case I_CONNECTED:
238                         return this->OnDataReady();
239                 break;
240                 default:
241                 break;
242         }
243 
244         return true;
245 }
.fi
.PP
.SS "char * InspSocket::Read ()\fC [virtual]\fP"
.PP
Reads all pending bytes from the socket into a char* array which can be up to 16 kilobytes in length. 
.PP
Definition at line 155 of file socket.cpp.
.PP
References DEBUG, ibuf, and log().
.PP
.nf
156 {
157         int n = recv(this->fd,this->ibuf,sizeof(this->ibuf),0);
158         if (n > 0)
159         {
160                 ibuf[n] = 0;
161                 return ibuf;
162         }
163         else
164         {
165                 log(DEBUG,'EOF or error on socket');
166                 return NULL;
167         }
168 }
.fi
.PP
.SS "void InspSocket::SetState (\fBInspSocketState\fP s)"
.PP
Changes the socket's state. 
.PP
The core uses this to change socket states, and you should not call it directly.
.PP
Definition at line 247 of file socket.cpp.
.PP
References DEBUG, log(), and state.
.PP
Referenced by Poll().
.PP
.nf
248 {
249         log(DEBUG,'Socket state change');
250         this->state = s;
251 }
.fi
.PP
.SS "bool InspSocket::Timeout (time_t current)"
.PP
This function checks if the socket has timed out yet, given the current time in the parameter. 
.PP
\fBReturns:\fP
.RS 4
true if timed out, false if not timed out
.RE
.PP

.PP
Definition at line 197 of file socket.cpp.
.PP
References FlushWriteBuffer(), I_CONNECTING, I_ERR_TIMEOUT, I_ERROR, OnError(), OnTimeout(), state, timeout, and timeout_end.
.PP
.nf
198 {
199         if ((this->state == I_CONNECTING) && (current > timeout_end))
200         {
201                 // for non-listening sockets, the timeout can occur
202                 // which causes termination of the connection after
203                 // the given number of seconds without a successful
204                 // connection.
205                 this->OnTimeout();
206                 this->OnError(I_ERR_TIMEOUT);
207                 timeout = true;
208                 this->state = I_ERROR;
209                 return true;
210         }
211         if (this->Buffer.length())
212                 this->FlushWriteBuffer();
213         return false;
214 }
.fi
.PP
.SS "int InspSocket::Write (\fBstd::string\fP data)\fC [virtual]\fP"
.PP
Writes a \fBstd::string\fP to the socket. 
.PP
No carriage returns or linefeeds are appended to the string. 
.PP
\fBParameters:\fP
.RS 4
\fIdata\fP The data to send
.RE
.PP

.PP
Definition at line 174 of file socket.cpp.
.PP
References Buffer, and FlushWriteBuffer().
.PP
.nf
175 {
176         this->Buffer = this->Buffer + data;
177         this->FlushWriteBuffer();
178         return data.length();
179 }
.fi
.PP
.SH "Member Data Documentation"
.PP 
.SS "sockaddr_in \fBInspSocket::addr\fP\fC [private]\fP"
.PP
The host being connected to, in sockaddr form. 
.PP
Definition at line 78 of file socket.h.
.PP
Referenced by InspSocket().
.SS "in_addr \fBInspSocket::addy\fP\fC [private]\fP"
.PP
The host being connected to, in in_addr form. 
.PP
Definition at line 84 of file socket.h.
.PP
Referenced by InspSocket().
.SS "\fBstd::string\fP \fBInspSocket::Buffer\fP\fC [private]\fP"
.PP
The output buffer for this socket. 
.PP
Definition at line 111 of file socket.h.
.PP
Referenced by FlushWriteBuffer(), and Write().
.SS "sockaddr_in \fBInspSocket::client\fP\fC [private]\fP"
.PP
Client sockaddr structure used by accept(). 
.PP
Definition at line 124 of file socket.h.
.PP
Referenced by Poll().
.SS "int \fBInspSocket::fd\fP\fC [private]\fP"
.PP
The file descriptor of this socket. 
.PP
Definition at line 54 of file socket.h.
.PP
Referenced by Close(), GetFd(), and InspSocket().
.SS "\fBstd::string\fP \fBInspSocket::host\fP\fC [private]\fP"
.PP
The hostname connected to. 
.PP
Definition at line 59 of file socket.h.
.SS "char \fBInspSocket::ibuf\fP[65535]\fC [private]\fP"
.PP
Socket input buffer, used by read(). 
.PP
The class which extends InspSocket is expected to implement an extendable buffer which can grow much larger than 64k, this buffer is just designed to be temporary storage. space.
.PP
Definition at line 106 of file socket.h.
.PP
Referenced by Read().
.SS "\fBstd::string\fP \fBInspSocket::IP\fP\fC [private]\fP"
.PP
The IP address being connected to stored in string form for easy retrieval by accessors. 
.PP
Definition at line 118 of file socket.h.
.PP
Referenced by GetIP(), and InspSocket().
.SS "socklen_t \fBInspSocket::length\fP\fC [private]\fP"
.PP
Used by accept() to indicate the sizes of the sockaddr_in structures. 
.PP
Definition at line 136 of file socket.h.
.PP
Referenced by Poll().
.SS "int \fBInspSocket::port\fP\fC [private]\fP"
.PP
The port connected to, or the port this socket is listening on. 
.PP
Definition at line 65 of file socket.h.
.SS "sockaddr_in \fBInspSocket::server\fP\fC [private]\fP"
.PP
\fBServer\fP sockaddr structure used by accept(). 
.PP
Definition at line 130 of file socket.h.
.SS "\fBInspSocketState\fP \fBInspSocket::state\fP\fC [private]\fP"
.PP
The state for this socket, either listening, connecting, connected or error. 
.PP
Definition at line 72 of file socket.h.
.PP
Referenced by GetState(), InspSocket(), SetState(), and Timeout().
.SS "bool \fBInspSocket::timeout\fP\fC [private]\fP"
.PP
This value is true if the socket has timed out. 
.PP
Definition at line 97 of file socket.h.
.PP
Referenced by InspSocket(), and Timeout().
.SS "time_t \fBInspSocket::timeout_end\fP\fC [private]\fP"
.PP
When this time is reached, the socket times out if it is in the CONNECTING state. 
.PP
Definition at line 91 of file socket.h.
.PP
Referenced by InspSocket(), and Timeout().

.SH "Author"
.PP 
Generated automatically by Doxygen for InspIRCd from the source code.
