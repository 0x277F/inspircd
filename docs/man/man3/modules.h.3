.TH "modules.h" 3 "19 Dec 2005" "Version 1.0Betareleases" "InspIRCd" \" -*- nroff -*-
.ad l
.nh
.SH NAME
modules.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'dynamic.h'\fP
.br
\fC#include 'base.h'\fP
.br
\fC#include 'ctables.h'\fP
.br
\fC#include 'socket.h'\fP
.br
\fC#include <string>\fP
.br
\fC#include <deque>\fP
.br
\fC#include <sstream>\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBVersion\fP"
.br
.RI "\fIHolds a module's Version information The four members (set by the constructor only) indicate details as to the version number of a module. \fP"
.ti -1c
.RI "class \fBAdmin\fP"
.br
.RI "\fIHolds /ADMIN data This class contains the admin details of the local server. \fP"
.ti -1c
.RI "class \fBModuleMessage\fP"
.br
.RI "\fIThe ModuleMessage class is the base class of \fBRequest\fP and \fBEvent\fP This class is used to represent a basic data structure which is passed between modules for safe inter-module communications. \fP"
.ti -1c
.RI "class \fBRequest\fP"
.br
.RI "\fIThe Request class is a unicast message directed at a given module. \fP"
.ti -1c
.RI "class \fBEvent\fP"
.br
.RI "\fIThe Event class is a unicast message directed at all modules. \fP"
.ti -1c
.RI "class \fBExtMode\fP"
.br
.RI "\fIHolds an extended mode's details. \fP"
.ti -1c
.RI "class \fBModule\fP"
.br
.RI "\fIBase class for all \fBInspIRCd\fP modules This class is the base class for \fBInspIRCd\fP modules. \fP"
.ti -1c
.RI "class \fBServer\fP"
.br
.RI "\fIAllows server output and query functions This class contains methods which allow a module to query the state of the irc server, and produce output to users and other servers. \fP"
.ti -1c
.RI "class \fBConfigReader\fP"
.br
.RI "\fIAllows reading of values from configuration files This class allows a module to read from either the main configuration file (inspircd.conf) or from a module-specified configuration file. \fP"
.ti -1c
.RI "class \fBFileReader\fP"
.br
.RI "\fICaches a text file into memory and can be used to retrieve lines from it. \fP"
.ti -1c
.RI "class \fBModuleFactory\fP"
.br
.RI "\fIInstantiates classes inherited from \fBModule\fP This class creates a class inherited from type \fBModule\fP, using new. \fP"
.in -1c
.SS "Defines"

.in +1c
.ti -1c
.RI "#define \fBDEBUG\fP   10"
.br
.RI "\fIlog levels \fP"
.ti -1c
.RI "#define \fBVERBOSE\fP   20"
.br
.ti -1c
.RI "#define \fBDEFAULT\fP   30"
.br
.ti -1c
.RI "#define \fBSPARSE\fP   40"
.br
.ti -1c
.RI "#define \fBNONE\fP   50"
.br
.ti -1c
.RI "#define \fBMT_CHANNEL\fP   1"
.br
.RI "\fIUsed with OnExtendedMode() method of modules. \fP"
.ti -1c
.RI "#define \fBMT_CLIENT\fP   2"
.br
.ti -1c
.RI "#define \fBMT_SERVER\fP   3"
.br
.ti -1c
.RI "#define \fBACR_DEFAULT\fP   0"
.br
.RI "\fIUsed with OnAccessCheck() method of modules. \fP"
.ti -1c
.RI "#define \fBACR_DENY\fP   1"
.br
.ti -1c
.RI "#define \fBACR_ALLOW\fP   2"
.br
.ti -1c
.RI "#define \fBAC_KICK\fP   0"
.br
.ti -1c
.RI "#define \fBAC_DEOP\fP   1"
.br
.ti -1c
.RI "#define \fBAC_OP\fP   2"
.br
.ti -1c
.RI "#define \fBAC_VOICE\fP   3"
.br
.ti -1c
.RI "#define \fBAC_DEVOICE\fP   4"
.br
.ti -1c
.RI "#define \fBAC_HALFOP\fP   5"
.br
.ti -1c
.RI "#define \fBAC_DEHALFOP\fP   6"
.br
.ti -1c
.RI "#define \fBAC_INVITE\fP   7"
.br
.ti -1c
.RI "#define \fBAC_GENERAL_MODE\fP   8"
.br
.ti -1c
.RI "#define \fBVF_STATIC\fP   1"
.br
.RI "\fIUsed to define a set of behavior bits for a module. \fP"
.ti -1c
.RI "#define \fBVF_VENDOR\fP   2"
.br
.ti -1c
.RI "#define \fBVF_SERVICEPROVIDER\fP   4"
.br
.ti -1c
.RI "#define \fBVF_COMMON\fP   8"
.br
.ti -1c
.RI "#define \fBFOREACH_MOD\fP   for (int _i = 0; _i <= \fBMODCOUNT\fP; _i++) modules[_i]->"
.br
.ti -1c
.RI "#define \fBFOREACH_RESULT\fP(x)"
.br
.ti -1c
.RI "#define \fBFD_MAGIC_NUMBER\fP   -42"
.br
.ti -1c
.RI "#define \fBIS_LOCAL\fP(x)   (x->fd > -1)"
.br
.ti -1c
.RI "#define \fBIS_REMOTE\fP(x)   (x->fd < 0)"
.br
.ti -1c
.RI "#define \fBIS_MODULE_CREATED\fP(x)   (x->fd == FD_MAGIC_NUMBER)"
.br
.ti -1c
.RI "#define \fBWM_AND\fP   1"
.br
.ti -1c
.RI "#define \fBWM_OR\fP   2"
.br
.ti -1c
.RI "#define \fBTYPE_USER\fP   1"
.br
.ti -1c
.RI "#define \fBTYPE_CHANNEL\fP   2"
.br
.ti -1c
.RI "#define \fBTYPE_SERVER\fP   3"
.br
.ti -1c
.RI "#define \fBCONF_NOT_A_NUMBER\fP   0x000010"
.br
.ti -1c
.RI "#define \fBCONF_NOT_UNSIGNED\fP   0x000080"
.br
.ti -1c
.RI "#define \fBCONF_VALUE_NOT_FOUND\fP   0x000100"
.br
.ti -1c
.RI "#define \fBCONF_FILE_NOT_FOUND\fP   0x000200"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef std::deque< \fBstd::string\fP > \fBfile_cache\fP"
.br
.RI "\fILow level definition of a \fBFileReader\fP classes file cache area. \fP"
.ti -1c
.RI "typedef \fBfile_cache\fP \fBstring_list\fP"
.br
.ti -1c
.RI "typedef std::deque< \fBuserrec\fP * > \fBchanuserlist\fP"
.br
.RI "\fIHolds a list of users in a channel. \fP"
.ti -1c
.RI "typedef DLLFactory< \fBModuleFactory\fP > \fBircd_module\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "bool \fBModeDefined\fP (char c, int i)"
.br
.ti -1c
.RI "bool \fBModeDefinedOper\fP (char c, int i)"
.br
.ti -1c
.RI "int \fBModeDefinedOn\fP (char c, int i)"
.br
.ti -1c
.RI "int \fBModeDefinedOff\fP (char c, int i)"
.br
.ti -1c
.RI "void \fBModeMakeList\fP (char modechar)"
.br
.ti -1c
.RI "bool \fBModeIsListMode\fP (char modechar, int type)"
.br
.in -1c
.SH "Define Documentation"
.PP 
.SS "#define AC_DEHALFOP   6"
.PP
Definition at line 46 of file modules.h.
.SS "#define AC_DEOP   1"
.PP
Definition at line 41 of file modules.h.
.SS "#define AC_DEVOICE   4"
.PP
Definition at line 44 of file modules.h.
.SS "#define AC_GENERAL_MODE   8"
.PP
Definition at line 48 of file modules.h.
.SS "#define AC_HALFOP   5"
.PP
Definition at line 45 of file modules.h.
.SS "#define AC_INVITE   7"
.PP
Definition at line 47 of file modules.h.
.SS "#define AC_KICK   0"
.PP
Definition at line 40 of file modules.h.
.PP
Referenced by kick_channel().
.SS "#define AC_OP   2"
.PP
Definition at line 42 of file modules.h.
.SS "#define AC_VOICE   3"
.PP
Definition at line 43 of file modules.h.
.SS "#define ACR_ALLOW   2"
.PP
Definition at line 39 of file modules.h.
.SS "#define ACR_DEFAULT   0"
.PP
Used with OnAccessCheck() method of modules. 
.PP
Definition at line 37 of file modules.h.
.PP
Referenced by kick_channel(), and Module::OnAccessCheck().
.SS "#define ACR_DENY   1"
.PP
Definition at line 38 of file modules.h.
.PP
Referenced by kick_channel().
.SS "#define CONF_FILE_NOT_FOUND   0x000200"
.PP
Definition at line 1541 of file modules.h.
.PP
Referenced by ConfigReader::ConfigReader().
.SS "#define CONF_NOT_A_NUMBER   0x000010"
.PP
Definition at line 1538 of file modules.h.
.PP
Referenced by ConfigReader::ReadInteger().
.SS "#define CONF_NOT_UNSIGNED   0x000080"
.PP
Definition at line 1539 of file modules.h.
.PP
Referenced by ConfigReader::ReadInteger().
.SS "#define CONF_VALUE_NOT_FOUND   0x000100"
.PP
Definition at line 1540 of file modules.h.
.PP
Referenced by ConfigReader::ReadFlag(), ConfigReader::ReadInteger(), and ConfigReader::ReadValue().
.SS "#define DEBUG   10"
.PP
log levels 
.PP
Definition at line 23 of file modules.h.
.SS "#define DEFAULT   30"
.PP
Definition at line 25 of file modules.h.
.SS "#define FD_MAGIC_NUMBER   -42"
.PP
Definition at line 102 of file modules.h.
.PP
Referenced by Server::PseudoToUser(), and Server::UserToPseudo().
.SS "#define FOREACH_MOD   for (int _i = 0; _i <= \fBMODCOUNT\fP; _i++) modules[_i]->"
.PP
Definition at line 82 of file modules.h.
.PP
Referenced by del_channel(), ForceChan(), FullConnectUser(), kick_channel(), kill_link(), kill_link_silent(), and Event::Send().
.SS "#define FOREACH_RESULT(x)"
.PP
\fBValue:\fP
.PP
.nf
{ MOD_RESULT = 0; \
                        for (int _i = 0; _i <= MODCOUNT; _i++) { \
                        int res = modules[_i]->x ; \
                        if (res != 0) { \
                                MOD_RESULT = res; \
                                break; \
                        } \
                } \
        }
.fi
.PP
Definition at line 90 of file modules.h.
.PP
Referenced by add_channel(), force_nickchange(), and kick_channel().
.SS "#define IS_LOCAL(x)   (x->fd > -1)"
.PP
Definition at line 106 of file modules.h.
.SS "#define IS_MODULE_CREATED(x)   (x->fd == FD_MAGIC_NUMBER)"
.PP
Definition at line 108 of file modules.h.
.SS "#define IS_REMOTE(x)   (x->fd < 0)"
.PP
Definition at line 107 of file modules.h.
.SS "#define MT_CHANNEL   1"
.PP
Used with OnExtendedMode() method of modules. 
.PP
Definition at line 31 of file modules.h.
.PP
Referenced by Server::AddExtendedListMode(), and ModeMakeList().
.SS "#define MT_CLIENT   2"
.PP
Definition at line 32 of file modules.h.
.PP
Referenced by Server::AddExtendedMode().
.SS "#define MT_SERVER   3"
.PP
Definition at line 33 of file modules.h.
.PP
Referenced by Server::AddExtendedMode().
.SS "#define NONE   50"
.PP
Definition at line 27 of file modules.h.
.SS "#define SPARSE   40"
.PP
Definition at line 26 of file modules.h.
.SS "#define TYPE_CHANNEL   2"
.PP
Definition at line 118 of file modules.h.
.SS "#define TYPE_SERVER   3"
.PP
Definition at line 119 of file modules.h.
.SS "#define TYPE_USER   1"
.PP
Definition at line 117 of file modules.h.
.SS "#define VERBOSE   20"
.PP
Definition at line 24 of file modules.h.
.SS "#define VF_COMMON   8"
.PP
Definition at line 55 of file modules.h.
.SS "#define VF_SERVICEPROVIDER   4"
.PP
Definition at line 54 of file modules.h.
.SS "#define VF_STATIC   1"
.PP
Used to define a set of behavior bits for a module. 
.PP
Definition at line 52 of file modules.h.
.SS "#define VF_VENDOR   2"
.PP
Definition at line 53 of file modules.h.
.PP
Referenced by Module::GetVersion().
.SS "#define WM_AND   1"
.PP
Definition at line 112 of file modules.h.
.SS "#define WM_OR   2"
.PP
Definition at line 113 of file modules.h.
.SH "Typedef Documentation"
.PP 
.SS "typedef std::deque<\fBuserrec\fP*> \fBchanuserlist\fP"
.PP
Holds a list of users in a channel. 
.PP
Definition at line 75 of file modules.h.
.SS "typedef std::deque<\fBstd::string\fP> \fBfile_cache\fP"
.PP
Low level definition of a \fBFileReader\fP classes file cache area. 
.PP
Definition at line 66 of file modules.h.
.SS "typedef DLLFactory<\fBModuleFactory\fP> \fBircd_module\fP"
.PP
Definition at line 1707 of file modules.h.
.SS "typedef \fBfile_cache\fP \fBstring_list\fP"
.PP
Definition at line 71 of file modules.h.
.SH "Function Documentation"
.PP 
.SS "bool ModeDefined (char c, int i)"
.PP
Definition at line 70 of file modules.cpp.
.PP
References EMode.
.PP
Referenced by DoAddExtendedMode().
.PP
.nf
71 {
72         for (ExtModeListIter i = EMode.begin(); i < EMode.end(); i++)
73         {
74                 if ((i->modechar == modechar) && (i->type == type))
75                 {
76                         return true;
77                 }
78         }
79         return false;
80 }
.fi
.PP
.SS "int ModeDefinedOff (char c, int i)"
.PP
Definition at line 120 of file modules.cpp.
.PP
References EMode.
.PP
.nf
121 {
122         for (ExtModeListIter i = EMode.begin(); i < EMode.end(); i++)
123         {
124                 if ((i->modechar == modechar) && (i->type == type))
125                 {
126                         return i->params_when_off;
127                 }
128         }
129         return 0;
130 }
.fi
.PP
.SS "int ModeDefinedOn (char c, int i)"
.PP
Definition at line 107 of file modules.cpp.
.PP
References EMode.
.PP
.nf
108 {
109         for (ExtModeListIter i = EMode.begin(); i < EMode.end(); i++)
110         {
111                 if ((i->modechar == modechar) && (i->type == type))
112                 {
113                         return i->params_when_on;
114                 }
115         }
116         return 0;
117 }
.fi
.PP
.SS "bool ModeDefinedOper (char c, int i)"
.PP
Definition at line 94 of file modules.cpp.
.PP
References EMode.
.PP
.nf
95 {
96         for (ExtModeListIter i = EMode.begin(); i < EMode.end(); i++)
97         {
98                 if ((i->modechar == modechar) && (i->type == type) && (i->needsoper == true))
99                 {
100                         return true;
101                 }
102         }
103         return false;
104 }
.fi
.PP
.SS "bool ModeIsListMode (char modechar, int type)"
.PP
Definition at line 82 of file modules.cpp.
.PP
References EMode.
.PP
.nf
83 {
84         for (ExtModeListIter i = EMode.begin(); i < EMode.end(); i++)
85         {
86                 if ((i->modechar == modechar) && (i->type == type) && (i->list == true))
87                 {
88                         return true;
89                 }
90         }
91         return false;
92 }
.fi
.PP
.SS "void ModeMakeList (char modechar)"
.PP
Definition at line 143 of file modules.cpp.
.PP
References EMode, and MT_CHANNEL.
.PP
Referenced by Server::AddExtendedListMode().
.PP
.nf
144 {
145         for (ExtModeListIter i = EMode.begin(); i < EMode.end(); i++)
146         {
147                 if ((i->modechar == modechar) && (i->type == MT_CHANNEL))
148                 {
149                         i->list = true;
150                         return;
151                 }
152         }
153         return;
154 }
.fi
.PP
.SH "Author"
.PP 
Generated automatically by Doxygen for InspIRCd from the source code.
