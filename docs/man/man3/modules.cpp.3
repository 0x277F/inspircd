.TH "modules.cpp" 3 "12 Dec 2005" "Version 1.0Betareleases" "InspIRCd" \" -*- nroff -*-
.ad l
.nh
.SH NAME
modules.cpp \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'inspircd_config.h'\fP
.br
\fC#include 'inspircd.h'\fP
.br
\fC#include 'inspircd_io.h'\fP
.br
\fC#include 'inspircd_util.h'\fP
.br
\fC#include <unistd.h>\fP
.br
\fC#include <sys/errno.h>\fP
.br
\fC#include <time.h>\fP
.br
\fC#include <string>\fP
.br
\fC#include <hash_map>\fP
.br
\fC#include <map>\fP
.br
\fC#include <sstream>\fP
.br
\fC#include <vector>\fP
.br
\fC#include <deque>\fP
.br
\fC#include 'users.h'\fP
.br
\fC#include 'ctables.h'\fP
.br
\fC#include 'globals.h'\fP
.br
\fC#include 'modules.h'\fP
.br
\fC#include 'dynamic.h'\fP
.br
\fC#include 'wildcard.h'\fP
.br
\fC#include 'message.h'\fP
.br
\fC#include 'mode.h'\fP
.br
\fC#include 'xline.h'\fP
.br
\fC#include 'commands.h'\fP
.br
\fC#include 'inspstring.h'\fP
.br
\fC#include 'helperfuncs.h'\fP
.br
\fC#include 'hashcomp.h'\fP
.br
\fC#include 'socket.h'\fP
.br
\fC#include 'socketengine.h'\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBExtMode\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef nspace::hash_map< \fBstd::string\fP, \fBuserrec\fP *, nspace::hash< \fBstring\fP >, \fBirc::StrHashComp\fP > \fBuser_hash\fP"
.br
.ti -1c
.RI "typedef nspace::hash_map< \fBstd::string\fP, \fBchanrec\fP *, nspace::hash< \fBstring\fP >, \fBirc::StrHashComp\fP > \fBchan_hash\fP"
.br
.ti -1c
.RI "typedef nspace::hash_map< in_addr, \fBstring\fP *, nspace::hash< in_addr >, \fBirc::InAddr_HashComp\fP > \fBaddress_cache\fP"
.br
.ti -1c
.RI "typedef nspace::hash_map< \fBstd::string\fP, \fBWhoWasUser\fP *, nspace::hash< \fBstring\fP >, \fBirc::StrHashComp\fP > \fBwhowas_hash\fP"
.br
.ti -1c
.RI "typedef std::deque< \fBcommand_t\fP > \fBcommand_table\fP"
.br
.ti -1c
.RI "typedef std::vector< \fBExtMode\fP > \fBExtModeList\fP"
.br
.ti -1c
.RI "typedef ExtModeList::iterator \fBExtModeListIter\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "bool \fBModeDefined\fP (char modechar, int type)"
.br
.ti -1c
.RI "bool \fBModeIsListMode\fP (char modechar, int type)"
.br
.ti -1c
.RI "bool \fBModeDefinedOper\fP (char modechar, int type)"
.br
.ti -1c
.RI "int \fBModeDefinedOn\fP (char modechar, int type)"
.br
.ti -1c
.RI "int \fBModeDefinedOff\fP (char modechar, int type)"
.br
.ti -1c
.RI "bool \fBDoAddExtendedMode\fP (char modechar, int type, bool requires_oper, int params_on, int params_off)"
.br
.ti -1c
.RI "void \fBModeMakeList\fP (char modechar)"
.br
.ti -1c
.RI "std::vector< \fBModule\fP * > \fBmodules\fP (255)"
.br
.ti -1c
.RI "std::vector< \fBircd_module\fP * > \fBfactory\fP (255)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "\fBSocketEngine\fP * \fBSE\fP"
.br
.ti -1c
.RI "int \fBMODCOUNT\fP = -1"
.br
.ti -1c
.RI "std::vector< \fBModule\fP * > \fBmodules\fP"
.br
.ti -1c
.RI "std::vector< \fBircd_module\fP * > \fBfactory\fP"
.br
.ti -1c
.RI "std::vector< \fBstd::string\fP > \fBinclude_stack\fP"
.br
.ti -1c
.RI "std::vector< \fBInspSocket\fP * > \fBmodule_sockets\fP"
.br
.ti -1c
.RI "time_t \fBTIME\fP"
.br
.ti -1c
.RI "int \fBLogLevel\fP"
.br
.ti -1c
.RI "char \fBServerName\fP [MAXBUF]"
.br
.ti -1c
.RI "char \fBNetwork\fP [MAXBUF]"
.br
.ti -1c
.RI "char \fBServerDesc\fP [MAXBUF]"
.br
.ti -1c
.RI "char \fBAdminName\fP [MAXBUF]"
.br
.ti -1c
.RI "char \fBAdminEmail\fP [MAXBUF]"
.br
.ti -1c
.RI "char \fBAdminNick\fP [MAXBUF]"
.br
.ti -1c
.RI "char \fBdiepass\fP [MAXBUF]"
.br
.ti -1c
.RI "char \fBrestartpass\fP [MAXBUF]"
.br
.ti -1c
.RI "char \fBmotd\fP [MAXBUF]"
.br
.ti -1c
.RI "char \fBrules\fP [MAXBUF]"
.br
.ti -1c
.RI "char \fBlist\fP [MAXBUF]"
.br
.ti -1c
.RI "char \fBPrefixQuit\fP [MAXBUF]"
.br
.ti -1c
.RI "char \fBDieValue\fP [MAXBUF]"
.br
.ti -1c
.RI "int \fBdebugging\fP"
.br
.ti -1c
.RI "int \fBWHOWAS_STALE\fP"
.br
.ti -1c
.RI "int \fBWHOWAS_MAX\fP"
.br
.ti -1c
.RI "int \fBDieDelay\fP"
.br
.ti -1c
.RI "time_t \fBstartup_time\fP"
.br
.ti -1c
.RI "int \fBNetBufferSize\fP"
.br
.ti -1c
.RI "int \fBMaxWhoResults\fP"
.br
.ti -1c
.RI "time_t \fBnb_start\fP"
.br
.ti -1c
.RI "std::vector< \fBstd::string\fP > \fBmodule_names\fP"
.br
.ti -1c
.RI "int \fBboundPortCount\fP"
.br
.ti -1c
.RI "int \fBportCount\fP"
.br
.ti -1c
.RI "int \fBports\fP [MAXSOCKS]"
.br
.ti -1c
.RI "std::stringstream \fBconfig_f\fP"
.br
.ti -1c
.RI "FILE * \fBlog_file\fP"
.br
.ti -1c
.RI "\fBuserrec\fP * \fBfd_ref_table\fP [65536]"
.br
.ti -1c
.RI "\fBuser_hash\fP \fBclientlist\fP"
.br
.ti -1c
.RI "\fBchan_hash\fP \fBchanlist\fP"
.br
.ti -1c
.RI "\fBwhowas_hash\fP \fBwhowas\fP"
.br
.ti -1c
.RI "\fBcommand_table\fP \fBcmdlist\fP"
.br
.ti -1c
.RI "\fBfile_cache\fP \fBMOTD\fP"
.br
.ti -1c
.RI "\fBfile_cache\fP \fBRULES\fP"
.br
.ti -1c
.RI "\fBaddress_cache\fP \fBIP\fP"
.br
.ti -1c
.RI "\fBExtModeList\fP \fBEMode\fP"
.br
.in -1c
.SH "Typedef Documentation"
.PP 
.SS "typedef nspace::hash_map<in_addr,\fBstring\fP*, nspace::hash<in_addr>, \fBirc::InAddr_HashComp\fP> \fBaddress_cache\fP"
.PP
Definition at line 117 of file modules.cpp.
.SS "typedef nspace::hash_map<\fBstd::string\fP, \fBchanrec\fP*, nspace::hash<\fBstring\fP>, \fBirc::StrHashComp\fP> \fBchan_hash\fP"
.PP
Definition at line 116 of file modules.cpp.
.SS "typedef std::deque<\fBcommand_t\fP> \fBcommand_table\fP"
.PP
Definition at line 119 of file modules.cpp.
.SS "typedef std::vector<\fBExtMode\fP> \fBExtModeList\fP"
.PP
Definition at line 145 of file modules.cpp.
.SS "typedef ExtModeList::iterator \fBExtModeListIter\fP"
.PP
Definition at line 146 of file modules.cpp.
.SS "typedef nspace::hash_map<\fBstd::string\fP, \fBuserrec\fP*, nspace::hash<\fBstring\fP>, \fBirc::StrHashComp\fP> \fBuser_hash\fP"
.PP
Definition at line 115 of file modules.cpp.
.SS "typedef nspace::hash_map<\fBstd::string\fP, \fBWhoWasUser\fP*, nspace::hash<\fBstring\fP>, \fBirc::StrHashComp\fP> \fBwhowas_hash\fP"
.PP
Definition at line 118 of file modules.cpp.
.SH "Function Documentation"
.PP 
.SS "bool DoAddExtendedMode (char modechar, int type, bool requires_oper, int params_on, int params_off)"
.PP
Definition at line 215 of file modules.cpp.
.PP
References EMode, and ModeDefined().
.PP
Referenced by Server::AddExtendedListMode(), and Server::AddExtendedMode().
.PP
.nf
216 {
217         if (ModeDefined(modechar,type)) {
218                 return false;
219         }
220         EMode.push_back(ExtMode(modechar,type,requires_oper,params_on,params_off));
221         return true;
222 }
.fi
.PP
.SS "std::vector<\fBircd_module\fP*> factory (255)"
.PP
.SS "bool ModeDefined (char modechar, int type)"
.PP
Definition at line 152 of file modules.cpp.
.PP
References EMode.
.PP
Referenced by DoAddExtendedMode().
.PP
.nf
153 {
154         for (ExtModeListIter i = EMode.begin(); i < EMode.end(); i++)
155         {
156                 if ((i->modechar == modechar) && (i->type == type))
157                 {
158                         return true;
159                 }
160         }
161         return false;
162 }
.fi
.PP
.SS "int ModeDefinedOff (char modechar, int type)"
.PP
Definition at line 202 of file modules.cpp.
.PP
References EMode.
.PP
.nf
203 {
204         for (ExtModeListIter i = EMode.begin(); i < EMode.end(); i++)
205         {
206                 if ((i->modechar == modechar) && (i->type == type))
207                 {
208                         return i->params_when_off;
209                 }
210         }
211         return 0;
212 }
.fi
.PP
.SS "int ModeDefinedOn (char modechar, int type)"
.PP
Definition at line 189 of file modules.cpp.
.PP
References EMode.
.PP
.nf
190 {
191         for (ExtModeListIter i = EMode.begin(); i < EMode.end(); i++)
192         {
193                 if ((i->modechar == modechar) && (i->type == type))
194                 {
195                         return i->params_when_on;
196                 }
197         }
198         return 0;
199 }
.fi
.PP
.SS "bool ModeDefinedOper (char modechar, int type)"
.PP
Definition at line 176 of file modules.cpp.
.PP
References EMode.
.PP
.nf
177 {
178         for (ExtModeListIter i = EMode.begin(); i < EMode.end(); i++)
179         {
180                 if ((i->modechar == modechar) && (i->type == type) && (i->needsoper == true))
181                 {
182                         return true;
183                 }
184         }
185         return false;
186 }
.fi
.PP
.SS "bool ModeIsListMode (char modechar, int type)"
.PP
Definition at line 164 of file modules.cpp.
.PP
References EMode.
.PP
.nf
165 {
166         for (ExtModeListIter i = EMode.begin(); i < EMode.end(); i++)
167         {
168                 if ((i->modechar == modechar) && (i->type == type) && (i->list == true))
169                 {
170                         return true;
171                 }
172         }
173         return false;
174 }
.fi
.PP
.SS "void ModeMakeList (char modechar)"
.PP
Definition at line 225 of file modules.cpp.
.PP
References EMode, and MT_CHANNEL.
.PP
Referenced by Server::AddExtendedListMode().
.PP
.nf
226 {
227         for (ExtModeListIter i = EMode.begin(); i < EMode.end(); i++)
228         {
229                 if ((i->modechar == modechar) && (i->type == MT_CHANNEL))
230                 {
231                         i->list = true;
232                         return;
233                 }
234         }
235         return;
236 }
.fi
.PP
.SS "std::vector<\fBModule\fP*> modules (255)"
.PP
.SH "Variable Documentation"
.PP 
.SS "char \fBAdminEmail\fP[MAXBUF]"
.PP
.SS "char \fBAdminName\fP[MAXBUF]"
.PP
.SS "char \fBAdminNick\fP[MAXBUF]"
.PP
.SS "int \fBboundPortCount\fP"
.PP
.SS "\fBchan_hash\fP \fBchanlist\fP"
.PP
.SS "\fBuser_hash\fP \fBclientlist\fP"
.PP
.SS "\fBcommand_table\fP \fBcmdlist\fP"
.PP
.SS "std::stringstream \fBconfig_f\fP"
.PP
.SS "int \fBdebugging\fP"
.PP
.SS "int \fBDieDelay\fP"
.PP
.SS "char \fBdiepass\fP[MAXBUF]"
.PP
.SS "char \fBDieValue\fP[MAXBUF]"
.PP
.SS "\fBExtModeList\fP \fBEMode\fP"
.PP
Definition at line 149 of file modules.cpp.
.PP
Referenced by DoAddExtendedMode(), ModeDefined(), ModeDefinedOff(), ModeDefinedOn(), ModeDefinedOper(), ModeIsListMode(), and ModeMakeList().
.SS "std::vector<\fBircd_module\fP*> factory"
.PP
.SS "\fBuserrec\fP* \fBfd_ref_table\fP[65536]"
.PP
.SS "std::vector<\fBstd::string\fP> \fBinclude_stack\fP"
.PP
Referenced by ConfigReader::ConfigReader().
.SS "\fBaddress_cache\fP \fBIP\fP"
.PP
.SS "char \fBlist\fP[MAXBUF]"
.PP
.SS "FILE* \fBlog_file\fP"
.PP
.SS "int \fBLogLevel\fP"
.PP
.SS "int \fBMaxWhoResults\fP"
.PP
Definition at line 81 of file channels.cpp.
.SS "int \fBMODCOUNT\fP = -1"
.PP
Definition at line 1005 of file modules.cpp.
.SS "std::vector<\fBstd::string\fP> \fBmodule_names\fP"
.PP
.SS "std::vector<\fBInspSocket\fP*> \fBmodule_sockets\fP"
.PP
Referenced by Server::AddSocket(), and Server::DelSocket().
.SS "std::vector<\fBModule\fP*> modules"
.PP
.SS "\fBfile_cache\fP \fBMOTD\fP"
.PP
.SS "char \fBmotd\fP[MAXBUF]"
.PP
.SS "time_t \fBnb_start\fP"
.PP
.SS "int \fBNetBufferSize\fP"
.PP
.SS "char \fBNetwork\fP[MAXBUF]"
.PP
.SS "int \fBportCount\fP"
.PP
.SS "int \fBports\fP[MAXSOCKS]"
.PP
.SS "char \fBPrefixQuit\fP[MAXBUF]"
.PP
.SS "char \fBrestartpass\fP[MAXBUF]"
.PP
.SS "\fBfile_cache\fP \fBRULES\fP"
.PP
.SS "char \fBrules\fP[MAXBUF]"
.PP
.SS "\fBSocketEngine\fP* \fBSE\fP"
.PP
.SS "char \fBServerDesc\fP[MAXBUF]"
.PP
.SS "char \fBServerName\fP[MAXBUF]"
.PP
.SS "time_t \fBstartup_time\fP"
.PP
.SS "time_t \fBTIME\fP"
.PP
.SS "\fBwhowas_hash\fP \fBwhowas\fP"
.PP
.SS "int \fBWHOWAS_MAX\fP"
.PP
.SS "int \fBWHOWAS_STALE\fP"
.PP
.SH "Author"
.PP 
Generated automatically by Doxygen for InspIRCd from the source code.
