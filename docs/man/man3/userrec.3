.TH "userrec" 3 "7 May 2005" "InspIRCd" \" -*- nroff -*-
.ad l
.nh
.SH NAME
userrec \- Holds all information about a user This class stores all information about a user connected to the irc server.  

.PP
.SH SYNOPSIS
.br
.PP
\fC#include <users.h>\fP
.PP
Inherits \fBconnection\fP.
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBuserrec\fP ()"
.br
.ti -1c
.RI "virtual \fB~userrec\fP ()"
.br
.ti -1c
.RI "virtual char * \fBGetFullHost\fP ()"
.br
.RI "\fIReturns the full displayed host of the user This member function returns the hostname of the user as seen by other users on the server, in nick!identhost form. \fP"
.ti -1c
.RI "virtual char * \fBGetFullRealHost\fP ()"
.br
.RI "\fIReturns the full real host of the user This member function returns the hostname of the user as seen by other users on the server, in nick!identhost form. \fP"
.ti -1c
.RI "virtual bool \fBIsInvited\fP (char *channel)"
.br
.RI "\fIReturns true if a user is invited to a channel. \fP"
.ti -1c
.RI "virtual void \fBInviteTo\fP (char *channel)"
.br
.RI "\fIAdds a channel to a users invite list (invites them to a channel). \fP"
.ti -1c
.RI "virtual void \fBRemoveInvite\fP (char *channel)"
.br
.RI "\fIRemoves a channel from a users invite list. \fP"
.ti -1c
.RI "bool \fBHasPermission\fP (char *command)"
.br
.RI "\fIReturns true or false for if a user can execute a privilaged oper command. \fP"
.ti -1c
.RI "bool \fBAddBuffer\fP (std::string a)"
.br
.RI "\fIThis method adds data to the buffer of the user. \fP"
.ti -1c
.RI "bool \fBBufferIsReady\fP ()"
.br
.RI "\fIThis method returns true if the buffer contains at least one carriage return character (e.g. \fP"
.ti -1c
.RI "void \fBClearBuffer\fP ()"
.br
.RI "\fIThis function clears the entire buffer by setting it to an empty string. \fP"
.ti -1c
.RI "std::string \fBGetBuffer\fP ()"
.br
.RI "\fIThis method returns the first available string at the tail end of the buffer and advances the tail end of the buffer past the string. \fP"
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "char \fBnick\fP [NICKMAX]"
.br
.RI "\fIThe users nickname. \fP"
.ti -1c
.RI "char \fBident\fP [64]"
.br
.RI "\fIThe users ident reply. \fP"
.ti -1c
.RI "char \fBdhost\fP [256]"
.br
.RI "\fIThe host displayed to non-opers (used for cloaking etc). \fP"
.ti -1c
.RI "char \fBfullname\fP [128]"
.br
.RI "\fIThe users full name. \fP"
.ti -1c
.RI "char \fBmodes\fP [MAXBUF]"
.br
.RI "\fIThe user's mode string. \fP"
.ti -1c
.RI "\fBucrec\fP \fBchans\fP [MAXCHANS]"
.br
.ti -1c
.RI "char \fBserver\fP [256]"
.br
.RI "\fIThe server the user is connected to. \fP"
.ti -1c
.RI "char \fBawaymsg\fP [512]"
.br
.RI "\fIThe user's away message. \fP"
.ti -1c
.RI "char \fBresult\fP [256]"
.br
.RI "\fIStores the result of the last GetFullHost or GetRealHost call. \fP"
.ti -1c
.RI "int \fBflood\fP"
.br
.RI "\fINumber of lines the user can place into the buffer (up to the global NetBufferSize bytes) before they are disconnected for excess flood. \fP"
.ti -1c
.RI "unsigned long \fBtimeout\fP"
.br
.RI "\fINumber of seconds this user is given to send USER/NICK If they do not send their details in this time limit they will be disconnected. \fP"
.ti -1c
.RI "char \fBoper\fP [NICKMAX]"
.br
.RI "\fIThe oper type they logged in as, if they are an oper. \fP"
.ti -1c
.RI "bool \fBdns_done\fP"
.br
.RI "\fITrue when \fBDNS\fP lookups are completed. \fP"
.ti -1c
.RI "unsigned long \fBpingmax\fP"
.br
.RI "\fINumber of seconds between PINGs for this user (set from <connect:allow> tag. \fP"
.ti -1c
.RI "char \fBpassword\fP [MAXBUF]"
.br
.RI "\fIPassword specified by the user when they registered. \fP"
.ti -1c
.RI "std::string \fBrecvq\fP"
.br
.RI "\fIUser's receive queue. \fP"
.ti -1c
.RI "long \fBlines_in\fP"
.br
.RI "\fIFlood counters. \fP"
.ti -1c
.RI "time_t \fBreset_due\fP"
.br
.ti -1c
.RI "long \fBthreshold\fP"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fBInvitedList\fP \fBinvites\fP"
.br
.RI "\fIA list of channels the user has a pending invite to. \fP"
.in -1c
.SH "Detailed Description"
.PP 
Holds all information about a user This class stores all information about a user connected to the irc server. 

Everything about a connection is stored here primarily, from the user's socket ID (file descriptor) through to the user's nickname and hostname. Use the Find method of the server class to locate a specific user by nickname. 
.PP
Definition at line 98 of file users.h.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "userrec::userrec ()"
.PP
Definition at line 28 of file users.cpp.
.PP
References awaymsg, connection::bytes_in, connection::bytes_out, ucrec::channel, chans, connection::cmds_in, connection::cmds_out, dhost, dns_done, connection::fd, flood, fullname, connection::haspassed, connection::host, ident, connection::idle_lastmsg, connection::inbuf, invites, connection::ip, connection::lastping, lines_in, modes, nick, connection::nping, oper, connection::port, recvq, connection::registered, reset_due, result, server, connection::signon, TIME, timeout, and ucrec::uc_modes.
.PP
.nf
29 {
30         // the PROPER way to do it, AVOID bzero at *ALL* costs
31         strcpy(nick,'');
32         strcpy(ip,'127.0.0.1');
33         timeout = 0;
34         strcpy(ident,'');
35         strcpy(host,'');
36         strcpy(dhost,'');
37         strcpy(fullname,'');
38         strcpy(modes,'');
39         strcpy(inbuf,'');
40         strcpy(server,'');
41         strcpy(awaymsg,'');
42         strcpy(oper,'');
43         reset_due = TIME;
44         lines_in = 0;
45         fd = lastping = signon = idle_lastmsg = nping = registered = 0;
46         flood = port = bytes_in = bytes_out = cmds_in = cmds_out = 0;
47         haspassed = false;
48         dns_done = false;
49         recvq = '';
50         strcpy(result,'');
51         for (int i = 0; i < MAXCHANS; i++)
52         {
53                 this->chans[i].channel = NULL;
54                 this->chans[i].uc_modes = 0;
55         }
56         invites.clear();
57 }
.fi
.SS "virtual userrec::~\fBuserrec\fP ()\fC [inline, virtual]\fP"
.PP
Definition at line 195 of file users.h.
.PP
.nf
195 {  }
.fi
.SH "Member Function Documentation"
.PP 
.SS "bool userrec::AddBuffer (std::string a)"
.PP
This method adds data to the buffer of the user. The buffer can grow to any size within limits of the available memory, managed by the size of a std::string, however if any individual line in the buffer grows over 600 bytes in length (which is 88 chars over the RFC-specified limit per line) then the method will return false and the text will not be inserted.Definition at line 169 of file users.cpp.
.PP
References recvq.
.PP
.nf
170 {
171         std::string b = '';
172         for (int i = 0; i < a.length(); i++)
173                 if ((a[i] != '\r') && (a[i] != '\0') && (a[i] != 7))
174                         b = b + a[i];
175         std::stringstream stream(recvq);
176         stream << b;
177         recvq = stream.str();
178         int i = 0;
179         // count the size of the first line in the buffer.
180         while (i < recvq.length())
181         {
182                 if (recvq[i++] == '\n')
183                         break;
184         }
185         // return false if we've had more than 600 characters WITHOUT
186         // a carriage return (this is BAD, drop the socket)
187         return (i < 600);
188 }
.fi
.SS "bool userrec::BufferIsReady ()"
.PP
This method returns true if the buffer contains at least one carriage return character (e.g. one complete line may be read)Definition at line 190 of file users.cpp.
.PP
References recvq.
.PP
.nf
191 {
192         for (int i = 0; i < recvq.length(); i++)
193                 if (recvq[i] == '\n')
194                         return true;
195         return false;
196 }
.fi
.SS "void userrec::ClearBuffer ()"
.PP
This function clears the entire buffer by setting it to an empty string. Definition at line 198 of file users.cpp.
.PP
References recvq.
.PP
Referenced by Server::PseudoToUser(), and Server::UserToPseudo().
.PP
.nf
199 {
200         recvq = '';
201 }
.fi
.SS "std::string userrec::GetBuffer ()"
.PP
This method returns the first available string at the tail end of the buffer and advances the tail end of the buffer past the string. This means it is a one way operation in a similar way to strtok(), and multiple calls return multiple lines if they are available. The results of this function if there are no lines to be read are unknown, always use \fBBufferIsReady()\fP to check if it is ok to read the buffer before calling \fBGetBuffer()\fP.Definition at line 203 of file users.cpp.
.PP
References recvq.
.PP
.nf
204 {
205         if (recvq == '')
206                 return '';
207         char* line = (char*)recvq.c_str();
208         std::string ret = '';
209         while ((*line != '\n') && (strlen(line)))
210         {
211                 ret = ret + *line;
212                 line++;
213         }
214         if ((*line == '\n') || (*line == '\r'))
215                 line++;
216         recvq = line;
217         return ret;
218 }
.fi
.SS "char * userrec::GetFullHost ()\fC [virtual]\fP"
.PP
Returns the full displayed host of the user This member function returns the hostname of the user as seen by other users on the server, in nick!identhost form. Definition at line 61 of file users.cpp.
.PP
References dhost, ident, nick, and result.
.PP
.nf
62 {
63         snprintf(result,MAXBUF,'%s!%s@%s',nick,ident,dhost);
64         return result;
65 }
.fi
.SS "char * userrec::GetFullRealHost ()\fC [virtual]\fP"
.PP
Returns the full real host of the user This member function returns the hostname of the user as seen by other users on the server, in nick!identhost form. If any form of hostname cloaking is in operation, e.g. through a module, then this method will ignore it and return the true hostname.Definition at line 68 of file users.cpp.
.PP
References connection::host, ident, nick, and result.
.PP
.nf
69 {
70         snprintf(result,MAXBUF,'%s!%s@%s',nick,ident,host);
71         return result;
72 }
.fi
.SS "bool userrec::HasPermission (char * command)"
.PP
Returns true or false for if a user can execute a privilaged oper command. This is done by looking up their oper type from \fBuserrec::oper\fP, then referencing this to their oper classes and checking the commands they can execute.Definition at line 117 of file users.cpp.
.PP
References config_f, and DEBUG.
.PP
.nf
118 {
119         char TypeName[MAXBUF],Classes[MAXBUF],ClassName[MAXBUF],CommandList[MAXBUF];
120         char* mycmd;
121         char* savept;
122         char* savept2;
123         
124         // are they even an oper at all?
125         if (strchr(this->modes,'o'))
126         {
127                 log(DEBUG,'*** HasPermission: %s is an oper',this->nick);
128                 for (int j =0; j < ConfValueEnum('type',&config_f); j++)
129                 {
130                         ConfValue('type','name',j,TypeName,&config_f);
131                         if (!strcmp(TypeName,this->oper))
132                         {
133                                 log(DEBUG,'*** HasPermission: %s is an oper of type '%s'',this->nick,this->oper);
134                                 ConfValue('type','classes',j,Classes,&config_f);
135                                 char* myclass = strtok_r(Classes,' ',&savept);
136                                 while (myclass)
137                                 {
138                                         log(DEBUG,'*** HasPermission: checking classtype '%s'',myclass);
139                                         for (int k =0; k < ConfValueEnum('class',&config_f); k++)
140                                         {
141                                                 ConfValue('class','name',k,ClassName,&config_f);
142                                                 if (!strcmp(ClassName,myclass))
143                                                 {
144                                                         ConfValue('class','commands',k,CommandList,&config_f);
145                                                         log(DEBUG,'*** HasPermission: found class named %s with commands: '%s'',ClassName,CommandList);
146                                                         
147                                                         
148                                                         mycmd = strtok_r(CommandList,' ',&savept2);
149                                                         while (mycmd)
150                                                         {
151                                                                 if (!strcasecmp(mycmd,command))
152                                                                 {
153                                                                         log(DEBUG,'*** Command %s found, returning true',command);
154                                                                         return true;
155                                                                 }
156                                                                 mycmd = strtok_r(NULL,' ',&savept2);
157                                                         }
158                                                 }
159                                         }
160                                         myclass = strtok_r(NULL,' ',&savept);
161                                 }
162                         }
163                 }
164         }
165         return false;
166 }
.fi
.SS "void userrec::InviteTo (char * channel)\fC [virtual]\fP"
.PP
Adds a channel to a users invite list (invites them to a channel). Definition at line 88 of file users.cpp.
.PP
References Invited::channel, and invites.
.PP
.nf
89 {
90         Invited i;
91         strlcpy(i.channel,channel,CHANMAX);
92         invites.push_back(i);
93 }
.fi
.SS "bool userrec::IsInvited (char * channel)\fC [virtual]\fP"
.PP
Returns true if a user is invited to a channel. Definition at line 74 of file users.cpp.
.PP
References invites.
.PP
.nf
75 {
76         for (InvitedList::iterator i = invites.begin(); i != invites.end(); i++)
77         {
78                 if (i->channel) {
79                         if (!strcasecmp(i->channel,channel))
80                         {
81                                 return true;
82                         }
83                 }
84         }
85         return false;
86 }
.fi
.SS "void userrec::RemoveInvite (char * channel)\fC [virtual]\fP"
.PP
Removes a channel from a users invite list. This member function is called on successfully joining an invite only channel to which the user has previously been invited, to clear the invitation.Definition at line 95 of file users.cpp.
.PP
References DEBUG, and invites.
.PP
.nf
96 {
97         log(DEBUG,'Removing invites');
98         if (channel)
99         {
100                 if (invites.size())
101                 {
102                         for (InvitedList::iterator i = invites.begin(); i != invites.end(); i++)
103                         {
104                                 if (i->channel)
105                                 {
106                                         if (!strcasecmp(i->channel,channel))
107                                         {
108                                                 invites.erase(i);
109                                                 return;
110                                         }
111                                 }
112                         }
113                 }
114         }
115 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "char \fBuserrec::awaymsg\fP[512]"
.PP
The user's away message. If this string is empty, the user is not marked as away.Definition at line 141 of file users.h.
.PP
Referenced by userrec().
.SS "\fBucrec\fP \fBuserrec::chans\fP[MAXCHANS]"
.PP
Definition at line 132 of file users.h.
.PP
Referenced by Server::PseudoToUser(), and userrec().
.SS "char \fBuserrec::dhost\fP[256]"
.PP
The host displayed to non-opers (used for cloaking etc). This usually matches the value of \fBuserrec::host\fP.Definition at line 120 of file users.h.
.PP
Referenced by GetFullHost(), and userrec().
.SS "bool \fBuserrec::dns_done\fP"
.PP
True when \fBDNS\fP lookups are completed. Definition at line 169 of file users.h.
.PP
Referenced by userrec().
.SS "int \fBuserrec::flood\fP"
.PP
Number of lines the user can place into the buffer (up to the global NetBufferSize bytes) before they are disconnected for excess flood. Definition at line 152 of file users.h.
.PP
Referenced by userrec().
.SS "char \fBuserrec::fullname\fP[128]"
.PP
The users full name. Definition at line 124 of file users.h.
.PP
Referenced by userrec().
.SS "char \fBuserrec::ident\fP[64]"
.PP
The users ident reply. Definition at line 115 of file users.h.
.PP
Referenced by GetFullHost(), GetFullRealHost(), Server::PseudoToUser(), userrec(), and Server::UserToPseudo().
.SS "\fBInvitedList\fP \fBuserrec::invites\fP\fC [private]\fP"
.PP
A list of channels the user has a pending invite to. Definition at line 104 of file users.h.
.PP
Referenced by InviteTo(), IsInvited(), RemoveInvite(), and userrec().
.SS "long \fBuserrec::lines_in\fP"
.PP
Flood counters. Definition at line 189 of file users.h.
.PP
Referenced by userrec().
.SS "char \fBuserrec::modes\fP[MAXBUF]"
.PP
The user's mode string. This may contain any of the following RFC characters: o, w, s, i Your module may define other mode characters as it sees fit.Definition at line 130 of file users.h.
.PP
Referenced by userrec().
.SS "char \fBuserrec::nick\fP[NICKMAX]"
.PP
The users nickname. An invalid nickname indicates an unregistered connection prior to the NICK command.Definition at line 111 of file users.h.
.PP
Referenced by ConfigReader::DumpErrors(), GetFullHost(), GetFullRealHost(), Server::PseudoToUser(), and userrec().
.SS "char \fBuserrec::oper\fP[NICKMAX]"
.PP
The oper type they logged in as, if they are an oper. This is used to check permissions in operclasses, so that we can say 'yay' or 'nay' to any commands they issue. The value of this is the value of a valid 'type name=' tag.Definition at line 165 of file users.h.
.PP
Referenced by userrec().
.SS "char \fBuserrec::password\fP[MAXBUF]"
.PP
Password specified by the user when they registered. This is stored even if the  block doesnt need a password, so that modules may check it.Definition at line 179 of file users.h.
.SS "unsigned long \fBuserrec::pingmax\fP"
.PP
Number of seconds between PINGs for this user (set from <connect:allow> tag. Definition at line 173 of file users.h.
.SS "std::string \fBuserrec::recvq\fP"
.PP
User's receive queue. Lines from the IRCd awaiting processing are stored here. Upgraded april 2005, old system a bit hairy.Definition at line 185 of file users.h.
.PP
Referenced by AddBuffer(), BufferIsReady(), ClearBuffer(), GetBuffer(), and userrec().
.SS "time_t \fBuserrec::reset_due\fP"
.PP
Definition at line 190 of file users.h.
.PP
Referenced by userrec().
.SS "char \fBuserrec::result\fP[256]"
.PP
Stores the result of the last GetFullHost or GetRealHost call. You may use this to increase the speed of use of this class.Definition at line 146 of file users.h.
.PP
Referenced by GetFullHost(), GetFullRealHost(), and userrec().
.SS "char \fBuserrec::server\fP[256]"
.PP
The server the user is connected to. Definition at line 136 of file users.h.
.PP
Referenced by userrec().
.SS "long \fBuserrec::threshold\fP"
.PP
Definition at line 191 of file users.h.
.SS "unsigned long \fBuserrec::timeout\fP"
.PP
Number of seconds this user is given to send USER/NICK If they do not send their details in this time limit they will be disconnected. Definition at line 158 of file users.h.
.PP
Referenced by userrec().

.SH "Author"
.PP 
Generated automatically by Doxygen for InspIRCd from the source code.
