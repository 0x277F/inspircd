.TH "userrec" 3 "19 Dec 2005" "Version 1.0Betareleases" "InspIRCd" \" -*- nroff -*-
.ad l
.nh
.SH NAME
userrec \- Holds all information about a user This class stores all information about a user connected to the irc server.  

.PP
.SH SYNOPSIS
.br
.PP
\fC#include <users.h>\fP
.PP
Inherits \fBconnection\fP.
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBuserrec\fP ()"
.br
.ti -1c
.RI "virtual char * \fBGetFullHost\fP ()"
.br
.RI "\fIReturns the full displayed host of the user This member function returns the hostname of the user as seen by other users on the server, in nick!identhost form. \fP"
.ti -1c
.RI "virtual char * \fBGetFullRealHost\fP ()"
.br
.RI "\fIReturns the full real host of the user This member function returns the hostname of the user as seen by other users on the server, in nick!identhost form. \fP"
.ti -1c
.RI "virtual bool \fBIsInvited\fP (\fBirc::string\fP &channel)"
.br
.RI "\fIReturns true if a user is invited to a channel. \fP"
.ti -1c
.RI "virtual void \fBInviteTo\fP (\fBirc::string\fP &channel)"
.br
.RI "\fIAdds a channel to a users invite list (invites them to a channel). \fP"
.ti -1c
.RI "virtual void \fBRemoveInvite\fP (\fBirc::string\fP &channel)"
.br
.RI "\fIRemoves a channel from a users invite list. \fP"
.ti -1c
.RI "bool \fBHasPermission\fP (\fBstd::string\fP &command)"
.br
.RI "\fIReturns true or false for if a user can execute a privilaged oper command. \fP"
.ti -1c
.RI "int \fBReadData\fP (void *buffer, size_t size)"
.br
.RI "\fICalls read() to read some data for this user using their fd. \fP"
.ti -1c
.RI "bool \fBAddBuffer\fP (\fBstd::string\fP a)"
.br
.RI "\fIThis method adds data to the buffer of the user. \fP"
.ti -1c
.RI "bool \fBBufferIsReady\fP ()"
.br
.RI "\fIThis method returns true if the buffer contains at least one carriage return character (e.g. \fP"
.ti -1c
.RI "void \fBClearBuffer\fP ()"
.br
.RI "\fIThis function clears the entire buffer by setting it to an empty string. \fP"
.ti -1c
.RI "\fBstd::string\fP \fBGetBuffer\fP ()"
.br
.RI "\fIThis method returns the first available string at the tail end of the buffer and advances the tail end of the buffer past the string. \fP"
.ti -1c
.RI "void \fBSetWriteError\fP (\fBstd::string\fP error)"
.br
.RI "\fISets the write error for a connection. \fP"
.ti -1c
.RI "\fBstd::string\fP \fBGetWriteError\fP ()"
.br
.RI "\fIReturns the write error which last occured on this connection or an empty string if none occured. \fP"
.ti -1c
.RI "void \fBAddWriteBuf\fP (\fBstd::string\fP data)"
.br
.RI "\fIAdds to the user's write buffer. \fP"
.ti -1c
.RI "void \fBFlushWriteBuf\fP ()"
.br
.RI "\fIFlushes as much of the user's buffer to the file descriptor as possible. \fP"
.ti -1c
.RI "\fBInvitedList\fP * \fBGetInviteList\fP ()"
.br
.RI "\fIReturns the list of channels this user has been invited to but has not yet joined. \fP"
.ti -1c
.RI "void \fBCloseSocket\fP ()"
.br
.RI "\fIShuts down and closes the user's socket. \fP"
.ti -1c
.RI "virtual \fB~userrec\fP ()"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "char \fBnick\fP [NICKMAX]"
.br
.RI "\fIThe users nickname. \fP"
.ti -1c
.RI "char \fBident\fP [IDENTMAX+2]"
.br
.RI "\fIThe users ident reply. \fP"
.ti -1c
.RI "char \fBdhost\fP [160]"
.br
.RI "\fIThe host displayed to non-opers (used for cloaking etc). \fP"
.ti -1c
.RI "char \fBfullname\fP [MAXGECOS+1]"
.br
.RI "\fIThe users full name. \fP"
.ti -1c
.RI "char \fBmodes\fP [54]"
.br
.RI "\fIThe user's mode string. \fP"
.ti -1c
.RI "std::vector< \fBucrec\fP > \fBchans\fP"
.br
.ti -1c
.RI "char * \fBserver\fP"
.br
.RI "\fIThe server the user is connected to. \fP"
.ti -1c
.RI "char \fBawaymsg\fP [MAXAWAY+1]"
.br
.RI "\fIThe user's away message. \fP"
.ti -1c
.RI "int \fBflood\fP"
.br
.RI "\fINumber of lines the user can place into the buffer (up to the global NetBufferSize bytes) before they are disconnected for excess flood. \fP"
.ti -1c
.RI "unsigned int \fBtimeout\fP"
.br
.RI "\fINumber of seconds this user is given to send USER/NICK If they do not send their details in this time limit they will be disconnected. \fP"
.ti -1c
.RI "char \fBoper\fP [NICKMAX]"
.br
.RI "\fIThe oper type they logged in as, if they are an oper. \fP"
.ti -1c
.RI "bool \fBdns_done\fP"
.br
.RI "\fITrue when \fBDNS\fP lookups are completed. \fP"
.ti -1c
.RI "unsigned int \fBpingmax\fP"
.br
.RI "\fINumber of seconds between PINGs for this user (set from <connect:allow> tag. \fP"
.ti -1c
.RI "char \fBpassword\fP [MAXBUF]"
.br
.RI "\fIPassword specified by the user when they registered. \fP"
.ti -1c
.RI "\fBstd::string\fP \fBrecvq\fP"
.br
.RI "\fIUser's receive queue. \fP"
.ti -1c
.RI "\fBstd::string\fP \fBsendq\fP"
.br
.RI "\fIUser's send queue. \fP"
.ti -1c
.RI "int \fBlines_in\fP"
.br
.RI "\fIFlood counters. \fP"
.ti -1c
.RI "time_t \fBreset_due\fP"
.br
.ti -1c
.RI "long \fBthreshold\fP"
.br
.ti -1c
.RI "\fBstd::string\fP \fBWriteError\fP"
.br
.ti -1c
.RI "long \fBsendqmax\fP"
.br
.RI "\fIMaximum size this user's sendq can become. \fP"
.ti -1c
.RI "long \fBrecvqmax\fP"
.br
.RI "\fIMaximum size this user's recvq can become. \fP"
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fBInvitedList\fP \fBinvites\fP"
.br
.RI "\fIA list of channels the user has a pending invite to. \fP"
.in -1c
.SH "Detailed Description"
.PP 
Holds all information about a user This class stores all information about a user connected to the irc server. 

Everything about a connection is stored here primarily, from the user's socket ID (file descriptor) through to the user's nickname and hostname. Use the Find method of the server class to locate a specific user by nickname.
.PP
Definition at line 115 of file users.h.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "userrec::userrec ()"
.PP
Definition at line 63 of file users.cpp.
.PP
References awaymsg, connection::bytes_in, connection::bytes_out, chans, connection::cmds_in, connection::cmds_out, dhost, dns_done, connection::fd, FindServerNamePtr(), flood, fullname, connection::haspassed, connection::host, ident, connection::idle_lastmsg, invites, connection::ip, connection::lastping, lines_in, modes, nick, connection::nping, oper, connection::port, recvq, connection::registered, reset_due, sendq, server, ServerConfig::ServerName, connection::signon, TIME, and timeout.
.PP
.nf
64 {
65         // the PROPER way to do it, AVOID bzero at *ALL* costs
66         strcpy(nick,'');
67         strcpy(ip,'127.0.0.1');
68         timeout = 0;
69         strcpy(ident,'');
70         strcpy(host,'');
71         strcpy(dhost,'');
72         strcpy(fullname,'');
73         strcpy(modes,'');
74         server = (char*)FindServerNamePtr(Config->ServerName);
75         strcpy(awaymsg,'');
76         strcpy(oper,'');
77         reset_due = TIME;
78         lines_in = 0;
79         fd = lastping = signon = idle_lastmsg = nping = registered = 0;
80         flood = port = bytes_in = bytes_out = cmds_in = cmds_out = 0;
81         haspassed = false;
82         dns_done = false;
83         recvq = '';
84         sendq = '';
85         chans.clear();
86         invites.clear();
87 }
.fi
.PP
.SS "userrec::~userrec ()\fC [virtual]\fP"
.PP
Definition at line 89 of file users.cpp.
.PP
.nf
90 {
91 }
.fi
.PP
.SH "Member Function Documentation"
.PP 
.SS "bool userrec::AddBuffer (\fBstd::string\fP a)"
.PP
This method adds data to the buffer of the user. 
.PP
The buffer can grow to any size within limits of the available memory, managed by the size of a \fBstd::string\fP, however if any individual line in the buffer grows over 600 bytes in length (which is 88 chars over the RFC-specified limit per line) then the method will return false and the text will not be inserted.
.PP
Definition at line 219 of file users.cpp.
.PP
References recvq, recvqmax, SetWriteError(), and WriteOpers().
.PP
.nf
220 {
221         std::string b = '';
222         for (unsigned int i = 0; i < a.length(); i++)
223                 if ((a[i] != '\r') && (a[i] != '\0') && (a[i] != 7))
224                         b = b + a[i];
225         std::stringstream stream(recvq);
226         stream << b;
227         recvq = stream.str();
228         unsigned int i = 0;
229         // count the size of the first line in the buffer.
230         while (i < recvq.length())
231         {
232                 if (recvq[i++] == '\n')
233                         break;
234         }
235         if (recvq.length() > (unsigned)this->recvqmax)
236         {
237                 this->SetWriteError('RecvQ exceeded');
238                 WriteOpers('*** User %s RecvQ of %d exceeds connect class maximum of %d',this->nick,recvq.length(),this->recvqmax);
239         }
240         // return false if we've had more than 600 characters WITHOUT
241         // a carriage return (this is BAD, drop the socket)
242         return (i < 600);
243 }
.fi
.PP
.SS "void userrec::AddWriteBuf (\fBstd::string\fP data)"
.PP
Adds to the user's write buffer. 
.PP
You may add any amount of text up to this users sendq value, if you exceed the sendq value, \fBSetWriteError()\fP will be called to set the users error string to 'SendQ exceeded', and further buffer adds will be dropped.
.PP
Definition at line 275 of file users.cpp.
.PP
References sendq, sendqmax, SetWriteError(), and WriteOpers().
.PP
.nf
276 {
277         if (this->GetWriteError() != '')
278                 return;
279         if (sendq.length() + data.length() > (unsigned)this->sendqmax)
280         {
281                 /* Fix by brain - Set the error text BEFORE calling writeopers, because
282                  * if we dont it'll recursively  call here over and over again trying
283                  * to repeatedly add the text to the sendq!
284                  */
285                 this->SetWriteError('SendQ exceeded');
286                 WriteOpers('*** User %s SendQ of %d exceeds connect class maximum of %d',this->nick,sendq.length() + data.length(),this->sendqmax);
287                 return;
288         }
289         std::stringstream stream;
290         stream << sendq << data;
291         sendq = stream.str();
292 }
.fi
.PP
.SS "bool userrec::BufferIsReady ()"
.PP
This method returns true if the buffer contains at least one carriage return character (e.g. 
.PP
one complete line may be read)
.PP
Definition at line 245 of file users.cpp.
.PP
References recvq.
.PP
.nf
246 {
247         for (unsigned int i = 0; i < recvq.length(); i++)
248                 if (recvq[i] == '\n')
249                         return true;
250         return false;
251 }
.fi
.PP
.SS "void userrec::ClearBuffer ()"
.PP
This function clears the entire buffer by setting it to an empty string. 
.PP
Definition at line 253 of file users.cpp.
.PP
References recvq.
.PP
Referenced by Server::PseudoToUser(), and Server::UserToPseudo().
.PP
.nf
254 {
255         recvq = '';
256 }
.fi
.PP
.SS "void userrec::CloseSocket ()"
.PP
Shuts down and closes the user's socket. 
.PP
Definition at line 93 of file users.cpp.
.PP
Referenced by kill_link(), and kill_link_silent().
.PP
.nf
94 {
95         shutdown(this->fd,2);
96         close(this->fd);
97 }
.fi
.PP
.SS "void userrec::FlushWriteBuf ()"
.PP
Flushes as much of the user's buffer to the file descriptor as possible. 
.PP
This function may not always flush the entire buffer, rather instead as much of it as it possibly can. If the send() call fails to send the entire buffer, the buffer position is advanced forwards and the rest of the data sent at the next call to this method.
.PP
Definition at line 295 of file users.cpp.
.PP
References connection::bytes_out, connection::cmds_out, sendq, and SetWriteError().
.PP
Referenced by kill_link(), and kill_link_silent().
.PP
.nf
296 {
297         if (sendq.length())
298         {
299                 char* tb = (char*)this->sendq.c_str();
300                 int n_sent = write(this->fd,tb,this->sendq.length());
301                 if (n_sent == -1)
302                 {
303                         this->SetWriteError(strerror(errno));
304                 }
305                 else
306                 {
307                         // advance the queue
308                         tb += n_sent;
309                         this->sendq = tb;
310                         // update the user's stats counters
311                         this->bytes_out += n_sent;
312                         this->cmds_out++;
313                 }
314         }
315 }
.fi
.PP
.SS "\fBstd::string\fP userrec::GetBuffer ()"
.PP
This method returns the first available string at the tail end of the buffer and advances the tail end of the buffer past the string. 
.PP
This means it is a one way operation in a similar way to strtok(), and multiple calls return multiple lines if they are available. The results of this function if there are no lines to be read are unknown, always use \fBBufferIsReady()\fP to check if it is ok to read the buffer before calling \fBGetBuffer()\fP.
.PP
Definition at line 258 of file users.cpp.
.PP
References recvq.
.PP
.nf
259 {
260         if (recvq == '')
261                 return '';
262         char* line = (char*)recvq.c_str();
263         std::string ret = '';
264         while ((*line != '\n') && (strlen(line)))
265         {
266                 ret = ret + *line;
267                 line++;
268         }
269         if ((*line == '\n') || (*line == '\r'))
270                 line++;
271         recvq = line;
272         return ret;
273 }
.fi
.PP
.SS "char * userrec::GetFullHost ()\fC [virtual]\fP"
.PP
Returns the full displayed host of the user This member function returns the hostname of the user as seen by other users on the server, in nick!identhost form. 
.PP
Definition at line 99 of file users.cpp.
.PP
References dhost, ident, and nick.
.PP
Referenced by add_channel().
.PP
.nf
100 {
101         static char result[MAXBUF];
102         snprintf(result,MAXBUF,'%s!%s@%s',nick,ident,dhost);
103         return result;
104 }
.fi
.PP
.SS "char * userrec::GetFullRealHost ()\fC [virtual]\fP"
.PP
Returns the full real host of the user This member function returns the hostname of the user as seen by other users on the server, in nick!identhost form. 
.PP
If any form of hostname cloaking is in operation, e.g. through a module, then this method will ignore it and return the true hostname.
.PP
Definition at line 116 of file users.cpp.
.PP
References connection::host, ident, and nick.
.PP
.nf
117 {
118         static char fresult[MAXBUF];
119         snprintf(fresult,MAXBUF,'%s!%s@%s',nick,ident,host);
120         return fresult;
121 }
.fi
.PP
.SS "\fBInvitedList\fP * userrec::GetInviteList ()"
.PP
Returns the list of channels this user has been invited to but has not yet joined. 
.PP
Definition at line 136 of file users.cpp.
.PP
References invites.
.PP
.nf
137 {
138         return &invites;
139 }
.fi
.PP
.SS "\fBstd::string\fP userrec::GetWriteError ()"
.PP
Returns the write error which last occured on this connection or an empty string if none occured. 
.PP
Definition at line 325 of file users.cpp.
.PP
References WriteError.
.PP
.nf
326 {
327         return this->WriteError;
328 }
.fi
.PP
.SS "bool userrec::HasPermission (\fBstd::string\fP & command)"
.PP
Returns true or false for if a user can execute a privilaged oper command. 
.PP
This is done by looking up their oper type from \fBuserrec::oper\fP, then referencing this to their oper classes and checking the commands they can execute.
.PP
Definition at line 165 of file users.cpp.
.PP
References ServerConfig::config_f, ServerConfig::ConfValue(), and is_uline().
.PP
.nf
166 {
167         char TypeName[MAXBUF],Classes[MAXBUF],ClassName[MAXBUF],CommandList[MAXBUF];
168         char* mycmd;
169         char* savept;
170         char* savept2;
171         
172         // users on u-lined servers can completely bypass
173         // all permissions based checks.
174         //
175         // of course, if this is sent to a remote server and this
176         // server is not ulined there, then that other server
177         // silently drops the command.
178         if (is_uline(this->server))
179                 return true;
180         
181         // are they even an oper at all?
182         if (strchr(this->modes,'o'))
183         {
184                 for (int j =0; j < Config->ConfValueEnum('type',&Config->config_f); j++)
185                 {
186                         Config->ConfValue('type','name',j,TypeName,&Config->config_f);
187                         if (!strcmp(TypeName,this->oper))
188                         {
189                                 Config->ConfValue('type','classes',j,Classes,&Config->config_f);
190                                 char* myclass = strtok_r(Classes,' ',&savept);
191                                 while (myclass)
192                                 {
193                                         for (int k =0; k < Config->ConfValueEnum('class',&Config->config_f); k++)
194                                         {
195                                                 Config->ConfValue('class','name',k,ClassName,&Config->config_f);
196                                                 if (!strcmp(ClassName,myclass))
197                                                 {
198                                                         Config->ConfValue('class','commands',k,CommandList,&Config->config_f);
199                                                         mycmd = strtok_r(CommandList,' ',&savept2);
200                                                         while (mycmd)
201                                                         {
202                                                                 if ((!strcasecmp(mycmd,command.c_str())) || (*mycmd == '*'))
203                                                                 {
204                                                                         return true;
205                                                                 }
206                                                                 mycmd = strtok_r(NULL,' ',&savept2);
207                                                         }
208                                                 }
209                                         }
210                                         myclass = strtok_r(NULL,' ',&savept);
211                                 }
212                         }
213                 }
214         }
215         return false;
216 }
.fi
.PP
.SS "void userrec::InviteTo (\fBirc::string\fP & channel)\fC [virtual]\fP"
.PP
Adds a channel to a users invite list (invites them to a channel). 
.PP
Definition at line 141 of file users.cpp.
.PP
References Invited::channel, and invites.
.PP
.nf
142 {
143         Invited i;
144         i.channel = channel;
145         invites.push_back(i);
146 }
.fi
.PP
.SS "bool userrec::IsInvited (\fBirc::string\fP & channel)\fC [virtual]\fP"
.PP
Returns true if a user is invited to a channel. 
.PP
Definition at line 123 of file users.cpp.
.PP
References invites.
.PP
Referenced by add_channel().
.PP
.nf
124 {
125         for (InvitedList::iterator i = invites.begin(); i != invites.end(); i++)
126         {
127                 irc::string compare = i->channel;
128                 if (compare == channel)
129                 {
130                         return true;
131                 }
132         }
133         return false;
134 }
.fi
.PP
.SS "int userrec::ReadData (void * buffer, size_t size)"
.PP
Calls read() to read some data for this user using their fd. 
.PP
Definition at line 106 of file users.cpp.
.PP
.nf
107 {
108         if (this->fd > -1)
109         {
110                 return read(this->fd, buffer, size);
111         }
112         else return 0;
113 }
.fi
.PP
.SS "void userrec::RemoveInvite (\fBirc::string\fP & channel)\fC [virtual]\fP"
.PP
Removes a channel from a users invite list. 
.PP
This member function is called on successfully joining an invite only channel to which the user has previously been invited, to clear the invitation.
.PP
Definition at line 148 of file users.cpp.
.PP
References DEBUG, invites, and log().
.PP
Referenced by add_channel().
.PP
.nf
149 {
150         log(DEBUG,'Removing invites');
151         if (invites.size())
152         {
153                 for (InvitedList::iterator i = invites.begin(); i != invites.end(); i++)
154                 {
155                         irc::string compare = i->channel;
156                         if (compare == channel)
157                         {
158                                 invites.erase(i);
159                                 return;
160                         }
161                 }
162         }
163 }
.fi
.PP
.SS "void userrec::SetWriteError (\fBstd::string\fP error)"
.PP
Sets the write error for a connection. 
.PP
This is done because the actual disconnect of a client may occur at an inopportune time such as half way through /LIST output. The WriteErrors of clients are checked at a more ideal time (in the mainloop) and errored clients purged.
.PP
Definition at line 317 of file users.cpp.
.PP
References DEBUG, log(), and WriteError.
.PP
Referenced by AddBuffer(), AddWriteBuf(), and FlushWriteBuf().
.PP
.nf
318 {
319         log(DEBUG,'Setting error string for %s to '%s'',this->nick,error.c_str());
320         // don't try to set the error twice, its already set take the first string.
321         if (this->WriteError == '')
322                 this->WriteError = error;
323 }
.fi
.PP
.SH "Member Data Documentation"
.PP 
.SS "char \fBuserrec::awaymsg\fP[MAXAWAY+1]"
.PP
The user's away message. 
.PP
If this string is empty, the user is not marked as away.
.PP
Definition at line 162 of file users.h.
.PP
Referenced by userrec().
.SS "std::vector<\fBucrec\fP> \fBuserrec::chans\fP"
.PP
Definition at line 153 of file users.h.
.PP
Referenced by add_channel(), del_channel(), kick_channel(), Server::PseudoToUser(), and userrec().
.SS "char \fBuserrec::dhost\fP[160]"
.PP
The host displayed to non-opers (used for cloaking etc). 
.PP
This usually matches the value of \fBuserrec::host\fP.
.PP
Definition at line 138 of file users.h.
.PP
Referenced by AddWhoWas(), GetFullHost(), and userrec().
.SS "bool \fBuserrec::dns_done\fP"
.PP
True when \fBDNS\fP lookups are completed. 
.PP
Definition at line 185 of file users.h.
.PP
Referenced by ConnectUser(), and userrec().
.SS "int \fBuserrec::flood\fP"
.PP
Number of lines the user can place into the buffer (up to the global NetBufferSize bytes) before they are disconnected for excess flood. 
.PP
Definition at line 168 of file users.h.
.PP
Referenced by userrec().
.SS "char \fBuserrec::fullname\fP[MAXGECOS+1]"
.PP
The users full name. 
.PP
Definition at line 142 of file users.h.
.PP
Referenced by AddWhoWas(), and userrec().
.SS "char \fBuserrec::ident\fP[IDENTMAX+2]"
.PP
The users ident reply. 
.PP
Two characters are added to the user-defined limit to compensate for the tilde etc.
.PP
Definition at line 133 of file users.h.
.PP
Referenced by AddWhoWas(), FullConnectUser(), GetFullHost(), GetFullRealHost(), kill_link(), kill_link_silent(), Server::PseudoToUser(), userrec(), and Server::UserToPseudo().
.SS "\fBInvitedList\fP \fBuserrec::invites\fP\fC [private]\fP"
.PP
A list of channels the user has a pending invite to. 
.PP
Definition at line 121 of file users.h.
.PP
Referenced by GetInviteList(), InviteTo(), IsInvited(), RemoveInvite(), and userrec().
.SS "int \fBuserrec::lines_in\fP"
.PP
Flood counters. 
.PP
Definition at line 210 of file users.h.
.PP
Referenced by userrec().
.SS "char \fBuserrec::modes\fP[54]"
.PP
The user's mode string. 
.PP
This may contain any of the following RFC characters: o, w, s, i Your module may define other mode characters as it sees fit. it is limited to length 54, as there can only be a maximum of 52 user modes (26 upper, 26 lower case) a null terminating char, and an optional + character.
.PP
Definition at line 151 of file users.h.
.PP
Referenced by add_channel(), and userrec().
.SS "char \fBuserrec::nick\fP[NICKMAX]"
.PP
The users nickname. 
.PP
An invalid nickname indicates an unregistered connection prior to the NICK command.
.PP
Definition at line 128 of file users.h.
.PP
Referenced by add_channel(), AddWhoWas(), del_channel(), ConfigReader::DumpErrors(), FullConnectUser(), GetFullHost(), GetFullRealHost(), kick_channel(), kill_link(), kill_link_silent(), Server::PseudoToUser(), and userrec().
.SS "char \fBuserrec::oper\fP[NICKMAX]"
.PP
The oper type they logged in as, if they are an oper. 
.PP
This is used to check permissions in operclasses, so that we can say 'yay' or 'nay' to any commands they issue. The value of this is the value of a valid 'type name=' tag.
.PP
Definition at line 181 of file users.h.
.PP
Referenced by userrec().
.SS "char \fBuserrec::password\fP[MAXBUF]"
.PP
Password specified by the user when they registered. 
.PP
This is stored even if the <connect> block doesnt need a password, so that modules may check it.
.PP
Definition at line 195 of file users.h.
.SS "unsigned int \fBuserrec::pingmax\fP"
.PP
Number of seconds between PINGs for this user (set from <connect:allow> tag. 
.PP
Definition at line 189 of file users.h.
.SS "\fBstd::string\fP \fBuserrec::recvq\fP"
.PP
User's receive queue. 
.PP
Lines from the IRCd awaiting processing are stored here. Upgraded april 2005, old system a bit hairy.
.PP
Definition at line 201 of file users.h.
.PP
Referenced by AddBuffer(), BufferIsReady(), ClearBuffer(), GetBuffer(), and userrec().
.SS "long \fBuserrec::recvqmax\fP"
.PP
Maximum size this user's recvq can become. 
.PP
Definition at line 224 of file users.h.
.PP
Referenced by AddBuffer().
.SS "time_t \fBuserrec::reset_due\fP"
.PP
Definition at line 211 of file users.h.
.PP
Referenced by userrec().
.SS "\fBstd::string\fP \fBuserrec::sendq\fP"
.PP
User's send queue. 
.PP
Lines waiting to be sent are stored here until their buffer is flushed.
.PP
Definition at line 206 of file users.h.
.PP
Referenced by AddWriteBuf(), FlushWriteBuf(), and userrec().
.SS "long \fBuserrec::sendqmax\fP"
.PP
Maximum size this user's sendq can become. 
.PP
Definition at line 220 of file users.h.
.PP
Referenced by AddWriteBuf().
.SS "char* \fBuserrec::server\fP"
.PP
The server the user is connected to. 
.PP
Definition at line 157 of file users.h.
.PP
Referenced by AddWhoWas(), kick_channel(), and userrec().
.SS "long \fBuserrec::threshold\fP"
.PP
Definition at line 212 of file users.h.
.SS "unsigned int \fBuserrec::timeout\fP"
.PP
Number of seconds this user is given to send USER/NICK If they do not send their details in this time limit they will be disconnected. 
.PP
Definition at line 174 of file users.h.
.PP
Referenced by userrec().
.SS "\fBstd::string\fP \fBuserrec::WriteError\fP"
.PP
Definition at line 216 of file users.h.
.PP
Referenced by GetWriteError(), and SetWriteError().

.SH "Author"
.PP 
Generated automatically by Doxygen for InspIRCd from the source code.
